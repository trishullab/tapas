---- RULE OF NON-TERMINAL ----

return_type : SomeReturnType | NoReturnType
module_id : SomeModuleId | NoModuleId
except_arg : SomeExceptArg | SomeExceptArgName | NoExceptArg
param_type : SomeParamType | NoParamType
param_default : SomeParamDefault | NoParamDefault
parameters_d : ConsKwParam | SingleKwParam | DictionarySplatParam
parameters_c : SingleListSplatParam | TransListSplatParam | ParamsD
parameters_b : ConsParam | SingleParam | ParamsC
parameters : ParamsA | ParamsB | NoParam
parameters_a : ConsPosParam | SinglePosParam | TransPosParam
keyword : NamedKeyword | SplatKeyword
alias : SomeAlias | NoAlias
alias_expr : SomeAliasExpr | NoAliasExpr
bases : SomeBases | NoBases
bases_a : ConsBase | SingleBase | KeywordsBase
keywords : ConsKeyword | SingleKeyword
comparisons : ConsCompareRight | SingleCompareRight
option_expr : SomeExpr | NoExpr
comma_exprs : ConsExpr | SingleExpr
target_exprs : ConsTargetExpr | SingleTargetExpr
decorators : ConsDec | NoDec
constraint_filters : ConsFilter | SingleFilter | NoFilter
sequence_string : ConsStr | SingleStr
arguments : ConsArg | SingleArg | KeywordsArg
dictionary_contents : ConsField | SingleField
sequence_var : ConsId | SingleId
sequence_ImportName : ConsImportName | SingleImportName
sequence_Withitem : ConsWithitem | SingleWithitem
statements : ConsStmt | SingleStmt
comprehension_constraints : ConsConstraint | SingleConstraint
sequence_ExceptHandler : ConsExceptHandler | SingleExceptHandler
conditions : ElifCond | ElseCond | NoCond
function_def : FunctionDef | AsyncFunctionDef
stmt : DecFunctionDef | DecAsyncFunctionDef | DecClassDef | ReturnSomething | Return | Delete | Assign | AugAssign | TypedAssign | TypedDeclare | For | ForElse | AsyncFor | AsyncForElse | While | WhileElse | If | With | AsyncWith | Raise | RaiseExc | RaiseFrom | Try | TryElse | TryFin | TryElseFin | Assert | AssertMsg | Import | ImportFrom | ImportWildCard | Global | Nonlocal | Expr | Pass | Break | Continue
expr : BoolOp | NamedExpr | BinOp | UnaryOp | Lambda | IfExp | Dictionary | EmptyDictionary | Set | ListComp | SetComp | DictionaryComp | GeneratorExp | Await | YieldNothing | Yield | YieldFrom | Compare | Call | CallArgs | Integer | Float | ConcatString | True_ | False_ | None_ | Ellip | Attribute | Subscript | Starred | Name | List | EmptyList | Tuple | EmptyTuple | Slice
boolop : And | Or
operator : Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv
unaryop : Invert | Not | UAdd | USub
cmpop : Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
constraint : AsyncConstraint | Constraint
Module : Module
CompareRight : CompareRight
ExceptHandler : ExceptHandler
Param : Param
Field : Field
ImportName : ImportName
Withitem : Withitem
ClassDef : ClassDef
ElifBlock : ElifBlock
ElseBlock : ElseBlock
FinallyBlock : FinallyBlock


---- RULE OF SEQUENCE ----

SomeReturnType :: ` -> ` (grammar : InLine : contents : expr) ``
NoReturnType :: `` 
SomeModuleId :: `` (vocab : contents : module_identifier)
NoModuleId :: `.` 
SomeExceptArg :: ` ` (grammar : InLine : contents : expr) ``
SomeExceptArgName :: ` ` (grammar : InLine : contents : expr) ` as ` (vocab : name : identifier)
NoExceptArg :: `` 
SomeParamType :: ` : ` (grammar : InLine : contents : expr) ``
NoParamType :: `` 
SomeParamDefault :: ` = ` (grammar : InLine : contents : expr) ``
NoParamDefault :: `` 
ConsKwParam :: `` (grammar : InLine : head : Param) `, ` (grammar : InLine : tail : parameters_d) ``
SingleKwParam :: `` (grammar : InLine : contents : Param) ``
DictionarySplatParam :: `**` (grammar : InLine : contents : Param) ``
SingleListSplatParam :: `*` (grammar : InLine : contents : Param) ``
TransListSplatParam :: `*` (grammar : InLine : head : Param) `, ` (grammar : InLine : tail : parameters_d) ``
ParamsD :: `*, ` (grammar : InLine : contents : parameters_d) ``
ConsParam :: `` (grammar : InLine : head : Param) `, ` (grammar : InLine : tail : parameters_b) ``
SingleParam :: `` (grammar : InLine : contents : Param) ``
ParamsC :: `` (grammar : InLine : contents : parameters_c) ``
ParamsA :: `` (grammar : InLine : contents : parameters_a) ``
ParamsB :: `` (grammar : InLine : contents : parameters_b) ``
NoParam :: `` 
ConsPosParam :: `` (grammar : InLine : head : Param) `, ` (grammar : InLine : tail : parameters_a) ``
SinglePosParam :: `` (grammar : InLine : contents : Param) `, /`
TransPosParam :: `` (grammar : InLine : head : Param) `, /, ` (grammar : InLine : tail : parameters_b) ``
NamedKeyword :: `` (vocab : name : identifier) (grammar : InLine : contents : expr) ``
SplatKeyword :: `**` (grammar : InLine : contents : expr) ``
SomeAlias :: ` as ` (vocab : contents : identifier)
NoAlias :: `` 
SomeAliasExpr :: ` as ` (grammar : InLine : contents : expr) ``
NoAliasExpr :: `` 
SomeBases :: `(` (grammar : InLine : bases : bases_a) `)`
NoBases :: `` 
ConsBase :: `` (grammar : InLine : head : expr) `, ` (grammar : InLine : tail : bases_a) ``
SingleBase :: `` (grammar : InLine : contents : expr) ``
KeywordsBase :: `` (grammar : InLine : kws : keywords) ``
ConsKeyword :: `` (grammar : InLine : head : keyword) `, ` (grammar : InLine : tail : keywords) ``
SingleKeyword :: `` (grammar : InLine : contents : keyword) ``
ConsCompareRight :: `` (grammar : InLine : head : CompareRight) ` ` (grammar : InLine : tail : comparisons) ``
SingleCompareRight :: `` (grammar : InLine : contents : CompareRight) ``
SomeExpr :: `` (grammar : InLine : contents : expr) ``
NoExpr :: `` 
ConsExpr :: `` (grammar : InLine : head : expr) `, ` (grammar : InLine : tail : comma_exprs) ``
SingleExpr :: `` (grammar : InLine : contents : expr) ``
ConsTargetExpr :: `` (grammar : InLine : head : expr) ` = ` (grammar : InLine : tail : target_exprs) ``
SingleTargetExpr :: `` (grammar : InLine : contents : expr) ``
ConsDec :: `@` (grammar : InLine : head : expr) `` (grammar : InLine : tail : decorators) ``
NoDec :: `` 
ConsFilter :: `if ` (grammar : NewLine : head : expr) `` (grammar : InLine : tail : constraint_filters) ``
SingleFilter :: `if ` (grammar : NewLine : contents : expr) ``
NoFilter :: `` 
ConsStr :: `` (vocab : head : string) (grammar : InLine : tail : sequence_string) ``
SingleStr :: `` (vocab : contents : string)
ConsArg :: `` (grammar : InLine : head : expr) `, ` (grammar : InLine : tail : arguments) ``
SingleArg :: `` (grammar : InLine : contents : expr) ``
KeywordsArg :: `` (grammar : InLine : kws : keywords) ``
ConsField :: `` (grammar : InLine : head : Field) `, ` (grammar : NewLine : tail : dictionary_contents) ``
SingleField :: `` (grammar : InLine : contents : Field) ``
ConsId :: `` (vocab : head : identifier) (grammar : InLine : tail : sequence_var) ``
SingleId :: `` (vocab : contents : identifier)
ConsImportName :: `` (grammar : InLine : head : ImportName) `, ` (grammar : InLine : tail : sequence_ImportName) ``
SingleImportName :: `` (grammar : InLine : contents : ImportName) ``
ConsWithitem :: `` (grammar : InLine : head : Withitem) `, ` (grammar : InLine : tail : sequence_Withitem) ``
SingleWithitem :: `` (grammar : InLine : contents : Withitem) ``
ConsStmt :: `` (grammar : InLine : head : stmt) `` (grammar : NewLine : tail : statements) ``
SingleStmt :: `` (grammar : InLine : contents : stmt) ``
ConsConstraint :: `` (grammar : InLine : head : constraint) `` (grammar : NewLine : tail : comprehension_constraints) ``
SingleConstraint :: `` (grammar : InLine : contents : constraint) ``
ConsExceptHandler :: `` (grammar : InLine : head : ExceptHandler) `` (grammar : NewLine : tail : sequence_ExceptHandler) ``
SingleExceptHandler :: `` (grammar : InLine : contents : ExceptHandler) ``
ElifCond :: `` (grammar : NewLine : contents : ElifBlock) `` (grammar : InLine : tail : conditions) ``
ElseCond :: `` (grammar : NewLine : contents : ElseBlock) ``
NoCond :: `` 
FunctionDef :: `def ` (vocab : name : identifier) (grammar : InLine : params : parameters) `)` (grammar : InLine : ret_typ : return_type) `:` (grammar : IndentLine : body : statements) ``
AsyncFunctionDef :: `def ` (vocab : name : identifier) (grammar : InLine : params : parameters) `)` (grammar : InLine : ret_typ : return_type) `:` (grammar : IndentLine : body : statements) ``
DecFunctionDef :: `` (grammar : InLine : decs : decorators) `` (grammar : NewLine : fun_def : function_def) ``
DecAsyncFunctionDef :: `` (grammar : InLine : decs : decorators) `` (grammar : NewLine : fun_def : function_def) ``
DecClassDef :: `` (grammar : InLine : decs : decorators) `` (grammar : NewLine : class_def : ClassDef) ``
ReturnSomething :: `return ` (grammar : InLine : contents : expr) ``
Return :: `return` 
Delete :: `del` (grammar : InLine : targets : comma_exprs) ``
Assign :: `` (grammar : InLine : targets : target_exprs) ` = ` (grammar : InLine : contents : expr) ``
AugAssign :: `` (grammar : InLine : target : expr) ` ` (grammar : InLine : op : operator) `= ` (grammar : InLine : contents : expr) ``
TypedAssign :: `` (grammar : InLine : target : expr) ` : ` (grammar : InLine : type : expr) ` = ` (grammar : InLine : contents : expr) ``
TypedDeclare :: `` (grammar : InLine : target : expr) ` : ` (grammar : InLine : type : expr) ``
For :: `for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : iter : expr) ` : ` (grammar : IndentLine : body : statements) ``
ForElse :: `for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : iter : expr) ` : ` (grammar : IndentLine : body : statements) `` (grammar : NewLine : orelse : ElseBlock) ``
AsyncFor :: `async for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : iter : expr) ` : ` (grammar : IndentLine : body : statements) ``
AsyncForElse :: `async for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : iter : expr) ` : ` (grammar : IndentLine : body : statements) `` (grammar : NewLine : orelse : ElseBlock) ``
While :: `while ` (grammar : InLine : test : expr) `: ` (grammar : IndentLine : body : statements) ``
WhileElse :: `while ` (grammar : InLine : test : expr) `: ` (grammar : IndentLine : body : statements) `` (grammar : NewLine : orelse : ElseBlock) ``
If :: `if ` (grammar : InLine : test : expr) `: ` (grammar : IndentLine : body : statements) `` (grammar : InLine : orelse : conditions) ``
With :: `with ` (grammar : InLine : items : sequence_Withitem) `:` (grammar : IndentLine : body : statements) ``
AsyncWith :: `async with ` (grammar : InLine : items : sequence_Withitem) `:` (grammar : IndentLine : body : statements) ``
Raise :: `raise` 
RaiseExc :: `raise ` (grammar : IndentLine : exc : expr) ``
RaiseFrom :: `raise ` (grammar : InLine : exc : expr) ` from ` (grammar : InLine : caus : expr) ``
Try :: `try:` (grammar : IndentLine : body : statements) `` (grammar : NewLine : handlers : sequence_ExceptHandler) ``
TryElse :: `try:` (grammar : IndentLine : body : statements) `` (grammar : NewLine : handlers : sequence_ExceptHandler) `` (grammar : NewLine : orelse : ElseBlock) ``
TryFin :: `try:` (grammar : IndentLine : body : statements) `` (grammar : NewLine : handlers : sequence_ExceptHandler) `` (grammar : NewLine : fin : FinallyBlock) ``
TryElseFin :: `try:` (grammar : IndentLine : body : statements) `` (grammar : NewLine : handlers : sequence_ExceptHandler) `` (grammar : NewLine : orelse : ElseBlock) `` (grammar : NewLine : fin : FinallyBlock) ``
Assert :: `assert ` (grammar : InLine : test : expr) ``
AssertMsg :: `assert ` (grammar : InLine : test : expr) `, ` (grammar : InLine : msg : expr) ``
Import :: `import ` (grammar : InLine : names : sequence_ImportName) ``
ImportFrom :: `from ` (grammar : InLine : module : module_id) ` import ` (grammar : InLine : names : sequence_ImportName) ``
ImportWildCard :: `from ` (grammar : InLine : module : module_id) ` import *`
Global :: `global ` (grammar : InLine : names : sequence_var) ``
Nonlocal :: `nonlocal ` (grammar : InLine : names : sequence_var) ``
Expr :: `` (grammar : InLine : contents : expr) ``
Pass :: `pass` 
Break :: `break` 
Continue :: `continue` 
BoolOp :: `(` (grammar : InLine : left : expr) ` ` (grammar : InLine : op : boolop) ` ` (grammar : InLine : right : expr) `)`
NamedExpr :: `` (grammar : InLine : target : expr) ` := ` (grammar : InLine : contents : expr) ``
BinOp :: `(` (grammar : InLine : left : expr) ` ` (grammar : InLine : op : operator) ` ` (grammar : InLine : right : expr) `)`
UnaryOp :: `(` (grammar : InLine : op : unaryop) ` ` (grammar : InLine : right : expr) `)`
Lambda :: `lambda ` (grammar : InLine : params : parameters) ` :` (grammar : InLine : body : expr) ``
IfExp :: `` (grammar : InLine : body : expr) `if ` (grammar : InLine : test : expr) ` else` (grammar : NewLine : orelse : expr) ``
Dictionary :: `{` (grammar : IndentLine : contents : dictionary_contents) `}`
EmptyDictionary :: `{}` 
Set :: `{` (grammar : IndentLine : contents : comma_exprs) `}`
ListComp :: `[` (grammar : IndentLine : contents : expr) `` (grammar : IndentLine : constraints : comprehension_constraints) `]`
SetComp :: `{` (grammar : IndentLine : contents : expr) `` (grammar : IndentLine : constraints : comprehension_constraints) `}`
DictionaryComp :: `{` (grammar : IndentLine : key : expr) ` : ` (grammar : InLine : contents : expr) `` (grammar : IndentLine : constraints : comprehension_constraints) `}`
GeneratorExp :: `(` (grammar : IndentLine : contents : expr) `` (grammar : IndentLine : constraints : comprehension_constraints) `)`
Await :: `await ` (grammar : InLine : contents : expr) ``
YieldNothing :: `yield` 
Yield :: `yield ` (grammar : InLine : contents : expr) ``
YieldFrom :: `yield from ` (grammar : InLine : contents : expr) ``
Compare :: `` (grammar : InLine : left : expr) ` ` (grammar : InLine : comps : comparisons) ``
Call :: `` (grammar : InLine : func : expr) `()`
CallArgs :: `` (grammar : InLine : func : expr) `(` (grammar : InLine : args : arguments) `)`
Integer :: `` (vocab : contents : integer)
Float :: `` (vocab : contents : float)
ConcatString :: `` (grammar : InLine : contents : sequence_string) ``
True_ :: `True` 
False_ :: `False` 
None_ :: `None` 
Ellip :: `...` 
Attribute :: `` (grammar : InLine : contents : expr) `.` (vocab : name : identifier)
Subscript :: `` (grammar : InLine : contents : expr) `[` (grammar : InLine : slice : expr) `]`
Starred :: `*` (grammar : InLine : contents : expr) ``
Name :: `` (vocab : contents : identifier)
List :: `[` (grammar : InLine : contents : comma_exprs) `]`
EmptyList :: `[]` 
Tuple :: `(` (grammar : InLine : contents : comma_exprs) `)`
EmptyTuple :: `()` 
Slice :: `` (grammar : InLine : lower : option_expr) `:` (grammar : InLine : upper : option_expr) `:` (grammar : InLine : step : option_expr) ``
And :: `and` 
Or :: `or` 
Add :: `+` 
Sub :: `-` 
Mult :: `*` 
MatMult :: `@` 
Div :: `/` 
Mod :: `%` 
Pow :: `**` 
LShift :: `<<` 
RShift :: `>>` 
BitOr :: `|` 
BitXor :: `^` 
BitAnd :: `&` 
FloorDiv :: `//` 
Invert :: `~` 
Not :: `not` 
UAdd :: `+` 
USub :: `-` 
Eq :: `==` 
NotEq :: `!=` 
Lt :: `<` 
LtE :: `<=` 
Gt :: `>` 
GtE :: `>=` 
Is :: `is` 
IsNot :: `is not` 
In :: `in` 
NotIn :: `not in` 
AsyncConstraint :: `async for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : search_space : expr) `` (grammar : InLine : filts : constraint_filters) ``
Constraint :: `for ` (grammar : InLine : target : expr) ` in ` (grammar : InLine : search_space : expr) `` (grammar : InLine : filts : constraint_filters) ``
Module :: `` (grammar : InLine : body : statements) ``
CompareRight :: `` (grammar : InLine : op : cmpop) ` ` (grammar : InLine : rand : expr) ``
ExceptHandler :: `except ` (grammar : InLine : arg : except_arg) `:` (grammar : IndentLine : body : statements) ``
Param :: `` (vocab : name : identifier) (grammar : InLine : type : param_type) `` (grammar : InLine : default : param_default) ``
Field :: `` (grammar : InLine : key : expr) ` : ` (grammar : InLine : contents : expr) ``
ImportName :: `` (vocab : name : module_identifier) (grammar : InLine : as_name : alias) ``
Withitem :: `` (grammar : InLine : contet : expr) `` (grammar : InLine : target : alias_expr) ``
ClassDef :: `class ` (vocab : name : identifier) (grammar : InLine : bs : bases) `:` (grammar : IndentLine : body : statements) ``
ElifBlock :: `elif ` (grammar : InLine : test : expr) `:` (grammar : IndentLine : body : statements) ``
ElseBlock :: `else:` (grammar : IndentLine : body : statements) ``
FinallyBlock :: `finally:` (grammar : IndentLine : body : statements) ``
