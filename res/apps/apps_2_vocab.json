{
    "module_identifier": [
        "regex",
        "heappush",
        "array",
        "log10",
        "PriorityQueue",
        "bisect_left",
        "string",
        "ceil",
        "typing",
        "re",
        "mul",
        "floor",
        "zip_longest",
        "numpy",
        "itertools",
        "chain",
        "log",
        "operator",
        "timedelta",
        "deque",
        "deepcopy",
        "OrderedDict",
        "queue",
        "gcd",
        "Optional",
        "Counter",
        "functools",
        "reduce",
        "bisect",
        "sortedcontainers",
        "ascii_lowercase",
        "permutations",
        "stdin",
        "SortedSet",
        "defaultdict",
        "add",
        "random",
        "count",
        "lru_cache",
        "groupby",
        "Fraction",
        "Dict",
        "insort",
        "takewhile",
        "factorial",
        "fractions",
        "sys",
        "Set",
        "islice",
        "enum",
        "heappop",
        "List",
        "sub",
        "cycle",
        "heapq",
        "datetime",
        "wraps",
        "sqrt",
        "stdout",
        "SortedList",
        "copy",
        "Enum",
        "bisect_right",
        "math",
        "collections"
    ],
    "identifier": [
        "pairs_to_dict",
        "boys_index",
        "lake_to_days",
        "combine",
        "nCommas",
        "SumEvenFibonacci",
        "reindeer",
        "jk",
        "urgency",
        "rightD",
        "aa",
        "isdigit",
        "pd",
        "qval",
        "friend_find",
        "new_l",
        "find_employees_role",
        "happyNow",
        "np",
        "__str__",
        "massV",
        "x",
        "processed",
        "nones",
        "snumber",
        "mountain",
        "fix",
        "rsplit",
        "from_iterable",
        "positives",
        "te",
        "final_arr",
        "best",
        "mx",
        "__sub__",
        "cats",
        "functools",
        "available_dry_day",
        "permutations",
        "complex",
        "new_dp2",
        "makedict",
        "nextRain",
        "vet",
        "header",
        "sieve",
        "med",
        "next_next_pizza_slice",
        "min_word",
        "nCats",
        "al",
        "variables",
        "comb",
        "fold",
        "y1",
        "miny",
        "no_rain",
        "lcs",
        "floor",
        "emptystring",
        "flatten",
        "lis",
        "cd",
        "full_lakes",
        "max",
        "lru_cache",
        "end",
        "trumps",
        "r",
        "lst1",
        "b0",
        "appendleft",
        "pos_max",
        "get",
        "locations",
        "__mul__",
        "indeks",
        "xy",
        "catchingDog",
        "type",
        "solve_linear",
        "factors",
        "update",
        "thearr",
        "cntr2",
        "suff",
        "completions",
        "vary",
        "ohms",
        "solve_runes",
        "amin",
        "MOD",
        "STval",
        "__add__",
        "word",
        "ini",
        "pizza_slice",
        "value_at",
        "__gt__",
        "main",
        "DNA_strand",
        "aCb",
        "digits",
        "fifteens",
        "array_int",
        "capitalize",
        "cur_less_than",
        "bus_price",
        "d_next",
        "returnArray",
        "band",
        "now",
        "delim",
        "hair",
        "find_gcd",
        "node",
        "isupper",
        "op",
        "compute_lcm",
        "right_i",
        "day_to_dry_lake",
        "xs",
        "freeDays",
        "card_2_wins",
        "vertex_set",
        "KMP",
        "cnt",
        "ord",
        "idxDry",
        "g",
        "LEG",
        "new_multiplier",
        "dogs",
        "max_len",
        "row",
        "min_b",
        "passer_rating",
        "structure",
        "cn",
        "sunny_day_idx",
        "AttributeError",
        "empty",
        "spell",
        "nAnd",
        "maketrans",
        "rbody",
        "heappush",
        "m_list",
        "gcd_arr",
        "new_lis",
        "_max",
        "masks",
        "BIT",
        "diviser",
        "group",
        "traverse",
        "a1",
        "orig",
        "lst_inverted",
        "num_zero",
        "req",
        "idx",
        "trump",
        "set1",
        "size",
        "sum",
        "products",
        "width",
        "startPos",
        "SortedList",
        "hashmap",
        "colors",
        "card_1",
        "valToInt",
        "right_val",
        "L_LEGS",
        "split_string",
        "total_products",
        "recursive",
        "isalpha",
        "myList",
        "ctlt",
        "denominator",
        "bucket",
        "hoursRest",
        "Result1",
        "second",
        "summax",
        "intersection",
        "prev_pizza_slice",
        "full",
        "Cook",
        "x2y2",
        "replace",
        "DFS",
        "new_arr",
        "newq",
        "threes",
        "lakes",
        "current_max",
        "testNums",
        "group_groceries",
        "option",
        "j",
        "caught",
        "outro",
        "nodes",
        "dry_on_day_index",
        "prev_pos",
        "memoized",
        "rains",
        "predicate",
        "str2",
        "return_arr",
        "cache",
        "next_pizza_slice_pos",
        "numMusicPlaylists",
        "cents",
        "currb",
        "swapcase",
        "mediantN",
        "minb",
        "fibonacci",
        "numsegs",
        "trim",
        "returnArr",
        "pr",
        "drydays",
        "candy",
        "att",
        "_acc",
        "min_a",
        "next_wet_day",
        "out",
        "eachletter",
        "num1",
        "tc",
        "notplayed",
        "sin",
        "method2",
        "zl",
        "cntr",
        "v1",
        "insort",
        "TestSolution",
        "flush",
        "_cache",
        "last_day_rains_over_lake",
        "append",
        "ValueError",
        "answer",
        "card_game",
        "__import__",
        "COLORS",
        "tour",
        "right_char",
        "cap",
        "array",
        "printer",
        "T",
        "cap_s",
        "four",
        "bisect_left",
        "strip",
        "right_legs",
        "queue",
        "transform",
        "n",
        "rightN",
        "query",
        "operations",
        "greater",
        "chosen_lake_day",
        "sums",
        "objects",
        "setup",
        "tube_fare",
        "p1",
        "Ymin",
        "pro",
        "polyPlus",
        "numerator",
        "other",
        "INSTRUCTIONS",
        "item",
        "div",
        "st",
        "default",
        "dollars",
        "heap",
        "attempts",
        "chain",
        "no_2",
        "MAXX",
        "add",
        "offset",
        "Q",
        "category",
        "split",
        "pairs",
        "fairy",
        "_len",
        "o",
        "next_lake_index",
        "seconds",
        "xor",
        "par",
        "self",
        "a_1",
        "to_decimal",
        "el",
        "res_sum",
        "elems",
        "zero_indices",
        "ar",
        "__setitem__",
        "jump",
        "i2",
        "rem",
        "won",
        "ind_new",
        "categories",
        "days",
        "next",
        "ip",
        "city",
        "loop",
        "INF",
        "grid_index",
        "precedence",
        "group_string",
        "solved",
        "page_size",
        "popleft",
        "found_numbers",
        "bisect_right",
        "buzz",
        "ilist",
        "minB",
        "newStr",
        "negative",
        "max_index",
        "pp",
        "maxSizeSlices",
        "news",
        "jump_length",
        "lstrip",
        "indexes",
        "Max",
        "titi",
        "lleg",
        "right_s",
        "find_zero_for_lake",
        "str3",
        "massD2",
        "contender",
        "R",
        "object",
        "operator",
        "set",
        "flooded",
        "binarySearch",
        "rota",
        "inf",
        "pizza_slice_pos",
        "high",
        "first_element",
        "inlist",
        "factorize",
        "coeff",
        "lastIndex",
        "backtrack",
        "lst_m",
        "done",
        "current_min",
        "found",
        "fnd",
        "chain_rain",
        "filled_lakes",
        "H",
        "contact",
        "x1",
        "funcs",
        "regex",
        "enumerate",
        "score",
        "prio",
        "sorting",
        "y",
        "__ge__",
        "smallest",
        "max1",
        "nq",
        "sortedcontainers",
        "zero_index",
        "oscar",
        "valchecked",
        "K",
        "x2",
        "str",
        "groups",
        "merkki",
        "longestprefix",
        "N0",
        "original",
        "false",
        "body",
        "neighbors",
        "reqs",
        "branches",
        "l2r",
        "choose",
        "li",
        "hashtable",
        "seti",
        "isinstance",
        "temp2",
        "nextstack",
        "M",
        "children",
        "write",
        "all",
        "LCM",
        "lr",
        "base_num",
        "aux",
        "key",
        "elem",
        "newstring",
        "setdefault",
        "cntb",
        "employees",
        "card_1_wins",
        "tuple",
        "cnts",
        "move",
        "ticket",
        "Poly",
        "i3",
        "ordinal",
        "primes",
        "free",
        "answer_list",
        "binom",
        "london_city_hacker",
        "tiwari",
        "arr1",
        "flag",
        "mouth",
        "id",
        "newlst",
        "ixd",
        "process",
        "test_case",
        "str_num",
        "chars",
        "Y",
        "findLCM",
        "checkto",
        "make_div_3",
        "min_value2",
        "slicesN",
        "is_prime",
        "deck",
        "y_exist",
        "minimum",
        "DisjointSet",
        "dirs",
        "R2_LOW",
        "tube",
        "put",
        "lower",
        "alternate_sort",
        "slices2",
        "n_picks",
        "pq",
        "MAX",
        "inputString",
        "map",
        "midIndex",
        "slice1",
        "minute",
        "indexZ",
        "guesses",
        "new_dp",
        "vegetal",
        "decopm",
        "urgent",
        "grid",
        "page_number",
        "list",
        "first_item",
        "polyMinus",
        "value",
        "catch",
        "prev_prev_pizza_slice",
        "minA",
        "gcd",
        "acc",
        "leg2",
        "cm",
        "sortme",
        "tableau",
        "C",
        "Trie",
        "rstrip",
        "ushijima",
        "poly_spec",
        "res_left",
        "time",
        "find_min_greater",
        "case",
        "__init__",
        "negatives",
        "maxx",
        "eval_string",
        "test_case1",
        "is_isogram",
        "next_lake_day",
        "leg_size",
        "bmin",
        "winner",
        "bus_fare",
        "pop",
        "OrderedDict",
        "col",
        "rix",
        "cmp",
        "el1",
        "tokens",
        "comp",
        "convert",
        "priority",
        "target",
        "digit",
        "islower",
        "sub",
        "List",
        "groceries",
        "cnta",
        "r2",
        "kills",
        "rleg",
        "dbl_linear",
        "STnum",
        "replace_letters",
        "f",
        "positive",
        "ca",
        "takewhile",
        "is_power2",
        "power_law",
        "o2",
        "memoize",
        "dry_sequence",
        "true",
        "parsed",
        "val",
        "Exception",
        "ls2",
        "stg",
        "expression",
        "final_string",
        "special",
        "u",
        "listan2",
        "name",
        "floods",
        "bit_length",
        "new_word",
        "one",
        "minutes",
        "inv",
        "tracker",
        "inverted_list",
        "values",
        "ast",
        "cakes",
        "uind",
        "ALICE",
        "currlength",
        "freeday",
        "l1",
        "character",
        "next_primes",
        "diamonds_and_toads",
        "input",
        "new_list",
        "rain_index",
        "leftN",
        "mex",
        "rest",
        "c",
        "trunc",
        "dollar",
        "__delitem__",
        "poss2",
        "y_dsec_rate",
        "power",
        "last_ids",
        "sep",
        "tnum",
        "could_dry",
        "__gcd",
        "busAccess",
        "dpOff",
        "inp",
        "format_words",
        "tbd",
        "fsociety",
        "q1",
        "gcdl",
        "L",
        "_default",
        "ME",
        "chosen_day",
        "length",
        "part",
        "beard",
        "digits_old",
        "evalvars",
        "ns",
        "hash_left",
        "hash2",
        "__starting_point",
        "prefix",
        "decrease",
        "LX",
        "nidx",
        "input_str",
        "_count",
        "lind",
        "lex",
        "pos",
        "players_list",
        "bol",
        "R1_LOW",
        "massV_ind",
        "product",
        "format",
        "filtered",
        "possible_combo",
        "cards",
        "player",
        "mat",
        "locs",
        "y3",
        "lk",
        "i",
        "ct",
        "left_i",
        "q2",
        "packet",
        "fs",
        "R1_HIGH",
        "two",
        "MIN",
        "islice",
        "CATEGORIES",
        "str_lst",
        "history",
        "mm",
        "B",
        "last_appear",
        "facti",
        "rained",
        "thing",
        "rightIndex",
        "factor_list",
        "binary_search",
        "ng",
        "v",
        "binomial",
        "required",
        "words_sorted",
        "rvalue",
        "who",
        "li_a",
        "b2",
        "index",
        "newliste",
        "day",
        "zeros",
        "booleans",
        "footer",
        "number",
        "o1",
        "range",
        "X",
        "joiner",
        "pref",
        "list2",
        "to_list",
        "nest",
        "isLess",
        "start",
        "total",
        "y4",
        "letter",
        "lastp",
        "LPS",
        "suffix",
        "rec",
        "lake_index",
        "entry",
        "rev",
        "n_bonacci",
        "number_of_variables",
        "kind",
        "sys",
        "great",
        "endswith",
        "journey",
        "body_size",
        "ret",
        "check1",
        "tulos",
        "slices_nodes",
        "t4",
        "res2",
        "fromkeys",
        "strn",
        "obj",
        "powerset",
        "dictionary",
        "used",
        "negb_frac",
        "E",
        "dd",
        "length_of_str",
        "insert",
        "maxim",
        "bus_counter",
        "t1",
        "link",
        "lastrain",
        "poly",
        "recent",
        "check",
        "mina",
        "primesL",
        "fillval",
        "communication_module",
        "isalnum",
        "list_of_baubles",
        "compare",
        "ZeroDivisionError",
        "i1",
        "co",
        "l2",
        "round",
        "multiplyList",
        "items",
        "x1y1",
        "closestNumber",
        "mem",
        "arr",
        "picked",
        "even_fib",
        "color2",
        "si",
        "weights",
        "draw_spider",
        "TR",
        "q",
        "Xmax",
        "ski_jump",
        "fid",
        "NUM",
        "ch",
        "mn",
        "stack",
        "primes2",
        "PriorityQueue",
        "ORDERS",
        "sn",
        "data1",
        "calc",
        "baubles_on_tree",
        "sum_digits",
        "sum_even_fibonacci",
        "ints",
        "binary",
        "ix",
        "_query",
        "codes",
        "girls",
        "stk",
        "rstring",
        "caracter",
        "lis3",
        "final",
        "min_ind",
        "dp1",
        "polyAns",
        "max_sum",
        "fill",
        "zero_lake",
        "make",
        "race",
        "startVal",
        "tube_price",
        "_size",
        "ra",
        "firstElem",
        "Match",
        "_check",
        "isBus",
        "bin",
        "symbol",
        "numpy",
        "timedelta",
        "x_data",
        "__repr__",
        "RESISTOR_COLORS",
        "len_lak",
        "card_2_value",
        "str1",
        "nPick",
        "largest_factor",
        "fizz",
        "encode_resistor_colors",
        "islist",
        "DoublyLinkedListNode",
        "eyes",
        "reference",
        "manager",
        "heapq",
        "system",
        "sumDup",
        "visited",
        "rules",
        "pow",
        "to_string",
        "c2",
        "choice",
        "rains_dict",
        "valsdone",
        "rains_over_city",
        "left_char",
        "filter",
        "c1",
        "seats",
        "num_list",
        "calc_str",
        "vertex_nums",
        "bording",
        "inverse",
        "rain_days",
        "Result",
        "reversed",
        "tab",
        "exoskeletons",
        "leng",
        "bit",
        "make_hash",
        "filled_at",
        "ll",
        "hexdec",
        "find_nearest",
        "taken",
        "n2",
        "remove",
        "bus_str",
        "negative_list",
        "last_idx",
        "fillvalue",
        "bisect_forward",
        "BOB",
        "tyagibagi",
        "cur",
        "ceil",
        "nearest",
        "N",
        "multi",
        "modexp",
        "card_1_value",
        "num2",
        "bisect",
        "r_body",
        "permPrime",
        "ls",
        "temp_str",
        "need",
        "hi",
        "hours",
        "binRota",
        "carne",
        "starred_word",
        "mx_i",
        "needs_trailing_zero",
        "spares",
        "wet",
        "ti",
        "wet_lake",
        "symbols",
        "data2",
        "dig_2",
        "has_rained",
        "drying_strategy",
        "next_ids",
        "comment",
        "yards",
        "p",
        "min_elem",
        "reverse",
        "hex",
        "nx",
        "left_body",
        "nnn",
        "rfind",
        "__lt__",
        "isprime",
        "f0",
        "BIG",
        "idk",
        "saved",
        "ope",
        "I",
        "box",
        "minHp",
        "get_num_ohms",
        "KEY",
        "tovisit",
        "mult",
        "last_rain",
        "ohmS",
        "q0",
        "check2",
        "flips",
        "unpac_lst",
        "base",
        "sentence",
        "n1",
        "next_rain",
        "it",
        "no_1",
        "ss",
        "min",
        "dry_on_day",
        "u0",
        "diff",
        "cal",
        "intersperse",
        "some_list",
        "players",
        "newy",
        "track",
        "judgeCircle",
        "separator",
        "zfill",
        "numero",
        "longestPrefix_bychance_Brute",
        "moves",
        "len_s",
        "create_list",
        "sqrt",
        "availables",
        "new_str",
        "leftIndex",
        "dec",
        "log10",
        "result_choose",
        "sa",
        "spells",
        "ratings",
        "toTest",
        "presents",
        "rv2",
        "desc_len",
        "cnd",
        "fullLake",
        "MULTIPLIER",
        "arbitrate",
        "qsort",
        "sunny",
        "top",
        "poss3",
        "processed_number",
        "findLHS",
        "vap",
        "office",
        "table2",
        "filled",
        "fr",
        "abs",
        "chosen_lake_index",
        "ma",
        "axx",
        "rv1",
        "nthMagicNo",
        "found_zero",
        "dog",
        "notPrime",
        "R_LEGS",
        "get_val",
        "sl",
        "firstSeen",
        "hand",
        "listx",
        "num_digits",
        "array1",
        "massD1",
        "qsize",
        "right",
        "k1",
        "leg",
        "bb",
        "lar",
        "collections",
        "levels",
        "sign",
        "lakesFull",
        "inverse_list",
        "tmp_a",
        "readline",
        "zip",
        "f1",
        "makeGood",
        "mod",
        "initialize",
        "redWith2Blues",
        "partition",
        "rv",
        "my_list",
        "prev_pizza_slice_pos",
        "fact",
        "x3",
        "r1",
        "lenght",
        "left_s",
        "txt",
        "longestPrefix2",
        "hash1",
        "idxs",
        "left",
        "bal",
        "dryDays",
        "maxq",
        "pattern",
        "dedupe",
        "suffixHash",
        "employee",
        "Prime",
        "remaining",
        "pair",
        "__",
        "el2",
        "counter",
        "s1",
        "lake_drying_days",
        "get_win",
        "SegmentTree",
        "Counter",
        "back",
        "prev",
        "slices1",
        "P",
        "bsearch",
        "TrieNode",
        "z",
        "STfire",
        "s2",
        "sort_list",
        "how_about_a_list",
        "temp",
        "from_left",
        "flags",
        "failure",
        "lesser",
        "runes",
        "lbody",
        "q3",
        "prices",
        "dries",
        "hold",
        "num",
        "zs",
        "polyElement",
        "new_string",
        "uni",
        "testcase",
        "fruta",
        "data2R",
        "prev_rain",
        "maxSizeSlicesBruteForce",
        "formatted",
        "_func",
        "massD2_ind",
        "bools",
        "rank_2",
        "mediantD",
        "flat",
        "stdout",
        "avoid",
        "fizzbuzz",
        "dct_lk2day",
        "seq",
        "vehicle",
        "free_days_balance",
        "evaluate",
        "num_doubles",
        "liste",
        "accumulate",
        "d",
        "primel",
        "chunks",
        "fi",
        "curr",
        "touchdowns",
        "kmp",
        "deal",
        "m2",
        "defaultdict",
        "valid",
        "char",
        "suit_1",
        "leo",
        "get_flip",
        "eval",
        "md",
        "dpOn",
        "hcf",
        "earliest_sunny_day",
        "Array",
        "max_adj_sum",
        "f3",
        "total_cost",
        "val2",
        "pat",
        "que2",
        "path",
        "clear",
        "next_index_to_cap",
        "_bisect_forward",
        "new_array",
        "color_bands",
        "reduce",
        "data",
        "version",
        "factorial",
        "phrase",
        "min_string",
        "iter",
        "first_0",
        "lmtbf",
        "wraps",
        "tolerance",
        "table1",
        "mid",
        "cb",
        "argmin",
        "sec",
        "card_2",
        "minflip",
        "lake_tracker",
        "A",
        "memo",
        "number2",
        "discard",
        "level",
        "solution",
        "exps",
        "new",
        "getMin",
        "_gcd",
        "cross_multiply",
        "indx",
        "temp1",
        "dnaComplement",
        "fib",
        "debug",
        "fac",
        "table",
        "ptr",
        "prebit",
        "baubles",
        "up",
        "divmod",
        "ele",
        "retrieved_val",
        "last_indx",
        "only_one",
        "inst",
        "D",
        "find",
        "neg",
        "Solution",
        "rq",
        "initial_number",
        "is_lucky",
        "newx",
        "lcm",
        "a0",
        "mode",
        "que0",
        "cell",
        "new_lst",
        "_",
        "hii",
        "jumpLength",
        "pivot",
        "next_pizza_slice",
        "dry_pos",
        "match",
        "matrix",
        "__len__",
        "checkPalindrome",
        "countg",
        "msg",
        "REGEX_NUMBERS",
        "Ans",
        "yds",
        "dict",
        "height",
        "dry_days",
        "hit",
        "nxt",
        "interceptions",
        "pizza_slices_left",
        "dtype",
        "test_string",
        "ys",
        "deck_dict",
        "sk",
        "compute_gcd",
        "EMPLOYEES_ROLES",
        "token",
        "split_s",
        "left_val",
        "setrecursionlimit",
        "dfs",
        "small",
        "right_body",
        "firstsplit",
        "flat_list",
        "float",
        "maxfact",
        "options",
        "build",
        "questions",
        "findall",
        "tmp",
        "arrangement",
        "prev_idx",
        "nb",
        "gcdf",
        "count",
        "groupby",
        "vl",
        "lstCopy",
        "spi",
        "color1",
        "resultado",
        "logical_or",
        "stop",
        "dc",
        "bitsum",
        "decomp",
        "get_weight",
        "replacing_rules",
        "do",
        "KMPSearch",
        "deadline",
        "REQUIRE",
        "LY",
        "tvl",
        "log",
        "candies",
        "indices",
        "__next__",
        "maxsize",
        "k",
        "b1",
        "facs",
        "dry",
        "__neg__",
        "yi",
        "last_rainy_day",
        "extra",
        "nums",
        "maxVal",
        "numbers",
        "ds",
        "slices",
        "gcdOfStrings",
        "dp2",
        "extra_left",
        "primes_degrees",
        "isnumeric",
        "legs",
        "itertools",
        "min_value",
        "Data",
        "EOFError",
        "invert",
        "ctra",
        "lf",
        "d2",
        "mp",
        "ind",
        "w",
        "val1",
        "k2",
        "prod",
        "mul3",
        "leg1",
        "td",
        "t",
        "gcd_l",
        "searchR",
        "line1",
        "poss",
        "deque",
        "arr4",
        "linear",
        "startswith",
        "s",
        "adjacent_bus_tour",
        "candidate",
        "repeat",
        "_binarySearch",
        "lake",
        "tbl",
        "countB",
        "zix",
        "x_exist",
        "lps",
        "most_common",
        "datetime",
        "unique",
        "eaten",
        "helper",
        "test",
        "randint",
        "text",
        "scntr",
        "left_legs",
        "expIndices",
        "arr3",
        "t3",
        "pieces",
        "a2",
        "po",
        "str_diviser",
        "join",
        "e",
        "rounds",
        "record",
        "sentinel",
        "m",
        "h",
        "polyTimes",
        "results",
        "a",
        "words",
        "cc",
        "slice2",
        "maxi",
        "curr_day",
        "gcd_fd",
        "nn",
        "duplicates",
        "invList",
        "posssible_combo",
        "bus",
        "reach",
        "F",
        "extend",
        "heappop",
        "solve",
        "days_next",
        "cycle",
        "curr_mex",
        "xi",
        "result",
        "free_days",
        "toList",
        "distance",
        "casefold",
        "lst2",
        "listy",
        "best_left",
        "b",
        "dry_day",
        "func",
        "que1",
        "leftD",
        "Build",
        "lis2",
        "array_sort",
        "basicCalculatorIV",
        "clean_string",
        "sort",
        "itr",
        "seat",
        "dic",
        "dig_1",
        "last_rained",
        "Solution2",
        "sol",
        "getCeil",
        "ip_string",
        "day_rev",
        "evalmap",
        "from_right",
        "test_cases",
        "edges",
        "avoidFlood",
        "chiffre",
        "jewels",
        "brands",
        "limit",
        "massD1_ind",
        "indx_chk",
        "zero",
        "fibfusc",
        "ascii_letters",
        "longestPrefix",
        "inverse_lst",
        "sorted_brands",
        "S",
        "lar_fac",
        "indexY",
        "num_s",
        "Set",
        "event",
        "y_data",
        "count_find_num",
        "countA",
        "Enum",
        "water_heap",
        "position",
        "get_color",
        "ps",
        "groce",
        "pw",
        "lst",
        "x_asc_rate",
        "to_choose",
        "minz",
        "ft",
        "pagination_text",
        "res",
        "instruction",
        "pre",
        "gc",
        "alist",
        "stdin",
        "brand",
        "close",
        "free_day",
        "__le__",
        "my_invert",
        "step",
        "double_total",
        "rb",
        "Number",
        "boys",
        "list_s",
        "fives",
        "output",
        "lst_invert",
        "tdp",
        "number_of_words",
        "zeroes",
        "car",
        "wrapped",
        "speed",
        "zip_longest",
        "maxEl",
        "maxSizeSlicesTopDown",
        "parse",
        "open",
        "appears",
        "evalints",
        "randrange",
        "curra",
        "low",
        "nex",
        "p2",
        "last",
        "tmp_acc",
        "RESULTS",
        "to_empty",
        "r2l",
        "result_not_choose",
        "dna",
        "subtract",
        "function",
        "xor_a",
        "v2",
        "suit_2",
        "nxts",
        "y2",
        "get_pre",
        "prime",
        "right_multiplier",
        "gao",
        "sum1",
        "tot",
        "new_s",
        "any",
        "first_ele",
        "lfact",
        "max_so_far",
        "array_operations",
        "zeros_indices",
        "avoidFloodBacktrack",
        "tmp_b",
        "vars",
        "inner",
        "prefixHash",
        "dp",
        "R2_HIGH",
        "extra_right",
        "queue_index",
        "m1",
        "root",
        "mul",
        "eleD",
        "dind",
        "eye",
        "l",
        "to_drain",
        "char_list",
        "ctrb",
        "play",
        "alp",
        "li_b",
        "test_case2",
        "expr",
        "di",
        "hour",
        "output_string",
        "happy",
        "no",
        "toReturn",
        "inverted",
        "cases",
        "math",
        "drys",
        "farey_seq",
        "seen",
        "countb",
        "initial_product",
        "search",
        "sorted",
        "sy",
        "print",
        "integers",
        "lv",
        "__getitem__",
        "counts",
        "fnum",
        "f2",
        "vertex",
        "ex",
        "highest_pos",
        "bool",
        "rain",
        "translate",
        "first",
        "rainSched",
        "lo",
        "last_flood",
        "ohms_string",
        "swimInWater",
        "NINF",
        "translation",
        "list1",
        "maxf",
        "instructions",
        "g2",
        "max_slice",
        "len",
        "get_maxsubseq",
        "_bisect_backward",
        "long",
        "random",
        "Identifier",
        "ln",
        "Fraction",
        "qq",
        "array_1",
        "hash_right",
        "xori",
        "arr2",
        "two_sort",
        "Count",
        "merge",
        "tests",
        "Cur",
        "d1",
        "vals",
        "nbin",
        "ab",
        "num_chars",
        "otput",
        "new_dp1",
        "fgcd",
        "string",
        "mmm",
        "lstn",
        "dct",
        "fin",
        "you",
        "rank_1",
        "positive_list",
        "new_sums",
        "int",
        "plrs",
        "Person",
        "color_map",
        "letters",
        "rainOnLake",
        "Binary",
        "todry",
        "upper",
        "KNOWN",
        "keys",
        "bank",
        "build_or_buy",
        "buf",
        "closest",
        "gcdiv",
        "sLen",
        "chck",
        "avoid_last",
        "pi",
        "f_val",
        "var",
        "same_structure_as",
        "popitem",
        "prm",
        "PRICES",
        "computelps",
        "cur_max",
        "color3",
        "isolbelow",
        "args",
        "climb",
        "ans",
        "drying",
        "r_leg",
        "instr",
        "bitadd",
        "t2",
        "cat",
        "bisect_backward",
        "res_right",
        "rst",
        "max_prefs",
        "chr",
        "let",
        "ctr",
        "s_list",
        "re",
        "get_sum_of_digits",
        "sz",
        "mi",
        "color_digit",
        "element",
        "unused",
        "player_manager",
        "SortedSet",
        "mylist",
        "multiplier",
        "fn",
        "to",
        "result_list",
        "IndexError",
        "sunny_days",
        "line",
        "sm",
        "f_alt"
    ],
    "integer": [
        "30",
        "41",
        "4",
        "25",
        "15",
        "499980",
        "128",
        "999",
        "8",
        "14",
        "20",
        "1000000",
        "111111111",
        "1000009",
        "53456",
        "7",
        "65536",
        "60",
        "29",
        "100000000",
        "499990",
        "68",
        "11",
        "86",
        "100000007",
        "56",
        "18",
        "110000",
        "13",
        "1000",
        "99999",
        "1",
        "33",
        "200",
        "3",
        "0",
        "87",
        "8589934592",
        "51",
        "12",
        "100001",
        "10001",
        "123",
        "88",
        "6",
        "48",
        "100",
        "65",
        "19134702400093278081449423917",
        "180",
        "10000",
        "300",
        "16",
        "0x3f3f3f3f",
        "69",
        "9",
        "5",
        "97",
        "181",
        "58",
        "256",
        "50",
        "1000001",
        "999999999",
        "2",
        "100000",
        "1000000007",
        "10",
        "26",
        "9999",
        "101",
        "40",
        "64",
        "1000005",
        "10000000",
        "3600",
        "31",
        "32",
        "21"
    ],
    "string": [
        "\" metres: He's ok!\"",
        "\"red\"",
        "\"SegmentTree({0})\"",
        "'b,w,g,s,o'",
        "\"E\"",
        "r'[^a-zA-Z]'",
        "'{0}'",
        "'4\u2660'",
        "'{0[first_name]} {0[last_name]}'",
        "'ooogg'",
        "'-?'",
        "'J|'",
        "'1000'",
        "'white'",
        "'3\u2660'",
        "'second'",
        "f\"{lenght:0.2f} metres: Gold!!\"",
        "f\"{distance:.2f} metres: He's ok!\"",
        "\"8\"",
        "'''\nUsing Rabin-Karp incremental hash\nReference:\nhttps://leetcode.com/problems/longest-happy-prefix/discuss/547446/C%2B%2BJava-with-picture-incremental-hash-and-KMP\n'''",
        "\"T\"",
        "\"fruit\"",
        "f'\u00a3{round(s,2):.2f}'",
        "\"\"\" Get the additive inverse of each number in given list. \"\"\"",
        "\"\"\"\n        We only care about the lakes that receive rain multiple times\n        \n        Those lakes will need to, ideally, be drained prior\n        \n        When we see a repeat --- we need to find the first \"Dry\" after the last\n        and pop it\n        \"\"\"",
        "\"bb\"",
        "'aBCdeF'",
        "'black brown red orange yellow green blue violet gray white'",
        "'first_name'",
        "'V'",
        "\"B\"",
        "'k'",
        "f'{c}:{\",\".join(sorted(d[c]))}'",
        "\"Grandma, we will have to buy a Christmas tree first!\"",
        "' '",
        "'''\n        [1,0,2,0,2,1]\n        for lake2 we need to find sunny_day_idx between 2 - 4\n        sunny_day_idx=[1,4] is a increasing array\n        use binary search to find minimum value between prev_day and curr_day\n        \n        '''",
        "'8\u2666'",
        "'orange'",
        "'6\u2665'",
        "'%s*%s'",
        "\"{}\"",
        "f'\u00a3{str(sum)}0'",
        "\"/\\\\%s%s%c%s%s/\\\"",
        "\"city\"",
        "'Grandma, we will have to buy a Christmas tree first!'",
        "'{:0{}b}'",
        "'B7A2'",
        "\"He's crap\"",
        "'violet'",
        "'d.index(c1[:-1])<d.index(c2[:-1])'",
        "'3'",
        "'Z'",
        "''",
        "'A'",
        "'8'",
        "\"fruit meat other vegetable\"",
        "'Showing '",
        "\"0F12\"",
        "\"filee\"",
        "'=='",
        "\"re\"",
        "'Products.'",
        "f\"The {['first','second'][eval(fn)]} card won.\"",
        "\"\"\"\n            using deque canDry to store the possible days that can be used to dry a lake\n            using hasRain to store the lake : day pairs\n            update rules:\n                1) if lake rains[i] rains on day i, check if it has rained before or not\n                    if it has rained before, check if there is a way to dry it \n                        binary search the interval between two rain days\n                    if there is no way to dry it, return []\n                2) if there is no rain on day i, put i in canDry\n        \"\"\"",
        "'Warehouse Manager'",
        "'S'",
        "'YES'",
        "\"_ ^ /\\ /\u2572 \u2571\u2572 \u2571\u2572 \u2571\\ /\\ ^\"",
        "'+'",
        "'brown'",
        "' - '",
        "'2\u2666'",
        "'player'",
        "\"collections\"",
        "r\"(?P<name>[a-zA-Z ]+), (?P<number>[0-9]+)\"",
        "'psPS'",
        "'contact'",
        "'The first card won.'",
        "\"/\u2572\"",
        "\"Case\"",
        "'J'",
        "'Ollie'",
        "'s'",
        "'5\u2663'",
        "f\"{card_1}{card_2}\"",
        "f\"{s}{r}\"",
        "r'(0*1)?(.*)'",
        "\"No\"",
        "\"()*+-\"",
        "'B'",
        "r'{n}([-+*]){n}={n}$'",
        "f\"{category}:{','.join(sorted(items))}\"",
        "'A\u2663'",
        "', '",
        "\"bug(?!s)\"",
        "'Smith'",
        "'3\u2666'",
        "'Q\u2660'",
        "\"/\u2572%s%s%c%s%s\u2571\\\"",
        "\"-\"",
        "' of '",
        "'UDLR'",
        "'ohms'",
        "'to'",
        "\"first\"",
        "'Jewel'",
        "\"bugs\"",
        "\"\u2571\\\\\"",
        "'''\n         construct a 2d dp[i][j] where i is i different songs and\n         j is the length of the playlist, also track the remaining songs r:\n         for dp update, we have two options:\n         if i <= k:\n            1. add a new song to the list, r -= 1\n         else:\n            if r > L-j\n                1. add a new song to the list, r -= 1\n                2. add an existing song\n            else:\n                1. add a new song\n         '''",
        "' ,'",
        "f'{header}{rvalue}{calc:04d}0000{footer}'",
        "\"He's ok\"",
        "\"-1\"",
        "'meat'",
        "' Products.'",
        "\"0\"",
        "'v'",
        "\"Too many presents\"",
        "'{:.2f}'",
        "f'{category}:{\",\".join(sorted(products))}'",
        "'i'",
        "'^'",
        "'\u2571\u2572'",
        "'...'",
        "f\"The {winner} card won.\"",
        "\"7\"",
        "'9\u2665'",
        "'grey'",
        "\"25\"",
        "\"0123456789\"",
        "f\"{jump_length:.2f} metres: He's ok!\"",
        "\"1\"",
        "'''\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from bisect import bisect_left\n        wet = {}\n        ans = [1]*len(rains)\n        dry = []\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.append(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = bisect_left(dry, wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n    '''",
        "\"NO\\n\"",
        "'Not even for Wolf of wallstreet?!'",
        "'Someone cheats.'",
        "'6\u2663'",
        "'1'",
        "'K\u2665'",
        "\"G\"",
        "'Mort'",
        "'\\n'",
        "'K\u2660'",
        "\"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"",
        "' and '",
        "'The second card won.'",
        "\"Ce n'est pas un insecte...\"",
        "'L'",
        "'*1000k'",
        "r'\\bblue blue red\\b|\\bblue red (?=blue\\b)|\\bred (?=blue blue\\b)'",
        "')'",
        "'o'",
        "'4\u2666'",
        "\"Leo finally won the oscar! Leo is happy\"",
        "'Cal'",
        "\"_\"",
        "f'{int(part[2])}{d[part[1]]}{int(part[3])}'",
        "'J\u2666'",
        "\"Gold!\"",
        "\" metres: Gold!!\"",
        "\"?\"",
        "'squirrel'",
        "\"*\"",
        "'/\\\\'",
        "'1234567890'",
        "'Bell'",
        "\"joker\"",
        "f\"{jump_length:.2f} metres: He's crap!\"",
        "'5'",
        "'='",
        "\"6\"",
        "'No'",
        "r'\\d{6}'",
        "'Carmel'",
        "'z'",
        "' to '",
        "r'[^#]((?R)*)#+|\\A#+'",
        "'7\u2665'",
        "'***'",
        "'blue'",
        "\"5\"",
        "'Showing {} to {} of {} Products.'",
        "'inf'",
        "'Let us play again.'",
        "\"))\"",
        "'(\\w+)'",
        "\"#\"",
        "' + '",
        "'Sales Manager'",
        "'\u00a3'",
        "'''\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from sortedcontainers import SortedList\n        wet = {}\n        ans = [1]*len(rains)\n        dry = SortedList()\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.add(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = dry.bisect_left(wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n    '''",
        "'w'",
        "\"TAGC\"",
        "'####'",
        "\"9999\"",
        "\"Case \"",
        "'bg'",
        "\"^%s%s%c%s%s^\"",
        "'%sFFFF%04i0000%s'",
        "'Morty'",
        "'{}:{}'",
        "\"YES\"",
        "'YES\\n1'",
        "'Warehouse Picker'",
        "\"0000\"",
        "r'f(\"\\1\")'",
        "\"Error\"",
        "'maxi'",
        "'Yes'",
        "'8\u2660'",
        "'python'",
        "'last_name'",
        "'Does not work here!'",
        "r'([0-9.]+)([k,M])?'",
        "f\"{lenght:0.2f} metres: He's crap!\"",
        "'9'",
        "f\"He's {'crap' if l < 10 else 'ok' if l < 25 else 'flying'}\"",
        "'''\n            for a given string 'elkmmmelk', prefix elk will be hashed in ascending order.\n            e: 'e': hash[e] = ord(e)\n            l: 'el': hash[el] = hash(e)*128 + ord(l)\n            k: 'elk': hash[elk] = hash(el)*128 + ord(k)\n            which translates to (l * 128 + ord(s[i]))\n\n            suffix elk will be hashed in descending order\n            k: 'k': hash[k] = ord(k)\n            l: 'lk': hash[lk] = ord(k) + ord(l) * 128\n            e: 'elk': hash[elk] = ord(k) + ord(l) * 128 + ord(e) * 128^2\n            which translates to r + pow(128, i, mod)\n            '''",
        "f'Case {i[0]}: {i[1]}'",
        "r\"\\d+\\.?\\d*\"",
        "'1000000'",
        "'rcRC'",
        "'bug'",
        "\"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"",
        "\"\"\"func of data[start, stop)\"\"\"",
        "r'(-?[0-9?]+)([-+*])(-?[0-9?]+)=(-?[0-9?]+)'",
        "\"settlement\"",
        "'8\u2665'",
        "\"Leo got one already!\"",
        "'C'",
        "'evil'",
        "\" \"",
        "\"YES\\n\"",
        "'of'",
        "\"\u2571\u2572\"",
        "'Jones'",
        "r\"(^0|^(-0))[0-9]+\"",
        "'Y'",
        "'R'",
        "\"\"\"Return string describing Leo based on 'oscar'.\n\n    (int) -> str\n\n    Conditions:\n        - If 'oscar' was 88, you should return \"Leo finally won the oscar! Leo is happy\",\n        - If 'oscar' was 86, you should return \"Not even for Wolf of wallstreet?!\",\n        - If 'oscar' was not 88 or 86 (and below 88) you should return \"When will you give Leo an Oscar?\",\n        - If 'oscar' was over 88 you should return \"Leo got one already!\"\n\n    >>> leo(88)\n    \"Leo finally won the oscar! Leo is happy\"\n\n    Example test cases:\n        - test.assert_equals(leo(85),\"When will you give Leo an Oscar?\")\n        - test.assert_equals(leo(86),\"Not even for Wolf of wallstreet?!\")\n        - test.assert_equals(leo(87),\"When will you give Leo an Oscar?\")\n        - test.assert_equals(leo(88),\"Leo finally won the oscar! Leo is happy\")\n        - test.assert_equals(leo(89),\"Leo got one already!\")\n    \"\"\"",
        "\"+\"",
        "'^%s^ /\\%s/\\ /\u2572%s\u2571\\ \u2571\u2572%s\u2571\u2572'",
        "\"b\"",
        "'n'",
        "'''\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        ret = []\n        def dfs(i, has_water, ans):\n            i#print(i, has_water,ans)\n            nonlocal ret\n            if ret: return\n            if i == n:  ret = ans; return \n            if rains[i] in has_water:  return \n            if rains[i]:  dfs(i+1, has_water|set([rains[i]]), ans+[-1])\n            else:\n                if not has_water: dfs(i+1, has_water, ans+[1])\n                for lake in has_water:\n                    has_water.remove(lake)\n                    dfs(i+1, has_water, ans+[lake])\n                    has_water.add(lake)\n        dfs(0, set(), [])\n        return ret\n                    \n'''",
        "\"contact\"",
        "r'\\(|\\)|[a-z]+|[0-9]+|[\\+\\-\\*]'",
        "\"first_name\"",
        "f'FFFF{str(res).zfill(4)}0000'",
        "\"Yes\"",
        "'settlement'",
        "'c2[-1]==t'",
        "\"{}{}{}{}{}{}{}\"",
        "\"role\"",
        "'bug(?!s)'",
        "'{} {}'",
        "'abcdefghijklmnopqrstuvwxyz'",
        "'U'",
        "' * '",
        "\"second\"",
        "'6\u2660'",
        "\"Does not work here!\"",
        "\"vegetable\"",
        "'Leo got one already!'",
        "' dna '",
        "\"\"\"\n[1,2,3,4]\nrain[i] = 0 -> \u62bd\u6c34\u65e5\n    dryDay.insert(i)\nrain[i] = x\n1) x is empty: fill[x] = i\n2) x is full: when to drain x?\n    must be in dryDays\n    must be later than fill[x]\n    \n      1  2  3  4  5  6\nfill  x     y     x \ndryD     -     x \n\n\n\"\"\"",
        "\"Mid index: %d, Mid val: %d, Target: %d\"",
        "'good'",
        "'development'",
        "\"\\n\"",
        "f\"\u00a3{sum(prices):.2f}\"",
        "'#'",
        "'Jesse'",
        "\"%.2f\"",
        "\"The first card won.\"",
        "'7\u2663'",
        "\"\"",
        "\"bug\"",
        "'*1E6'",
        "''' returns a list of prime numbers upto limit.\n    source: Rossetta code: Sieve of Eratosthenes\n    http://rosettacode.org/wiki/Sieve_of_Eratosthenes#Odds-only_version_of_the_array_sieve_above\n    '''",
        "']'",
        "\"***\"",
        "'Sparks'",
        "\"^ ^\"",
        "\"\"\"\n                for x in range(i+1,len(rains)):\n                    print(x,\" is x\")\n                    if rains[x] in d and not rains[x]==0:\n                        #print(d,d[rains[x]],rains[x])\n                        if h: \n                            pop = heappop(h)\n                            print(pop,x,\"compare\")\n                        \n                        d[0]-=1\n                        ans[i] = rains[x]\n                        d[rains[x]]-=1\n                        if d[rains[x]]==0: del d[rains[x]]\n                        break\n                \"\"\"",
        "\"9\"",
        "'9\u2666'",
        "'Trainee'",
        "'I'",
        "'K\u2666'",
        "r'([^\\d]|\\b)0\\d+'",
        "f\"{' '.join(COLORS.get(x) for x in ohms[:2])} {COLORS.get(str(len(ohms[2:]) - 2))} gold\"",
        "'b'",
        "'+-*'",
        "'Neil'",
        "\"bwsg\"",
        "'2345678910JQKA'",
        "'J\u2660'",
        "'''\n    first we sort the array by sort() function :->\n    and then we will take its first element and use it to get output :->\n    '''",
        "\"Gold!!\"",
        "'Tori'",
        "f\"{lenght:0.2f} metres: He's ok!\"",
        "'-'",
        "\")\"",
        "'zeeediiihooooonuuuuutaaaaa'",
        "'C3D9'",
        "'q'",
        "r'(0|-?[1-9?][0-9?]*)'",
        "'red'",
        "\"(\"",
        "'Truck Driver'",
        "'E'",
        "\"bu_gs\"",
        "'Sales Assistant'",
        "'*1000'",
        "'T'",
        "f'{lleg}{lbody}{eye}{mouth}{eye}{rbody}{rleg}'",
        "\"|J\"",
        "'bwsg'",
        "'6'",
        "\"nZero\"",
        "\"python\"",
        "'('",
        "'*1E3'",
        "'Boss'",
        "\"\"\"\n        #O(n^2) working sol\n        ans = [1 for i in range(len(rains))]\n        d = collections.defaultdict(int)\n        d[0]=0\n        \n        for i in range(len(rains)):\n            d[rains[i]]+=1\n            if rains[i]==0:\n                #look for the nearest value that exists in the dict we got\n                for x in range(i+1,len(rains)):\n                    if rains[x] in d and not rains[x]==0:\n                        #print(d,d[rains[x]],rains[x])\n                        d[0]-=1\n                        ans[i] = rains[x]\n                        d[rains[x]]-=1\n                        if d[rains[x]]==0: del d[rains[x]]\n                        break\n            else:\n                #you gotta get out early of a bad pattern that cannot be salvaged\n                if d[rains[i]]>1:\n                    return []\n                ans[i] = -1\n        \n        return ans\n        \"\"\"",
        "\")))\"",
        "'Your goal is to avoid flood.'",
        "\"g\"",
        "'Your country has an infinite number of lakes.'",
        "'m'",
        "'u'",
        "'ruby'",
        "\"bw\"",
        "\"good\"",
        "'X'",
        "'Q\u2663'",
        "'4\u2663'",
        "'Initially, all lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water.'",
        "\"development\"",
        "f\"{n}/{d}\"",
        "\"FFFF\"",
        "'2\u2660'",
        "\"Case {}: {}\"",
        "'.'",
        "'p'",
        "'fruit meat other vegetable'",
        "'0'",
        "\"last_name\"",
        "'Hamm'",
        "f\"{x}:{','.join(sorted(y))}\"",
        "'(^|[+\\-*=])\\?[?\\d]'",
        "'A\u2665'",
        "\"\"\"initialize the segment tree with data\"\"\"",
        "\"2\"",
        "'h'",
        "f\"{x:.2f} metres: {y}!\"",
        "\"The {} card won.\"",
        "f\"{jump_length:.2f} metres: He's flying!\"",
        "f\"\u00a3{tube_price + bus_price:.2f}\"",
        "\"t\"",
        "'5\u2666'",
        "\"D\"",
        "\", \"",
        "'cC'",
        "'Q\u2665'",
        "\"{:.2f}{:s}\"",
        "\"=\"",
        "'aeiou'",
        "f\"{'0'*i}1{(n-i-1)*'0'}\"",
        "\"file\"",
        "f\"{jump_length:.2f} metres: Gold!!\"",
        "\"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"",
        "\"[0-9]{1}\"",
        "'\u2571\\\\'",
        "'9\u2660'",
        "'a'",
        "\"&\"",
        "\"Someone cheats.\"",
        "\"Let us play again.\"",
        "'c2==\"joker\"'",
        "'10\u2660'",
        "\"^\"",
        "'3\u2663'",
        "'gray'",
        "'Showing'",
        "f\"{i}:{j}\"",
        "f\"{header}FFFF{res:0>4}0000{footer}\"",
        "\" metres: He's flying!\"",
        "'3\u2665'",
        "'Receptionist'",
        "'re'",
        "\"B7A2\"",
        "\"{} {} {} gold\"",
        "'Brown'",
        "\"(((\"",
        "\"\"\" Will oscar go to Leonardo DiCaprio? \"\"\"",
        "\"/\\\\\"",
        "\"He's flying\"",
        "'green'",
        "'11'",
        "\"He's crap!\"",
        "'Saunders'",
        "'bugs'",
        "'''\nLogics:\nWe dry lakes in the order of urgency - Greedy.\nIterating through days, when day i is raining on lake lake, if lake is already full, simply return []; else, push the next raining day for lake to to_empty to queue it for drying.\nWhen day i is sunny, dry the most urgent lake referring to to_empty. Remember to remove it from full.\n        '''",
        "'Peter'",
        "' == '",
        "'''fruit:{}\nmeat:{}\nother:{}\nvegetable:{}'''",
        "'d'",
        "'first'",
        "\"Showing %d to %d of %d Products.\"",
        "'10\u2665'",
        "'NO'",
        "'''\n    a a b a a b a a a\n    0 1 2 3 4 5 6 7 8\n    0 1 0 1 2 3 4 5 2\n    \n    '''",
        "'%s %s %s gold'",
        "' JQKA'",
        "'vegetable'",
        "\" metres: He's crap!\"",
        "'7\u2660'",
        "' ohms'",
        "f\"{distance:.2f} metres: Gold!!\"",
        "'y'",
        "'M'",
        "'g'",
        "'t'",
        "f\"\u00a3{sum(2.4 if v == 't' else 1.5 for v in vehicle):.2f}\"",
        "\" and \"",
        "f'The {[\"first\", \"second\"][t2 == t1 and c2 > c1]} card won.'",
        "'role'",
        "'e'",
        "'K\u2663'",
        "\":\"",
        "\"Showing {} to {} of {} Products.\"",
        "'A\u2660'",
        "'osg'",
        "'|'",
        "r'bug(?!s)'",
        "'''#include <bits/stdc++.h> \n#include <math.h> \nusing namespace std; \n\nmain(){\n    long long a=pow(2,1000000000000000000,8589934592);\n    printf(\"%lld\",a);\n}'''",
        "\"/\u2572 \u2571\\\\\"",
        "'On each dry day you may choose to dry one lake.'",
        "f\"{distance:.2f} metres: He's crap!\"",
        "'0F12'",
        "r'(.+?), (\\d+)(?:, )?'",
        "\"ABCDEF\"",
        "'''\n        now start from the beginning and end of the string\n        - note you shouldn't search teh whole string because the longest prefix/suffix is the string itself\n        '''",
        "r'[^a-z]'",
        "'x'",
        "'Admin'",
        "'10\u2663'",
        "'/\u2572'",
        "f\"{l:.2f} metres: {msg[(l>10)+(l>25)+(l>50)]}\"",
        "'gold'",
        "f'\u00a3{s:.2f}'",
        "'6\u2666'",
        "'joker'",
        "'{first_name} {last_name}'",
        "'When will you give Leo an Oscar?'",
        "\"({} {} {})\"",
        "'234567891JQKA'",
        "'2 3 4 5 6 7 8 9 10 J Q K A'",
        "\"\"\"Brute force first loop populates the set of u.  The second loop \n    fills any gaps\"\"\"",
        "'r'",
        "\"test.txt\"",
        "'bw'",
        "'10'",
        "' gold'",
        "'G'",
        "f'{e}***'",
        "'crystal'",
        "'Hepburn'",
        "'collections'",
        "'{}FFFF{:04}0000{}'",
        "\"r\"",
        "','",
        "'F'",
        "'*'",
        "'J\u2665'",
        "f'{ L_LEGS[legs] }{ \"(\"*body }{ eyes }{ mouth }{ eyes }{ \")\"*body }{ R_LEGS[legs] }'",
        "\"He's flying!\"",
        "\"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: bool\n         \"\"\"",
        "f\"{l:.2f} metres: {comment}!\"",
        "\"J\"",
        "\"When will you give Leo an Oscar?\"",
        "'==00'",
        "\"...\"",
        "\"squirrel\"",
        "'2\u2663'",
        "'J\u2663'",
        "'O'",
        "f\"{b}{x}***\"",
        "\"...and it's also not a bug.\"",
        "'-inf'",
        "'city'",
        "'Anna'",
        "'2'",
        "'5\u2660'",
        "\"crystal\"",
        "\": \"",
        "'[^#]{1}#'",
        "'9\u2663'",
        "\"ruby\"",
        "\"Here\"",
        "'H'",
        "f'\u00a3{total_cost:.2f}'",
        "'*1000000'",
        "\"brand\"",
        "'K'",
        "'Oops'",
        "f\"{k}:{','.join(sorted(v))}\"",
        "'c'",
        "\"\"\"\n         :type ratings: List[int]\n         :rtype: int\n         \"\"\"",
        "'\u00a3{:.2f}'",
        "'2\u2665'",
        "'math'",
        "\"\u2571\u2572 \u2571\u2572\"",
        "\">\"",
        "\"|\"",
        "'0123456789'",
        "'['",
        "'{}FFFF{:0>4}0000{}'",
        "\"ATCG\"",
        "'j'",
        "'....'",
        "f\"{d['first_name']} {d['last_name']}\"",
        "\",\"",
        "\"4\"",
        "\"road\"",
        "'7\u2666'",
        "f'{\", \".join(words[:-1])} and {words[-1]}'",
        "\"ooogg\"",
        "\"b1u2g3s\"",
        "'dna '",
        "\"3\"",
        "\"a\"",
        "'sS'",
        "'-1'",
        "'black'",
        "\"/\\\\ /\\\\\"",
        "'''\n        res keeps track of the index of the end of the prefix, used to output the happy prefix\n        l stores the hash key for prefix\n        r tracks the hash key for suffix\n        '''",
        "\"\u2571\u2572%s%s%c%s%s\u2571\u2572\"",
        "f'{k}:{\",\".join(sorted(v))}'",
        "'10\u2666'",
        "f\"{lenght:0.2f} metres: He's flying!\"",
        "'''\r\n\r\n                            Online Python Compiler.\r\n                Code, Compile, Run and Debug python program online.\r\nWrite your code in this editor and press \"Run\" button to execute it.\r\n\r\n'''",
        "'fruit'",
        "\"C\"",
        "\"NO\"",
        "'yellow'",
        "'8\u2663'",
        "\"C3D9\"",
        "\"player\"",
        "\"meat\"",
        "'.?#'",
        "'''\n        [1,2,0,0,2,1]\n        day0 rains on lake1\n        day1 rains on lake2\n        day2 sunny\n        day3 sunny\n        day4 rains on lake1\n        day5 rains on lake2\n        \n        '''",
        "'5\u2665'",
        "'W'",
        "\"\"\"\n         :type moves: str\n         :rtype: bool\n         \"\"\"",
        "'_'",
        "'D'",
        "\"road settlement city development\"",
        "'brand'",
        "\"bw bwsg ooogg osg\"",
        "\"osg\"",
        "\"blue\"",
        "'A\u2666'",
        "'If it rains over a full lake, there will be a flood.'",
        "'4'",
        "\"F\"",
        "'f'",
        "'FFFF'",
        "\"Not even for Wolf of wallstreet?!\"",
        "'Q\u2666'",
        "'N'",
        "'P'",
        "'''\nfor nn in xrange(1,n+1) :\n    for mm in xrange(1,m+1) :\n        if cc <= c :\n            print \"2\",\n            print nn,nn,mm,mm\n            sys.stdout.flush()\n            matrix[nn][mm] = int(raw_input())\n            cc += 1\n        else :\n            break\n    if cc > c :\n        break\n###print matrix'''",
        "'!'",
        "\"The second card won.\"",
        "'Q'",
        "f\"{distance:.2f} metres: He's flying!\"",
        "''' returns a list of prime factors of n.\n    ex. factorize(24) = [2, 2, 2, 3]\n    source: Rossetta code: prime factorization (slightly modified)\n    http://rosettacode.org/wiki/Prime_decomposition#Python:_Using_floating_point\n    '''",
        "\" metres: \"",
        "'4\u2665'",
        "'LRUD'",
        "\"+-\"",
        "'?'",
        "\"yZero\"",
        "'road'",
        "\"other\"",
        "f\"\u00a3{sum(2.4 * len(list(l)) if k is str else (len(list(l)) + 1) // 2 * 1.5 for k,l in groupby(journey, type)):.2f}\"",
        "r'\\b0\\d'",
        "r'([0-9\\.]+)([kM])?(.*)'",
        "'7'",
        "f'{length:.2f} metres: {text}!'",
        "'other'",
        "\"He's ok!\"",
        "\"Index out of range\"",
        "\"A\"",
        "'Ross'",
        "'{seq} and {last}'",
        "'l'",
        "'Leo finally won the oscar! Leo is happy'",
        "'Colin'",
        "\"((\""
    ],
    "float": [
        ".25",
        "2.40",
        "0.05",
        "1.0",
        "1.5",
        "1.35",
        "2.375",
        "0.0",
        "30.0",
        "1.50",
        "2.4",
        ".3",
        "0.25",
        "0.5",
        "1e18",
        "0.3",
        "0.1",
        "1e-9",
        "0.00"
    ]
}