# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST


from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')



# type return_annotation
@dataclass(frozen=True, eq=True)
class return_annotation(ABC):
    @abstractmethod
    def _match(self, handlers : ReturnAnnotationHandlers[T]) -> T: pass


# constructors for type return_annotation

@dataclass(frozen=True, eq=True)
class SomeReturnAnno(return_annotation):
    content : expr

    def _match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_SomeReturnAnno(self)

def make_SomeReturnAnno(content : expr) -> return_annotation:
    return SomeReturnAnno(content)
        

@dataclass(frozen=True, eq=True)
class NoReturnAnno(return_annotation):


    def _match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_NoReturnAnno(self)

def make_NoReturnAnno() -> return_annotation:
    return NoReturnAnno()
        

# case handlers for type return_annotation
@dataclass(frozen=True, eq=True)
class ReturnAnnotationHandlers(Generic[T]):
    case_SomeReturnAnno : Callable[[SomeReturnAnno], T]
    case_NoReturnAnno : Callable[[NoReturnAnno], T]


# matching for type return_annotation
def match_return_annotation(o : return_annotation, handlers : ReturnAnnotationHandlers[T]) -> T :
    return o._match(handlers)
    

# type except_arg
@dataclass(frozen=True, eq=True)
class except_arg(ABC):
    @abstractmethod
    def _match(self, handlers : ExceptArgHandlers[T]) -> T: pass


# constructors for type except_arg

@dataclass(frozen=True, eq=True)
class SomeExceptArg(except_arg):
    content : expr

    def _match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArg(self)

def make_SomeExceptArg(content : expr) -> except_arg:
    return SomeExceptArg(content)
        

@dataclass(frozen=True, eq=True)
class SomeExceptArgName(except_arg):
    content : expr
    name : str

    def _match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArgName(self)

def make_SomeExceptArgName(content : expr, name : str) -> except_arg:
    return SomeExceptArgName(content, name)
        

@dataclass(frozen=True, eq=True)
class NoExceptArg(except_arg):


    def _match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_NoExceptArg(self)

def make_NoExceptArg() -> except_arg:
    return NoExceptArg()
        

# case handlers for type except_arg
@dataclass(frozen=True, eq=True)
class ExceptArgHandlers(Generic[T]):
    case_SomeExceptArg : Callable[[SomeExceptArg], T]
    case_SomeExceptArgName : Callable[[SomeExceptArgName], T]
    case_NoExceptArg : Callable[[NoExceptArg], T]


# matching for type except_arg
def match_except_arg(o : except_arg, handlers : ExceptArgHandlers[T]) -> T :
    return o._match(handlers)
    

# type param_annotation
@dataclass(frozen=True, eq=True)
class param_annotation(ABC):
    @abstractmethod
    def _match(self, handlers : ParamAnnotationHandlers[T]) -> T: pass


# constructors for type param_annotation

@dataclass(frozen=True, eq=True)
class SomeParamAnno(param_annotation):
    content : expr

    def _match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_SomeParamAnno(self)

def make_SomeParamAnno(content : expr) -> param_annotation:
    return SomeParamAnno(content)
        

@dataclass(frozen=True, eq=True)
class NoParamAnno(param_annotation):


    def _match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_NoParamAnno(self)

def make_NoParamAnno() -> param_annotation:
    return NoParamAnno()
        

# case handlers for type param_annotation
@dataclass(frozen=True, eq=True)
class ParamAnnotationHandlers(Generic[T]):
    case_SomeParamAnno : Callable[[SomeParamAnno], T]
    case_NoParamAnno : Callable[[NoParamAnno], T]


# matching for type param_annotation
def match_param_annotation(o : param_annotation, handlers : ParamAnnotationHandlers[T]) -> T :
    return o._match(handlers)
    

# type param_default
@dataclass(frozen=True, eq=True)
class param_default(ABC):
    @abstractmethod
    def _match(self, handlers : ParamDefaultHandlers[T]) -> T: pass


# constructors for type param_default

@dataclass(frozen=True, eq=True)
class SomeParamDefault(param_default):
    content : expr

    def _match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_SomeParamDefault(self)

def make_SomeParamDefault(content : expr) -> param_default:
    return SomeParamDefault(content)
        

@dataclass(frozen=True, eq=True)
class NoParamDefault(param_default):


    def _match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_NoParamDefault(self)

def make_NoParamDefault() -> param_default:
    return NoParamDefault()
        

# case handlers for type param_default
@dataclass(frozen=True, eq=True)
class ParamDefaultHandlers(Generic[T]):
    case_SomeParamDefault : Callable[[SomeParamDefault], T]
    case_NoParamDefault : Callable[[NoParamDefault], T]


# matching for type param_default
def match_param_default(o : param_default, handlers : ParamDefaultHandlers[T]) -> T :
    return o._match(handlers)
    

# type parameters_d
@dataclass(frozen=True, eq=True)
class parameters_d(ABC):
    @abstractmethod
    def _match(self, handlers : ParametersDHandlers[T]) -> T: pass


# constructors for type parameters_d

@dataclass(frozen=True, eq=True)
class ConsKwParam(parameters_d):
    head : Param
    tail : parameters_d

    def _match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_ConsKwParam(self)

def make_ConsKwParam(head : Param, tail : parameters_d) -> parameters_d:
    return ConsKwParam(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleKwParam(parameters_d):
    content : Param

    def _match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_SingleKwParam(self)

def make_SingleKwParam(content : Param) -> parameters_d:
    return SingleKwParam(content)
        

@dataclass(frozen=True, eq=True)
class DictionarySplatParam(parameters_d):
    content : Param

    def _match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_DictionarySplatParam(self)

def make_DictionarySplatParam(content : Param) -> parameters_d:
    return DictionarySplatParam(content)
        

# case handlers for type parameters_d
@dataclass(frozen=True, eq=True)
class ParametersDHandlers(Generic[T]):
    case_ConsKwParam : Callable[[ConsKwParam], T]
    case_SingleKwParam : Callable[[SingleKwParam], T]
    case_DictionarySplatParam : Callable[[DictionarySplatParam], T]


# matching for type parameters_d
def match_parameters_d(o : parameters_d, handlers : ParametersDHandlers[T]) -> T :
    return o._match(handlers)
    

# type parameters_c
@dataclass(frozen=True, eq=True)
class parameters_c(ABC):
    @abstractmethod
    def _match(self, handlers : ParametersCHandlers[T]) -> T: pass


# constructors for type parameters_c

@dataclass(frozen=True, eq=True)
class SingleListSplatParam(parameters_c):
    content : Param

    def _match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_SingleListSplatParam(self)

def make_SingleListSplatParam(content : Param) -> parameters_c:
    return SingleListSplatParam(content)
        

@dataclass(frozen=True, eq=True)
class TransListSplatParam(parameters_c):
    head : Param
    tail : parameters_d

    def _match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_TransListSplatParam(self)

def make_TransListSplatParam(head : Param, tail : parameters_d) -> parameters_c:
    return TransListSplatParam(head, tail)
        

@dataclass(frozen=True, eq=True)
class ParamsD(parameters_c):
    content : parameters_d

    def _match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_ParamsD(self)

def make_ParamsD(content : parameters_d) -> parameters_c:
    return ParamsD(content)
        

# case handlers for type parameters_c
@dataclass(frozen=True, eq=True)
class ParametersCHandlers(Generic[T]):
    case_SingleListSplatParam : Callable[[SingleListSplatParam], T]
    case_TransListSplatParam : Callable[[TransListSplatParam], T]
    case_ParamsD : Callable[[ParamsD], T]


# matching for type parameters_c
def match_parameters_c(o : parameters_c, handlers : ParametersCHandlers[T]) -> T :
    return o._match(handlers)
    

# type parameters_b
@dataclass(frozen=True, eq=True)
class parameters_b(ABC):
    @abstractmethod
    def _match(self, handlers : ParametersBHandlers[T]) -> T: pass


# constructors for type parameters_b

@dataclass(frozen=True, eq=True)
class ConsParam(parameters_b):
    head : Param
    tail : parameters_b

    def _match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ConsParam(self)

def make_ConsParam(head : Param, tail : parameters_b) -> parameters_b:
    return ConsParam(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleParam(parameters_b):
    content : Param

    def _match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_SingleParam(self)

def make_SingleParam(content : Param) -> parameters_b:
    return SingleParam(content)
        

@dataclass(frozen=True, eq=True)
class ParamsC(parameters_b):
    content : parameters_c

    def _match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ParamsC(self)

def make_ParamsC(content : parameters_c) -> parameters_b:
    return ParamsC(content)
        

# case handlers for type parameters_b
@dataclass(frozen=True, eq=True)
class ParametersBHandlers(Generic[T]):
    case_ConsParam : Callable[[ConsParam], T]
    case_SingleParam : Callable[[SingleParam], T]
    case_ParamsC : Callable[[ParamsC], T]


# matching for type parameters_b
def match_parameters_b(o : parameters_b, handlers : ParametersBHandlers[T]) -> T :
    return o._match(handlers)
    

# type parameters_a
@dataclass(frozen=True, eq=True)
class parameters_a(ABC):
    @abstractmethod
    def _match(self, handlers : ParametersAHandlers[T]) -> T: pass


# constructors for type parameters_a

@dataclass(frozen=True, eq=True)
class ConsPosParam(parameters_a):
    head : Param
    tail : parameters_a

    def _match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_ConsPosParam(self)

def make_ConsPosParam(head : Param, tail : parameters_a) -> parameters_a:
    return ConsPosParam(head, tail)
        

@dataclass(frozen=True, eq=True)
class SinglePosParam(parameters_a):
    content : Param

    def _match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_SinglePosParam(self)

def make_SinglePosParam(content : Param) -> parameters_a:
    return SinglePosParam(content)
        

@dataclass(frozen=True, eq=True)
class TransPosParam(parameters_a):
    head : Param
    tail : parameters_b

    def _match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_TransPosParam(self)

def make_TransPosParam(head : Param, tail : parameters_b) -> parameters_a:
    return TransPosParam(head, tail)
        

# case handlers for type parameters_a
@dataclass(frozen=True, eq=True)
class ParametersAHandlers(Generic[T]):
    case_ConsPosParam : Callable[[ConsPosParam], T]
    case_SinglePosParam : Callable[[SinglePosParam], T]
    case_TransPosParam : Callable[[TransPosParam], T]


# matching for type parameters_a
def match_parameters_a(o : parameters_a, handlers : ParametersAHandlers[T]) -> T :
    return o._match(handlers)
    

# type parameters
@dataclass(frozen=True, eq=True)
class parameters(ABC):
    @abstractmethod
    def _match(self, handlers : ParametersHandlers[T]) -> T: pass


# constructors for type parameters

@dataclass(frozen=True, eq=True)
class ParamsA(parameters):
    content : parameters_a

    def _match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsA(self)

def make_ParamsA(content : parameters_a) -> parameters:
    return ParamsA(content)
        

@dataclass(frozen=True, eq=True)
class ParamsB(parameters):
    content : parameters_b

    def _match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsB(self)

def make_ParamsB(content : parameters_b) -> parameters:
    return ParamsB(content)
        

@dataclass(frozen=True, eq=True)
class NoParam(parameters):


    def _match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_NoParam(self)

def make_NoParam() -> parameters:
    return NoParam()
        

# case handlers for type parameters
@dataclass(frozen=True, eq=True)
class ParametersHandlers(Generic[T]):
    case_ParamsA : Callable[[ParamsA], T]
    case_ParamsB : Callable[[ParamsB], T]
    case_NoParam : Callable[[NoParam], T]


# matching for type parameters
def match_parameters(o : parameters, handlers : ParametersHandlers[T]) -> T :
    return o._match(handlers)
    

# type keyword
@dataclass(frozen=True, eq=True)
class keyword(ABC):
    @abstractmethod
    def _match(self, handlers : KeywordHandlers[T]) -> T: pass


# constructors for type keyword

@dataclass(frozen=True, eq=True)
class NamedKeyword(keyword):
    name : str
    content : expr

    def _match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_NamedKeyword(self)

def make_NamedKeyword(name : str, content : expr) -> keyword:
    return NamedKeyword(name, content)
        

@dataclass(frozen=True, eq=True)
class SplatKeyword(keyword):
    content : expr

    def _match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_SplatKeyword(self)

def make_SplatKeyword(content : expr) -> keyword:
    return SplatKeyword(content)
        

# case handlers for type keyword
@dataclass(frozen=True, eq=True)
class KeywordHandlers(Generic[T]):
    case_NamedKeyword : Callable[[NamedKeyword], T]
    case_SplatKeyword : Callable[[SplatKeyword], T]


# matching for type keyword
def match_keyword(o : keyword, handlers : KeywordHandlers[T]) -> T :
    return o._match(handlers)
    

# type import_name
@dataclass(frozen=True, eq=True)
class import_name(ABC):
    @abstractmethod
    def _match(self, handlers : ImportNameHandlers[T]) -> T: pass


# constructors for type import_name

@dataclass(frozen=True, eq=True)
class ImportNameAlias(import_name):
    name : str
    alias : str

    def _match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameAlias(self)

def make_ImportNameAlias(name : str, alias : str) -> import_name:
    return ImportNameAlias(name, alias)
        

@dataclass(frozen=True, eq=True)
class ImportNameOnly(import_name):
    name : str

    def _match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameOnly(self)

def make_ImportNameOnly(name : str) -> import_name:
    return ImportNameOnly(name)
        

# case handlers for type import_name
@dataclass(frozen=True, eq=True)
class ImportNameHandlers(Generic[T]):
    case_ImportNameAlias : Callable[[ImportNameAlias], T]
    case_ImportNameOnly : Callable[[ImportNameOnly], T]


# matching for type import_name
def match_import_name(o : import_name, handlers : ImportNameHandlers[T]) -> T :
    return o._match(handlers)
    

# type with_item
@dataclass(frozen=True, eq=True)
class with_item(ABC):
    @abstractmethod
    def _match(self, handlers : WithItemHandlers[T]) -> T: pass


# constructors for type with_item

@dataclass(frozen=True, eq=True)
class WithItemAlias(with_item):
    content : expr
    alias : expr

    def _match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemAlias(self)

def make_WithItemAlias(content : expr, alias : expr) -> with_item:
    return WithItemAlias(content, alias)
        

@dataclass(frozen=True, eq=True)
class WithItemOnly(with_item):
    content : expr

    def _match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemOnly(self)

def make_WithItemOnly(content : expr) -> with_item:
    return WithItemOnly(content)
        

# case handlers for type with_item
@dataclass(frozen=True, eq=True)
class WithItemHandlers(Generic[T]):
    case_WithItemAlias : Callable[[WithItemAlias], T]
    case_WithItemOnly : Callable[[WithItemOnly], T]


# matching for type with_item
def match_with_item(o : with_item, handlers : WithItemHandlers[T]) -> T :
    return o._match(handlers)
    

# type bases
@dataclass(frozen=True, eq=True)
class bases(ABC):
    @abstractmethod
    def _match(self, handlers : BasesHandlers[T]) -> T: pass


# constructors for type bases

@dataclass(frozen=True, eq=True)
class SomeBases(bases):
    bases : bases_a

    def _match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_SomeBases(self)

def make_SomeBases(bases : bases_a) -> bases:
    return SomeBases(bases)
        

@dataclass(frozen=True, eq=True)
class NoBases(bases):


    def _match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_NoBases(self)

def make_NoBases() -> bases:
    return NoBases()
        

# case handlers for type bases
@dataclass(frozen=True, eq=True)
class BasesHandlers(Generic[T]):
    case_SomeBases : Callable[[SomeBases], T]
    case_NoBases : Callable[[NoBases], T]


# matching for type bases
def match_bases(o : bases, handlers : BasesHandlers[T]) -> T :
    return o._match(handlers)
    

# type bases_a
@dataclass(frozen=True, eq=True)
class bases_a(ABC):
    @abstractmethod
    def _match(self, handlers : BasesAHandlers[T]) -> T: pass


# constructors for type bases_a

@dataclass(frozen=True, eq=True)
class ConsBase(bases_a):
    head : expr
    tail : bases_a

    def _match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_ConsBase(self)

def make_ConsBase(head : expr, tail : bases_a) -> bases_a:
    return ConsBase(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleBase(bases_a):
    content : expr

    def _match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_SingleBase(self)

def make_SingleBase(content : expr) -> bases_a:
    return SingleBase(content)
        

@dataclass(frozen=True, eq=True)
class KeywordsBase(bases_a):
    kws : keywords

    def _match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_KeywordsBase(self)

def make_KeywordsBase(kws : keywords) -> bases_a:
    return KeywordsBase(kws)
        

# case handlers for type bases_a
@dataclass(frozen=True, eq=True)
class BasesAHandlers(Generic[T]):
    case_ConsBase : Callable[[ConsBase], T]
    case_SingleBase : Callable[[SingleBase], T]
    case_KeywordsBase : Callable[[KeywordsBase], T]


# matching for type bases_a
def match_bases_a(o : bases_a, handlers : BasesAHandlers[T]) -> T :
    return o._match(handlers)
    

# type keywords
@dataclass(frozen=True, eq=True)
class keywords(ABC):
    @abstractmethod
    def _match(self, handlers : KeywordsHandlers[T]) -> T: pass


# constructors for type keywords

@dataclass(frozen=True, eq=True)
class ConsKeyword(keywords):
    head : keyword
    tail : keywords

    def _match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_ConsKeyword(self)

def make_ConsKeyword(head : keyword, tail : keywords) -> keywords:
    return ConsKeyword(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleKeyword(keywords):
    content : keyword

    def _match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_SingleKeyword(self)

def make_SingleKeyword(content : keyword) -> keywords:
    return SingleKeyword(content)
        

# case handlers for type keywords
@dataclass(frozen=True, eq=True)
class KeywordsHandlers(Generic[T]):
    case_ConsKeyword : Callable[[ConsKeyword], T]
    case_SingleKeyword : Callable[[SingleKeyword], T]


# matching for type keywords
def match_keywords(o : keywords, handlers : KeywordsHandlers[T]) -> T :
    return o._match(handlers)
    

# type comparisons
@dataclass(frozen=True, eq=True)
class comparisons(ABC):
    @abstractmethod
    def _match(self, handlers : ComparisonsHandlers[T]) -> T: pass


# constructors for type comparisons

@dataclass(frozen=True, eq=True)
class ConsCompareRight(comparisons):
    head : CompareRight
    tail : comparisons

    def _match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_ConsCompareRight(self)

def make_ConsCompareRight(head : CompareRight, tail : comparisons) -> comparisons:
    return ConsCompareRight(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleCompareRight(comparisons):
    content : CompareRight

    def _match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_SingleCompareRight(self)

def make_SingleCompareRight(content : CompareRight) -> comparisons:
    return SingleCompareRight(content)
        

# case handlers for type comparisons
@dataclass(frozen=True, eq=True)
class ComparisonsHandlers(Generic[T]):
    case_ConsCompareRight : Callable[[ConsCompareRight], T]
    case_SingleCompareRight : Callable[[SingleCompareRight], T]


# matching for type comparisons
def match_comparisons(o : comparisons, handlers : ComparisonsHandlers[T]) -> T :
    return o._match(handlers)
    

# type option_expr
@dataclass(frozen=True, eq=True)
class option_expr(ABC):
    @abstractmethod
    def _match(self, handlers : OptionExprHandlers[T]) -> T: pass


# constructors for type option_expr

@dataclass(frozen=True, eq=True)
class SomeExpr(option_expr):
    content : expr

    def _match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_SomeExpr(self)

def make_SomeExpr(content : expr) -> option_expr:
    return SomeExpr(content)
        

@dataclass(frozen=True, eq=True)
class NoExpr(option_expr):


    def _match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_NoExpr(self)

def make_NoExpr() -> option_expr:
    return NoExpr()
        

# case handlers for type option_expr
@dataclass(frozen=True, eq=True)
class OptionExprHandlers(Generic[T]):
    case_SomeExpr : Callable[[SomeExpr], T]
    case_NoExpr : Callable[[NoExpr], T]


# matching for type option_expr
def match_option_expr(o : option_expr, handlers : OptionExprHandlers[T]) -> T :
    return o._match(handlers)
    

# type comma_exprs
@dataclass(frozen=True, eq=True)
class comma_exprs(ABC):
    @abstractmethod
    def _match(self, handlers : CommaExprsHandlers[T]) -> T: pass


# constructors for type comma_exprs

@dataclass(frozen=True, eq=True)
class ConsExpr(comma_exprs):
    head : expr
    tail : comma_exprs

    def _match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_ConsExpr(self)

def make_ConsExpr(head : expr, tail : comma_exprs) -> comma_exprs:
    return ConsExpr(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleExpr(comma_exprs):
    content : expr

    def _match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_SingleExpr(self)

def make_SingleExpr(content : expr) -> comma_exprs:
    return SingleExpr(content)
        

# case handlers for type comma_exprs
@dataclass(frozen=True, eq=True)
class CommaExprsHandlers(Generic[T]):
    case_ConsExpr : Callable[[ConsExpr], T]
    case_SingleExpr : Callable[[SingleExpr], T]


# matching for type comma_exprs
def match_comma_exprs(o : comma_exprs, handlers : CommaExprsHandlers[T]) -> T :
    return o._match(handlers)
    

# type target_exprs
@dataclass(frozen=True, eq=True)
class target_exprs(ABC):
    @abstractmethod
    def _match(self, handlers : TargetExprsHandlers[T]) -> T: pass


# constructors for type target_exprs

@dataclass(frozen=True, eq=True)
class ConsTargetExpr(target_exprs):
    head : expr
    tail : target_exprs

    def _match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_ConsTargetExpr(self)

def make_ConsTargetExpr(head : expr, tail : target_exprs) -> target_exprs:
    return ConsTargetExpr(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleTargetExpr(target_exprs):
    content : expr

    def _match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_SingleTargetExpr(self)

def make_SingleTargetExpr(content : expr) -> target_exprs:
    return SingleTargetExpr(content)
        

# case handlers for type target_exprs
@dataclass(frozen=True, eq=True)
class TargetExprsHandlers(Generic[T]):
    case_ConsTargetExpr : Callable[[ConsTargetExpr], T]
    case_SingleTargetExpr : Callable[[SingleTargetExpr], T]


# matching for type target_exprs
def match_target_exprs(o : target_exprs, handlers : TargetExprsHandlers[T]) -> T :
    return o._match(handlers)
    

# type decorators
@dataclass(frozen=True, eq=True)
class decorators(ABC):
    @abstractmethod
    def _match(self, handlers : DecoratorsHandlers[T]) -> T: pass


# constructors for type decorators

@dataclass(frozen=True, eq=True)
class ConsDec(decorators):
    head : expr
    tail : decorators

    def _match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_ConsDec(self)

def make_ConsDec(head : expr, tail : decorators) -> decorators:
    return ConsDec(head, tail)
        

@dataclass(frozen=True, eq=True)
class NoDec(decorators):


    def _match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_NoDec(self)

def make_NoDec() -> decorators:
    return NoDec()
        

# case handlers for type decorators
@dataclass(frozen=True, eq=True)
class DecoratorsHandlers(Generic[T]):
    case_ConsDec : Callable[[ConsDec], T]
    case_NoDec : Callable[[NoDec], T]


# matching for type decorators
def match_decorators(o : decorators, handlers : DecoratorsHandlers[T]) -> T :
    return o._match(handlers)
    

# type constraint_filters
@dataclass(frozen=True, eq=True)
class constraint_filters(ABC):
    @abstractmethod
    def _match(self, handlers : ConstraintFiltersHandlers[T]) -> T: pass


# constructors for type constraint_filters

@dataclass(frozen=True, eq=True)
class ConsFilter(constraint_filters):
    head : expr
    tail : constraint_filters

    def _match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_ConsFilter(self)

def make_ConsFilter(head : expr, tail : constraint_filters) -> constraint_filters:
    return ConsFilter(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleFilter(constraint_filters):
    content : expr

    def _match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_SingleFilter(self)

def make_SingleFilter(content : expr) -> constraint_filters:
    return SingleFilter(content)
        

@dataclass(frozen=True, eq=True)
class NoFilter(constraint_filters):


    def _match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_NoFilter(self)

def make_NoFilter() -> constraint_filters:
    return NoFilter()
        

# case handlers for type constraint_filters
@dataclass(frozen=True, eq=True)
class ConstraintFiltersHandlers(Generic[T]):
    case_ConsFilter : Callable[[ConsFilter], T]
    case_SingleFilter : Callable[[SingleFilter], T]
    case_NoFilter : Callable[[NoFilter], T]


# matching for type constraint_filters
def match_constraint_filters(o : constraint_filters, handlers : ConstraintFiltersHandlers[T]) -> T :
    return o._match(handlers)
    

# type sequence_string
@dataclass(frozen=True, eq=True)
class sequence_string(ABC):
    @abstractmethod
    def _match(self, handlers : SequenceStringHandlers[T]) -> T: pass


# constructors for type sequence_string

@dataclass(frozen=True, eq=True)
class ConsStr(sequence_string):
    head : str
    tail : sequence_string

    def _match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_ConsStr(self)

def make_ConsStr(head : str, tail : sequence_string) -> sequence_string:
    return ConsStr(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleStr(sequence_string):
    content : str

    def _match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_SingleStr(self)

def make_SingleStr(content : str) -> sequence_string:
    return SingleStr(content)
        

# case handlers for type sequence_string
@dataclass(frozen=True, eq=True)
class SequenceStringHandlers(Generic[T]):
    case_ConsStr : Callable[[ConsStr], T]
    case_SingleStr : Callable[[SingleStr], T]


# matching for type sequence_string
def match_sequence_string(o : sequence_string, handlers : SequenceStringHandlers[T]) -> T :
    return o._match(handlers)
    

# type arguments
@dataclass(frozen=True, eq=True)
class arguments(ABC):
    @abstractmethod
    def _match(self, handlers : ArgumentsHandlers[T]) -> T: pass


# constructors for type arguments

@dataclass(frozen=True, eq=True)
class ConsArg(arguments):
    head : expr
    tail : arguments

    def _match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_ConsArg(self)

def make_ConsArg(head : expr, tail : arguments) -> arguments:
    return ConsArg(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleArg(arguments):
    content : expr

    def _match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_SingleArg(self)

def make_SingleArg(content : expr) -> arguments:
    return SingleArg(content)
        

@dataclass(frozen=True, eq=True)
class KeywordsArg(arguments):
    kws : keywords

    def _match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_KeywordsArg(self)

def make_KeywordsArg(kws : keywords) -> arguments:
    return KeywordsArg(kws)
        

# case handlers for type arguments
@dataclass(frozen=True, eq=True)
class ArgumentsHandlers(Generic[T]):
    case_ConsArg : Callable[[ConsArg], T]
    case_SingleArg : Callable[[SingleArg], T]
    case_KeywordsArg : Callable[[KeywordsArg], T]


# matching for type arguments
def match_arguments(o : arguments, handlers : ArgumentsHandlers[T]) -> T :
    return o._match(handlers)
    

# type dictionary_item
@dataclass(frozen=True, eq=True)
class dictionary_item(ABC):
    @abstractmethod
    def _match(self, handlers : DictionaryItemHandlers[T]) -> T: pass


# constructors for type dictionary_item

@dataclass(frozen=True, eq=True)
class Field(dictionary_item):
    key : expr
    content : expr

    def _match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_Field(self)

def make_Field(key : expr, content : expr) -> dictionary_item:
    return Field(key, content)
        

@dataclass(frozen=True, eq=True)
class DictionarySplatFields(dictionary_item):
    content : expr

    def _match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_DictionarySplatFields(self)

def make_DictionarySplatFields(content : expr) -> dictionary_item:
    return DictionarySplatFields(content)
        

# case handlers for type dictionary_item
@dataclass(frozen=True, eq=True)
class DictionaryItemHandlers(Generic[T]):
    case_Field : Callable[[Field], T]
    case_DictionarySplatFields : Callable[[DictionarySplatFields], T]


# matching for type dictionary_item
def match_dictionary_item(o : dictionary_item, handlers : DictionaryItemHandlers[T]) -> T :
    return o._match(handlers)
    

# type dictionary_content
@dataclass(frozen=True, eq=True)
class dictionary_content(ABC):
    @abstractmethod
    def _match(self, handlers : DictionaryContentHandlers[T]) -> T: pass


# constructors for type dictionary_content

@dataclass(frozen=True, eq=True)
class ConsDictionaryItem(dictionary_content):
    head : dictionary_item
    tail : dictionary_content

    def _match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_ConsDictionaryItem(self)

def make_ConsDictionaryItem(head : dictionary_item, tail : dictionary_content) -> dictionary_content:
    return ConsDictionaryItem(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleDictionaryItem(dictionary_content):
    content : dictionary_item

    def _match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_SingleDictionaryItem(self)

def make_SingleDictionaryItem(content : dictionary_item) -> dictionary_content:
    return SingleDictionaryItem(content)
        

# case handlers for type dictionary_content
@dataclass(frozen=True, eq=True)
class DictionaryContentHandlers(Generic[T]):
    case_ConsDictionaryItem : Callable[[ConsDictionaryItem], T]
    case_SingleDictionaryItem : Callable[[SingleDictionaryItem], T]


# matching for type dictionary_content
def match_dictionary_content(o : dictionary_content, handlers : DictionaryContentHandlers[T]) -> T :
    return o._match(handlers)
    

# type sequence_name
@dataclass(frozen=True, eq=True)
class sequence_name(ABC):
    @abstractmethod
    def _match(self, handlers : SequenceNameHandlers[T]) -> T: pass


# constructors for type sequence_name

@dataclass(frozen=True, eq=True)
class ConsId(sequence_name):
    head : str
    tail : sequence_name

    def _match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_ConsId(self)

def make_ConsId(head : str, tail : sequence_name) -> sequence_name:
    return ConsId(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleId(sequence_name):
    content : str

    def _match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_SingleId(self)

def make_SingleId(content : str) -> sequence_name:
    return SingleId(content)
        

# case handlers for type sequence_name
@dataclass(frozen=True, eq=True)
class SequenceNameHandlers(Generic[T]):
    case_ConsId : Callable[[ConsId], T]
    case_SingleId : Callable[[SingleId], T]


# matching for type sequence_name
def match_sequence_name(o : sequence_name, handlers : SequenceNameHandlers[T]) -> T :
    return o._match(handlers)
    

# type sequence_import_name
@dataclass(frozen=True, eq=True)
class sequence_import_name(ABC):
    @abstractmethod
    def _match(self, handlers : SequenceImportNameHandlers[T]) -> T: pass


# constructors for type sequence_import_name

@dataclass(frozen=True, eq=True)
class ConsImportName(sequence_import_name):
    head : import_name
    tail : sequence_import_name

    def _match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_ConsImportName(self)

def make_ConsImportName(head : import_name, tail : sequence_import_name) -> sequence_import_name:
    return ConsImportName(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleImportName(sequence_import_name):
    content : import_name

    def _match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_SingleImportName(self)

def make_SingleImportName(content : import_name) -> sequence_import_name:
    return SingleImportName(content)
        

# case handlers for type sequence_import_name
@dataclass(frozen=True, eq=True)
class SequenceImportNameHandlers(Generic[T]):
    case_ConsImportName : Callable[[ConsImportName], T]
    case_SingleImportName : Callable[[SingleImportName], T]


# matching for type sequence_import_name
def match_sequence_import_name(o : sequence_import_name, handlers : SequenceImportNameHandlers[T]) -> T :
    return o._match(handlers)
    

# type sequence_with_item
@dataclass(frozen=True, eq=True)
class sequence_with_item(ABC):
    @abstractmethod
    def _match(self, handlers : SequenceWithItemHandlers[T]) -> T: pass


# constructors for type sequence_with_item

@dataclass(frozen=True, eq=True)
class ConsWithItem(sequence_with_item):
    head : with_item
    tail : sequence_with_item

    def _match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_ConsWithItem(self)

def make_ConsWithItem(head : with_item, tail : sequence_with_item) -> sequence_with_item:
    return ConsWithItem(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleWithItem(sequence_with_item):
    content : with_item

    def _match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_SingleWithItem(self)

def make_SingleWithItem(content : with_item) -> sequence_with_item:
    return SingleWithItem(content)
        

# case handlers for type sequence_with_item
@dataclass(frozen=True, eq=True)
class SequenceWithItemHandlers(Generic[T]):
    case_ConsWithItem : Callable[[ConsWithItem], T]
    case_SingleWithItem : Callable[[SingleWithItem], T]


# matching for type sequence_with_item
def match_sequence_with_item(o : sequence_with_item, handlers : SequenceWithItemHandlers[T]) -> T :
    return o._match(handlers)
    

# type module
@dataclass(frozen=True, eq=True)
class module(ABC):
    @abstractmethod
    def _match(self, handlers : ModuleHandlers[T]) -> T: pass


# constructors for type module

@dataclass(frozen=True, eq=True)
class FutureMod(module):
    names : sequence_import_name
    body : statements

    def _match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_FutureMod(self)

def make_FutureMod(names : sequence_import_name, body : statements) -> module:
    return FutureMod(names, body)
        

@dataclass(frozen=True, eq=True)
class SimpleMod(module):
    body : statements

    def _match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_SimpleMod(self)

def make_SimpleMod(body : statements) -> module:
    return SimpleMod(body)
        

# case handlers for type module
@dataclass(frozen=True, eq=True)
class ModuleHandlers(Generic[T]):
    case_FutureMod : Callable[[FutureMod], T]
    case_SimpleMod : Callable[[SimpleMod], T]


# matching for type module
def match_module(o : module, handlers : ModuleHandlers[T]) -> T :
    return o._match(handlers)
    

# type statements
@dataclass(frozen=True, eq=True)
class statements(ABC):
    @abstractmethod
    def _match(self, handlers : StatementsHandlers[T]) -> T: pass


# constructors for type statements

@dataclass(frozen=True, eq=True)
class ConsStmt(statements):
    head : stmt
    tail : statements

    def _match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_ConsStmt(self)

def make_ConsStmt(head : stmt, tail : statements) -> statements:
    return ConsStmt(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleStmt(statements):
    content : stmt

    def _match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_SingleStmt(self)

def make_SingleStmt(content : stmt) -> statements:
    return SingleStmt(content)
        

# case handlers for type statements
@dataclass(frozen=True, eq=True)
class StatementsHandlers(Generic[T]):
    case_ConsStmt : Callable[[ConsStmt], T]
    case_SingleStmt : Callable[[SingleStmt], T]


# matching for type statements
def match_statements(o : statements, handlers : StatementsHandlers[T]) -> T :
    return o._match(handlers)
    

# type comprehension_constraints
@dataclass(frozen=True, eq=True)
class comprehension_constraints(ABC):
    @abstractmethod
    def _match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T: pass


# constructors for type comprehension_constraints

@dataclass(frozen=True, eq=True)
class ConsConstraint(comprehension_constraints):
    head : constraint
    tail : comprehension_constraints

    def _match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_ConsConstraint(self)

def make_ConsConstraint(head : constraint, tail : comprehension_constraints) -> comprehension_constraints:
    return ConsConstraint(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleConstraint(comprehension_constraints):
    content : constraint

    def _match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_SingleConstraint(self)

def make_SingleConstraint(content : constraint) -> comprehension_constraints:
    return SingleConstraint(content)
        

# case handlers for type comprehension_constraints
@dataclass(frozen=True, eq=True)
class ComprehensionConstraintsHandlers(Generic[T]):
    case_ConsConstraint : Callable[[ConsConstraint], T]
    case_SingleConstraint : Callable[[SingleConstraint], T]


# matching for type comprehension_constraints
def match_comprehension_constraints(o : comprehension_constraints, handlers : ComprehensionConstraintsHandlers[T]) -> T :
    return o._match(handlers)
    

# type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class sequence_ExceptHandler(ABC):
    @abstractmethod
    def _match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T: pass


# constructors for type sequence_ExceptHandler

@dataclass(frozen=True, eq=True)
class ConsExceptHandler(sequence_ExceptHandler):
    head : ExceptHandler
    tail : sequence_ExceptHandler

    def _match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_ConsExceptHandler(self)

def make_ConsExceptHandler(head : ExceptHandler, tail : sequence_ExceptHandler) -> sequence_ExceptHandler:
    return ConsExceptHandler(head, tail)
        

@dataclass(frozen=True, eq=True)
class SingleExceptHandler(sequence_ExceptHandler):
    content : ExceptHandler

    def _match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_SingleExceptHandler(self)

def make_SingleExceptHandler(content : ExceptHandler) -> sequence_ExceptHandler:
    return SingleExceptHandler(content)
        

# case handlers for type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class SequenceExceptHandlerHandlers(Generic[T]):
    case_ConsExceptHandler : Callable[[ConsExceptHandler], T]
    case_SingleExceptHandler : Callable[[SingleExceptHandler], T]


# matching for type sequence_ExceptHandler
def match_sequence_ExceptHandler(o : sequence_ExceptHandler, handlers : SequenceExceptHandlerHandlers[T]) -> T :
    return o._match(handlers)
    

# type conditions
@dataclass(frozen=True, eq=True)
class conditions(ABC):
    @abstractmethod
    def _match(self, handlers : ConditionsHandlers[T]) -> T: pass


# constructors for type conditions

@dataclass(frozen=True, eq=True)
class ElifCond(conditions):
    content : ElifBlock
    tail : conditions

    def _match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElifCond(self)

def make_ElifCond(content : ElifBlock, tail : conditions) -> conditions:
    return ElifCond(content, tail)
        

@dataclass(frozen=True, eq=True)
class ElseCond(conditions):
    content : ElseBlock

    def _match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElseCond(self)

def make_ElseCond(content : ElseBlock) -> conditions:
    return ElseCond(content)
        

@dataclass(frozen=True, eq=True)
class NoCond(conditions):


    def _match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_NoCond(self)

def make_NoCond() -> conditions:
    return NoCond()
        

# case handlers for type conditions
@dataclass(frozen=True, eq=True)
class ConditionsHandlers(Generic[T]):
    case_ElifCond : Callable[[ElifCond], T]
    case_ElseCond : Callable[[ElseCond], T]
    case_NoCond : Callable[[NoCond], T]


# matching for type conditions
def match_conditions(o : conditions, handlers : ConditionsHandlers[T]) -> T :
    return o._match(handlers)
    

# type function_def
@dataclass(frozen=True, eq=True)
class function_def(ABC):
    @abstractmethod
    def _match(self, handlers : FunctionDefHandlers[T]) -> T: pass


# constructors for type function_def

@dataclass(frozen=True, eq=True)
class FunctionDef(function_def):
    name : str
    params : parameters
    ret_anno : return_annotation
    body : statements

    def _match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_FunctionDef(self)

def make_FunctionDef(name : str, params : parameters, ret_anno : return_annotation, body : statements) -> function_def:
    return FunctionDef(name, params, ret_anno, body)
        

@dataclass(frozen=True, eq=True)
class AsyncFunctionDef(function_def):
    name : str
    params : parameters
    ret_anno : return_annotation
    body : statements

    def _match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_AsyncFunctionDef(self)

def make_AsyncFunctionDef(name : str, params : parameters, ret_anno : return_annotation, body : statements) -> function_def:
    return AsyncFunctionDef(name, params, ret_anno, body)
        

# case handlers for type function_def
@dataclass(frozen=True, eq=True)
class FunctionDefHandlers(Generic[T]):
    case_FunctionDef : Callable[[FunctionDef], T]
    case_AsyncFunctionDef : Callable[[AsyncFunctionDef], T]


# matching for type function_def
def match_function_def(o : function_def, handlers : FunctionDefHandlers[T]) -> T :
    return o._match(handlers)
    

# type stmt
@dataclass(frozen=True, eq=True)
class stmt(ABC):
    @abstractmethod
    def _match(self, handlers : StmtHandlers[T]) -> T: pass


# constructors for type stmt

@dataclass(frozen=True, eq=True)
class DecFunctionDef(stmt):
    decs : decorators
    fun_def : function_def

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecFunctionDef(self)

def make_DecFunctionDef(decs : decorators, fun_def : function_def) -> stmt:
    return DecFunctionDef(decs, fun_def)
        

@dataclass(frozen=True, eq=True)
class DecClassDef(stmt):
    decs : decorators
    class_def : ClassDef

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecClassDef(self)

def make_DecClassDef(decs : decorators, class_def : ClassDef) -> stmt:
    return DecClassDef(decs, class_def)
        

@dataclass(frozen=True, eq=True)
class ReturnSomething(stmt):
    content : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ReturnSomething(self)

def make_ReturnSomething(content : expr) -> stmt:
    return ReturnSomething(content)
        

@dataclass(frozen=True, eq=True)
class Return(stmt):


    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Return(self)

def make_Return() -> stmt:
    return Return()
        

@dataclass(frozen=True, eq=True)
class Delete(stmt):
    targets : comma_exprs

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Delete(self)

def make_Delete(targets : comma_exprs) -> stmt:
    return Delete(targets)
        

@dataclass(frozen=True, eq=True)
class Assign(stmt):
    targets : target_exprs
    content : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assign(self)

def make_Assign(targets : target_exprs, content : expr) -> stmt:
    return Assign(targets, content)
        

@dataclass(frozen=True, eq=True)
class AugAssign(stmt):
    target : expr
    op : operator
    content : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AugAssign(self)

def make_AugAssign(target : expr, op : operator, content : expr) -> stmt:
    return AugAssign(target, op, content)
        

@dataclass(frozen=True, eq=True)
class AnnoAssign(stmt):
    target : expr
    anno : expr
    content : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoAssign(self)

def make_AnnoAssign(target : expr, anno : expr, content : expr) -> stmt:
    return AnnoAssign(target, anno, content)
        

@dataclass(frozen=True, eq=True)
class AnnoDeclar(stmt):
    target : expr
    anno : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoDeclar(self)

def make_AnnoDeclar(target : expr, anno : expr) -> stmt:
    return AnnoDeclar(target, anno)
        

@dataclass(frozen=True, eq=True)
class For(stmt):
    target : expr
    iter : expr
    body : statements

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_For(self)

def make_For(target : expr, iter : expr, body : statements) -> stmt:
    return For(target, iter, body)
        

@dataclass(frozen=True, eq=True)
class ForElse(stmt):
    target : expr
    iter : expr
    body : statements
    orelse : ElseBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ForElse(self)

def make_ForElse(target : expr, iter : expr, body : statements, orelse : ElseBlock) -> stmt:
    return ForElse(target, iter, body, orelse)
        

@dataclass(frozen=True, eq=True)
class AsyncFor(stmt):
    target : expr
    iter : expr
    body : statements

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncFor(self)

def make_AsyncFor(target : expr, iter : expr, body : statements) -> stmt:
    return AsyncFor(target, iter, body)
        

@dataclass(frozen=True, eq=True)
class AsyncForElse(stmt):
    target : expr
    iter : expr
    body : statements
    orelse : ElseBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncForElse(self)

def make_AsyncForElse(target : expr, iter : expr, body : statements, orelse : ElseBlock) -> stmt:
    return AsyncForElse(target, iter, body, orelse)
        

@dataclass(frozen=True, eq=True)
class While(stmt):
    test : expr
    body : statements

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_While(self)

def make_While(test : expr, body : statements) -> stmt:
    return While(test, body)
        

@dataclass(frozen=True, eq=True)
class WhileElse(stmt):
    test : expr
    body : statements
    orelse : ElseBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_WhileElse(self)

def make_WhileElse(test : expr, body : statements, orelse : ElseBlock) -> stmt:
    return WhileElse(test, body, orelse)
        

@dataclass(frozen=True, eq=True)
class If(stmt):
    test : expr
    body : statements
    orelse : conditions

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_If(self)

def make_If(test : expr, body : statements, orelse : conditions) -> stmt:
    return If(test, body, orelse)
        

@dataclass(frozen=True, eq=True)
class With(stmt):
    items : sequence_with_item
    body : statements

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_With(self)

def make_With(items : sequence_with_item, body : statements) -> stmt:
    return With(items, body)
        

@dataclass(frozen=True, eq=True)
class AsyncWith(stmt):
    items : sequence_with_item
    body : statements

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncWith(self)

def make_AsyncWith(items : sequence_with_item, body : statements) -> stmt:
    return AsyncWith(items, body)
        

@dataclass(frozen=True, eq=True)
class Raise(stmt):


    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Raise(self)

def make_Raise() -> stmt:
    return Raise()
        

@dataclass(frozen=True, eq=True)
class RaiseExc(stmt):
    exc : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseExc(self)

def make_RaiseExc(exc : expr) -> stmt:
    return RaiseExc(exc)
        

@dataclass(frozen=True, eq=True)
class RaiseFrom(stmt):
    exc : expr
    caus : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseFrom(self)

def make_RaiseFrom(exc : expr, caus : expr) -> stmt:
    return RaiseFrom(exc, caus)
        

@dataclass(frozen=True, eq=True)
class Try(stmt):
    body : statements
    handlers : sequence_ExceptHandler

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Try(self)

def make_Try(body : statements, handlers : sequence_ExceptHandler) -> stmt:
    return Try(body, handlers)
        

@dataclass(frozen=True, eq=True)
class TryElse(stmt):
    body : statements
    handlers : sequence_ExceptHandler
    orelse : ElseBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElse(self)

def make_TryElse(body : statements, handlers : sequence_ExceptHandler, orelse : ElseBlock) -> stmt:
    return TryElse(body, handlers, orelse)
        

@dataclass(frozen=True, eq=True)
class TryExceptFin(stmt):
    body : statements
    handlers : sequence_ExceptHandler
    fin : FinallyBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryExceptFin(self)

def make_TryExceptFin(body : statements, handlers : sequence_ExceptHandler, fin : FinallyBlock) -> stmt:
    return TryExceptFin(body, handlers, fin)
        

@dataclass(frozen=True, eq=True)
class TryFin(stmt):
    body : statements
    fin : FinallyBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryFin(self)

def make_TryFin(body : statements, fin : FinallyBlock) -> stmt:
    return TryFin(body, fin)
        

@dataclass(frozen=True, eq=True)
class TryElseFin(stmt):
    body : statements
    handlers : sequence_ExceptHandler
    orelse : ElseBlock
    fin : FinallyBlock

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElseFin(self)

def make_TryElseFin(body : statements, handlers : sequence_ExceptHandler, orelse : ElseBlock, fin : FinallyBlock) -> stmt:
    return TryElseFin(body, handlers, orelse, fin)
        

@dataclass(frozen=True, eq=True)
class Assert(stmt):
    test : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assert(self)

def make_Assert(test : expr) -> stmt:
    return Assert(test)
        

@dataclass(frozen=True, eq=True)
class AssertMsg(stmt):
    test : expr
    msg : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AssertMsg(self)

def make_AssertMsg(test : expr, msg : expr) -> stmt:
    return AssertMsg(test, msg)
        

@dataclass(frozen=True, eq=True)
class Import(stmt):
    names : sequence_import_name

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Import(self)

def make_Import(names : sequence_import_name) -> stmt:
    return Import(names)
        

@dataclass(frozen=True, eq=True)
class ImportFrom(stmt):
    module : str
    names : sequence_import_name

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportFrom(self)

def make_ImportFrom(module : str, names : sequence_import_name) -> stmt:
    return ImportFrom(module, names)
        

@dataclass(frozen=True, eq=True)
class ImportWildCard(stmt):
    module : str

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportWildCard(self)

def make_ImportWildCard(module : str) -> stmt:
    return ImportWildCard(module)
        

@dataclass(frozen=True, eq=True)
class Global(stmt):
    names : sequence_name

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Global(self)

def make_Global(names : sequence_name) -> stmt:
    return Global(names)
        

@dataclass(frozen=True, eq=True)
class Nonlocal(stmt):
    names : sequence_name

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Nonlocal(self)

def make_Nonlocal(names : sequence_name) -> stmt:
    return Nonlocal(names)
        

@dataclass(frozen=True, eq=True)
class Expr(stmt):
    content : expr

    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Expr(self)

def make_Expr(content : expr) -> stmt:
    return Expr(content)
        

@dataclass(frozen=True, eq=True)
class Pass(stmt):


    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Pass(self)

def make_Pass() -> stmt:
    return Pass()
        

@dataclass(frozen=True, eq=True)
class Break(stmt):


    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Break(self)

def make_Break() -> stmt:
    return Break()
        

@dataclass(frozen=True, eq=True)
class Continue(stmt):


    def _match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Continue(self)

def make_Continue() -> stmt:
    return Continue()
        

# case handlers for type stmt
@dataclass(frozen=True, eq=True)
class StmtHandlers(Generic[T]):
    case_DecFunctionDef : Callable[[DecFunctionDef], T]
    case_DecClassDef : Callable[[DecClassDef], T]
    case_ReturnSomething : Callable[[ReturnSomething], T]
    case_Return : Callable[[Return], T]
    case_Delete : Callable[[Delete], T]
    case_Assign : Callable[[Assign], T]
    case_AugAssign : Callable[[AugAssign], T]
    case_AnnoAssign : Callable[[AnnoAssign], T]
    case_AnnoDeclar : Callable[[AnnoDeclar], T]
    case_For : Callable[[For], T]
    case_ForElse : Callable[[ForElse], T]
    case_AsyncFor : Callable[[AsyncFor], T]
    case_AsyncForElse : Callable[[AsyncForElse], T]
    case_While : Callable[[While], T]
    case_WhileElse : Callable[[WhileElse], T]
    case_If : Callable[[If], T]
    case_With : Callable[[With], T]
    case_AsyncWith : Callable[[AsyncWith], T]
    case_Raise : Callable[[Raise], T]
    case_RaiseExc : Callable[[RaiseExc], T]
    case_RaiseFrom : Callable[[RaiseFrom], T]
    case_Try : Callable[[Try], T]
    case_TryElse : Callable[[TryElse], T]
    case_TryExceptFin : Callable[[TryExceptFin], T]
    case_TryFin : Callable[[TryFin], T]
    case_TryElseFin : Callable[[TryElseFin], T]
    case_Assert : Callable[[Assert], T]
    case_AssertMsg : Callable[[AssertMsg], T]
    case_Import : Callable[[Import], T]
    case_ImportFrom : Callable[[ImportFrom], T]
    case_ImportWildCard : Callable[[ImportWildCard], T]
    case_Global : Callable[[Global], T]
    case_Nonlocal : Callable[[Nonlocal], T]
    case_Expr : Callable[[Expr], T]
    case_Pass : Callable[[Pass], T]
    case_Break : Callable[[Break], T]
    case_Continue : Callable[[Continue], T]


# matching for type stmt
def match_stmt(o : stmt, handlers : StmtHandlers[T]) -> T :
    return o._match(handlers)
    

# type expr
@dataclass(frozen=True, eq=True)
class expr(ABC):
    @abstractmethod
    def _match(self, handlers : ExprHandlers[T]) -> T: pass


# constructors for type expr

@dataclass(frozen=True, eq=True)
class BoolOp(expr):
    left : expr
    op : boolop
    right : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BoolOp(self)

def make_BoolOp(left : expr, op : boolop, right : expr) -> expr:
    return BoolOp(left, op, right)
        

@dataclass(frozen=True, eq=True)
class AssignExpr(expr):
    target : expr
    content : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_AssignExpr(self)

def make_AssignExpr(target : expr, content : expr) -> expr:
    return AssignExpr(target, content)
        

@dataclass(frozen=True, eq=True)
class BinOp(expr):
    left : expr
    op : operator
    right : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BinOp(self)

def make_BinOp(left : expr, op : operator, right : expr) -> expr:
    return BinOp(left, op, right)
        

@dataclass(frozen=True, eq=True)
class UnaryOp(expr):
    op : unaryop
    right : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_UnaryOp(self)

def make_UnaryOp(op : unaryop, right : expr) -> expr:
    return UnaryOp(op, right)
        

@dataclass(frozen=True, eq=True)
class Lambda(expr):
    params : parameters
    body : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Lambda(self)

def make_Lambda(params : parameters, body : expr) -> expr:
    return Lambda(params, body)
        

@dataclass(frozen=True, eq=True)
class IfExp(expr):
    body : expr
    test : expr
    orelse : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_IfExp(self)

def make_IfExp(body : expr, test : expr, orelse : expr) -> expr:
    return IfExp(body, test, orelse)
        

@dataclass(frozen=True, eq=True)
class Dictionary(expr):
    content : dictionary_content

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Dictionary(self)

def make_Dictionary(content : dictionary_content) -> expr:
    return Dictionary(content)
        

@dataclass(frozen=True, eq=True)
class EmptyDictionary(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyDictionary(self)

def make_EmptyDictionary() -> expr:
    return EmptyDictionary()
        

@dataclass(frozen=True, eq=True)
class Set(expr):
    content : comma_exprs

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Set(self)

def make_Set(content : comma_exprs) -> expr:
    return Set(content)
        

@dataclass(frozen=True, eq=True)
class ListComp(expr):
    content : expr
    constraints : comprehension_constraints

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ListComp(self)

def make_ListComp(content : expr, constraints : comprehension_constraints) -> expr:
    return ListComp(content, constraints)
        

@dataclass(frozen=True, eq=True)
class SetComp(expr):
    content : expr
    constraints : comprehension_constraints

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_SetComp(self)

def make_SetComp(content : expr, constraints : comprehension_constraints) -> expr:
    return SetComp(content, constraints)
        

@dataclass(frozen=True, eq=True)
class DictionaryComp(expr):
    key : expr
    content : expr
    constraints : comprehension_constraints

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_DictionaryComp(self)

def make_DictionaryComp(key : expr, content : expr, constraints : comprehension_constraints) -> expr:
    return DictionaryComp(key, content, constraints)
        

@dataclass(frozen=True, eq=True)
class GeneratorExp(expr):
    content : expr
    constraints : comprehension_constraints

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_GeneratorExp(self)

def make_GeneratorExp(content : expr, constraints : comprehension_constraints) -> expr:
    return GeneratorExp(content, constraints)
        

@dataclass(frozen=True, eq=True)
class Await(expr):
    content : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Await(self)

def make_Await(content : expr) -> expr:
    return Await(content)
        

@dataclass(frozen=True, eq=True)
class YieldNothing(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldNothing(self)

def make_YieldNothing() -> expr:
    return YieldNothing()
        

@dataclass(frozen=True, eq=True)
class Yield(expr):
    content : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Yield(self)

def make_Yield(content : expr) -> expr:
    return Yield(content)
        

@dataclass(frozen=True, eq=True)
class YieldFrom(expr):
    content : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldFrom(self)

def make_YieldFrom(content : expr) -> expr:
    return YieldFrom(content)
        

@dataclass(frozen=True, eq=True)
class Compare(expr):
    left : expr
    comps : comparisons

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Compare(self)

def make_Compare(left : expr, comps : comparisons) -> expr:
    return Compare(left, comps)
        

@dataclass(frozen=True, eq=True)
class Call(expr):
    func : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Call(self)

def make_Call(func : expr) -> expr:
    return Call(func)
        

@dataclass(frozen=True, eq=True)
class CallArgs(expr):
    func : expr
    args : arguments

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_CallArgs(self)

def make_CallArgs(func : expr, args : arguments) -> expr:
    return CallArgs(func, args)
        

@dataclass(frozen=True, eq=True)
class Integer(expr):
    content : str

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Integer(self)

def make_Integer(content : str) -> expr:
    return Integer(content)
        

@dataclass(frozen=True, eq=True)
class Float(expr):
    content : str

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Float(self)

def make_Float(content : str) -> expr:
    return Float(content)
        

@dataclass(frozen=True, eq=True)
class ConcatString(expr):
    content : sequence_string

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ConcatString(self)

def make_ConcatString(content : sequence_string) -> expr:
    return ConcatString(content)
        

@dataclass(frozen=True, eq=True)
class True_(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_True_(self)

def make_True_() -> expr:
    return True_()
        

@dataclass(frozen=True, eq=True)
class False_(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_False_(self)

def make_False_() -> expr:
    return False_()
        

@dataclass(frozen=True, eq=True)
class None_(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_None_(self)

def make_None_() -> expr:
    return None_()
        

@dataclass(frozen=True, eq=True)
class Ellip(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Ellip(self)

def make_Ellip() -> expr:
    return Ellip()
        

@dataclass(frozen=True, eq=True)
class Attribute(expr):
    content : expr
    name : str

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Attribute(self)

def make_Attribute(content : expr, name : str) -> expr:
    return Attribute(content, name)
        

@dataclass(frozen=True, eq=True)
class Subscript(expr):
    content : expr
    slice : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Subscript(self)

def make_Subscript(content : expr, slice : expr) -> expr:
    return Subscript(content, slice)
        

@dataclass(frozen=True, eq=True)
class Starred(expr):
    content : expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Starred(self)

def make_Starred(content : expr) -> expr:
    return Starred(content)
        

@dataclass(frozen=True, eq=True)
class Name(expr):
    content : str

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Name(self)

def make_Name(content : str) -> expr:
    return Name(content)
        

@dataclass(frozen=True, eq=True)
class List(expr):
    content : comma_exprs

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_List(self)

def make_List(content : comma_exprs) -> expr:
    return List(content)
        

@dataclass(frozen=True, eq=True)
class EmptyList(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyList(self)

def make_EmptyList() -> expr:
    return EmptyList()
        

@dataclass(frozen=True, eq=True)
class Tuple(expr):
    content : comma_exprs

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Tuple(self)

def make_Tuple(content : comma_exprs) -> expr:
    return Tuple(content)
        

@dataclass(frozen=True, eq=True)
class EmptyTuple(expr):


    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyTuple(self)

def make_EmptyTuple() -> expr:
    return EmptyTuple()
        

@dataclass(frozen=True, eq=True)
class Slice(expr):
    lower : option_expr
    upper : option_expr
    step : option_expr

    def _match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Slice(self)

def make_Slice(lower : option_expr, upper : option_expr, step : option_expr) -> expr:
    return Slice(lower, upper, step)
        

# case handlers for type expr
@dataclass(frozen=True, eq=True)
class ExprHandlers(Generic[T]):
    case_BoolOp : Callable[[BoolOp], T]
    case_AssignExpr : Callable[[AssignExpr], T]
    case_BinOp : Callable[[BinOp], T]
    case_UnaryOp : Callable[[UnaryOp], T]
    case_Lambda : Callable[[Lambda], T]
    case_IfExp : Callable[[IfExp], T]
    case_Dictionary : Callable[[Dictionary], T]
    case_EmptyDictionary : Callable[[EmptyDictionary], T]
    case_Set : Callable[[Set], T]
    case_ListComp : Callable[[ListComp], T]
    case_SetComp : Callable[[SetComp], T]
    case_DictionaryComp : Callable[[DictionaryComp], T]
    case_GeneratorExp : Callable[[GeneratorExp], T]
    case_Await : Callable[[Await], T]
    case_YieldNothing : Callable[[YieldNothing], T]
    case_Yield : Callable[[Yield], T]
    case_YieldFrom : Callable[[YieldFrom], T]
    case_Compare : Callable[[Compare], T]
    case_Call : Callable[[Call], T]
    case_CallArgs : Callable[[CallArgs], T]
    case_Integer : Callable[[Integer], T]
    case_Float : Callable[[Float], T]
    case_ConcatString : Callable[[ConcatString], T]
    case_True_ : Callable[[True_], T]
    case_False_ : Callable[[False_], T]
    case_None_ : Callable[[None_], T]
    case_Ellip : Callable[[Ellip], T]
    case_Attribute : Callable[[Attribute], T]
    case_Subscript : Callable[[Subscript], T]
    case_Starred : Callable[[Starred], T]
    case_Name : Callable[[Name], T]
    case_List : Callable[[List], T]
    case_EmptyList : Callable[[EmptyList], T]
    case_Tuple : Callable[[Tuple], T]
    case_EmptyTuple : Callable[[EmptyTuple], T]
    case_Slice : Callable[[Slice], T]


# matching for type expr
def match_expr(o : expr, handlers : ExprHandlers[T]) -> T :
    return o._match(handlers)
    

# type boolop
@dataclass(frozen=True, eq=True)
class boolop(ABC):
    @abstractmethod
    def _match(self, handlers : BoolopHandlers[T]) -> T: pass


# constructors for type boolop

@dataclass(frozen=True, eq=True)
class And(boolop):


    def _match(self, handlers : BoolopHandlers[T]) -> T:
        return handlers.case_And(self)

def make_And() -> boolop:
    return And()
        

@dataclass(frozen=True, eq=True)
class Or(boolop):


    def _match(self, handlers : BoolopHandlers[T]) -> T:
        return handlers.case_Or(self)

def make_Or() -> boolop:
    return Or()
        

# case handlers for type boolop
@dataclass(frozen=True, eq=True)
class BoolopHandlers(Generic[T]):
    case_And : Callable[[And], T]
    case_Or : Callable[[Or], T]


# matching for type boolop
def match_boolop(o : boolop, handlers : BoolopHandlers[T]) -> T :
    return o._match(handlers)
    

# type operator
@dataclass(frozen=True, eq=True)
class operator(ABC):
    @abstractmethod
    def _match(self, handlers : OperatorHandlers[T]) -> T: pass


# constructors for type operator

@dataclass(frozen=True, eq=True)
class Add(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Add(self)

def make_Add() -> operator:
    return Add()
        

@dataclass(frozen=True, eq=True)
class Sub(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Sub(self)

def make_Sub() -> operator:
    return Sub()
        

@dataclass(frozen=True, eq=True)
class Mult(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Mult(self)

def make_Mult() -> operator:
    return Mult()
        

@dataclass(frozen=True, eq=True)
class MatMult(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_MatMult(self)

def make_MatMult() -> operator:
    return MatMult()
        

@dataclass(frozen=True, eq=True)
class Div(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Div(self)

def make_Div() -> operator:
    return Div()
        

@dataclass(frozen=True, eq=True)
class Mod(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Mod(self)

def make_Mod() -> operator:
    return Mod()
        

@dataclass(frozen=True, eq=True)
class Pow(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_Pow(self)

def make_Pow() -> operator:
    return Pow()
        

@dataclass(frozen=True, eq=True)
class LShift(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_LShift(self)

def make_LShift() -> operator:
    return LShift()
        

@dataclass(frozen=True, eq=True)
class RShift(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_RShift(self)

def make_RShift() -> operator:
    return RShift()
        

@dataclass(frozen=True, eq=True)
class BitOr(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_BitOr(self)

def make_BitOr() -> operator:
    return BitOr()
        

@dataclass(frozen=True, eq=True)
class BitXor(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_BitXor(self)

def make_BitXor() -> operator:
    return BitXor()
        

@dataclass(frozen=True, eq=True)
class BitAnd(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_BitAnd(self)

def make_BitAnd() -> operator:
    return BitAnd()
        

@dataclass(frozen=True, eq=True)
class FloorDiv(operator):


    def _match(self, handlers : OperatorHandlers[T]) -> T:
        return handlers.case_FloorDiv(self)

def make_FloorDiv() -> operator:
    return FloorDiv()
        

# case handlers for type operator
@dataclass(frozen=True, eq=True)
class OperatorHandlers(Generic[T]):
    case_Add : Callable[[Add], T]
    case_Sub : Callable[[Sub], T]
    case_Mult : Callable[[Mult], T]
    case_MatMult : Callable[[MatMult], T]
    case_Div : Callable[[Div], T]
    case_Mod : Callable[[Mod], T]
    case_Pow : Callable[[Pow], T]
    case_LShift : Callable[[LShift], T]
    case_RShift : Callable[[RShift], T]
    case_BitOr : Callable[[BitOr], T]
    case_BitXor : Callable[[BitXor], T]
    case_BitAnd : Callable[[BitAnd], T]
    case_FloorDiv : Callable[[FloorDiv], T]


# matching for type operator
def match_operator(o : operator, handlers : OperatorHandlers[T]) -> T :
    return o._match(handlers)
    

# type unaryop
@dataclass(frozen=True, eq=True)
class unaryop(ABC):
    @abstractmethod
    def _match(self, handlers : UnaryopHandlers[T]) -> T: pass


# constructors for type unaryop

@dataclass(frozen=True, eq=True)
class Invert(unaryop):


    def _match(self, handlers : UnaryopHandlers[T]) -> T:
        return handlers.case_Invert(self)

def make_Invert() -> unaryop:
    return Invert()
        

@dataclass(frozen=True, eq=True)
class Not(unaryop):


    def _match(self, handlers : UnaryopHandlers[T]) -> T:
        return handlers.case_Not(self)

def make_Not() -> unaryop:
    return Not()
        

@dataclass(frozen=True, eq=True)
class UAdd(unaryop):


    def _match(self, handlers : UnaryopHandlers[T]) -> T:
        return handlers.case_UAdd(self)

def make_UAdd() -> unaryop:
    return UAdd()
        

@dataclass(frozen=True, eq=True)
class USub(unaryop):


    def _match(self, handlers : UnaryopHandlers[T]) -> T:
        return handlers.case_USub(self)

def make_USub() -> unaryop:
    return USub()
        

# case handlers for type unaryop
@dataclass(frozen=True, eq=True)
class UnaryopHandlers(Generic[T]):
    case_Invert : Callable[[Invert], T]
    case_Not : Callable[[Not], T]
    case_UAdd : Callable[[UAdd], T]
    case_USub : Callable[[USub], T]


# matching for type unaryop
def match_unaryop(o : unaryop, handlers : UnaryopHandlers[T]) -> T :
    return o._match(handlers)
    

# type cmpop
@dataclass(frozen=True, eq=True)
class cmpop(ABC):
    @abstractmethod
    def _match(self, handlers : CmpopHandlers[T]) -> T: pass


# constructors for type cmpop

@dataclass(frozen=True, eq=True)
class Eq(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_Eq(self)

def make_Eq() -> cmpop:
    return Eq()
        

@dataclass(frozen=True, eq=True)
class NotEq(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_NotEq(self)

def make_NotEq() -> cmpop:
    return NotEq()
        

@dataclass(frozen=True, eq=True)
class Lt(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_Lt(self)

def make_Lt() -> cmpop:
    return Lt()
        

@dataclass(frozen=True, eq=True)
class LtE(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_LtE(self)

def make_LtE() -> cmpop:
    return LtE()
        

@dataclass(frozen=True, eq=True)
class Gt(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_Gt(self)

def make_Gt() -> cmpop:
    return Gt()
        

@dataclass(frozen=True, eq=True)
class GtE(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_GtE(self)

def make_GtE() -> cmpop:
    return GtE()
        

@dataclass(frozen=True, eq=True)
class Is(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_Is(self)

def make_Is() -> cmpop:
    return Is()
        

@dataclass(frozen=True, eq=True)
class IsNot(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_IsNot(self)

def make_IsNot() -> cmpop:
    return IsNot()
        

@dataclass(frozen=True, eq=True)
class In(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_In(self)

def make_In() -> cmpop:
    return In()
        

@dataclass(frozen=True, eq=True)
class NotIn(cmpop):


    def _match(self, handlers : CmpopHandlers[T]) -> T:
        return handlers.case_NotIn(self)

def make_NotIn() -> cmpop:
    return NotIn()
        

# case handlers for type cmpop
@dataclass(frozen=True, eq=True)
class CmpopHandlers(Generic[T]):
    case_Eq : Callable[[Eq], T]
    case_NotEq : Callable[[NotEq], T]
    case_Lt : Callable[[Lt], T]
    case_LtE : Callable[[LtE], T]
    case_Gt : Callable[[Gt], T]
    case_GtE : Callable[[GtE], T]
    case_Is : Callable[[Is], T]
    case_IsNot : Callable[[IsNot], T]
    case_In : Callable[[In], T]
    case_NotIn : Callable[[NotIn], T]


# matching for type cmpop
def match_cmpop(o : cmpop, handlers : CmpopHandlers[T]) -> T :
    return o._match(handlers)
    

# type constraint
@dataclass(frozen=True, eq=True)
class constraint(ABC):
    @abstractmethod
    def _match(self, handlers : ConstraintHandlers[T]) -> T: pass


# constructors for type constraint

@dataclass(frozen=True, eq=True)
class AsyncConstraint(constraint):
    target : expr
    search_space : expr
    filts : constraint_filters

    def _match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_AsyncConstraint(self)

def make_AsyncConstraint(target : expr, search_space : expr, filts : constraint_filters) -> constraint:
    return AsyncConstraint(target, search_space, filts)
        

@dataclass(frozen=True, eq=True)
class Constraint(constraint):
    target : expr
    search_space : expr
    filts : constraint_filters

    def _match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_Constraint(self)

def make_Constraint(target : expr, search_space : expr, filts : constraint_filters) -> constraint:
    return Constraint(target, search_space, filts)
        

# case handlers for type constraint
@dataclass(frozen=True, eq=True)
class ConstraintHandlers(Generic[T]):
    case_AsyncConstraint : Callable[[AsyncConstraint], T]
    case_Constraint : Callable[[Constraint], T]


# matching for type constraint
def match_constraint(o : constraint, handlers : ConstraintHandlers[T]) -> T :
    return o._match(handlers)
     


# type and constructor CompareRight
@dataclass(frozen=True, eq=True)
class CompareRight:
    op : cmpop
    rand : expr


# type and constructor ExceptHandler
@dataclass(frozen=True, eq=True)
class ExceptHandler:
    arg : except_arg
    body : statements


# type and constructor Param
@dataclass(frozen=True, eq=True)
class Param:
    name : str
    anno : param_annotation
    default : param_default


# type and constructor ClassDef
@dataclass(frozen=True, eq=True)
class ClassDef:
    name : str
    bs : bases
    body : statements


# type and constructor ElifBlock
@dataclass(frozen=True, eq=True)
class ElifBlock:
    test : expr
    body : statements


# type and constructor ElseBlock
@dataclass(frozen=True, eq=True)
class ElseBlock:
    body : statements


# type and constructor FinallyBlock
@dataclass(frozen=True, eq=True)
class FinallyBlock:
    body : statements
 
    