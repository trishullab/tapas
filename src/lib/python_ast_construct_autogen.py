# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST





from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass


from typing import Union


# type return_annotation
@dataclass(frozen=True, eq=True)
class return_annotation(ABC):
    # @abstractmethod
    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        raise Exception()


# constructors for type return_annotation

@dataclass(frozen=True, eq=True)
class SomeReturnAnno(return_annotation):
    content : expr | None

    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_SomeReturnAnno(self)

def make_SomeReturnAnno(
    content : expr | None
) -> return_annotation:
    return SomeReturnAnno(
        content
    )

def update_SomeReturnAnno(source_SomeReturnAnno : SomeReturnAnno,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SomeReturnAnno:
    return SomeReturnAnno(
        source_SomeReturnAnno.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoReturnAnno(return_annotation):


    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_NoReturnAnno(self)

def make_NoReturnAnno(
) -> return_annotation:
    return NoReturnAnno(
    )

def update_NoReturnAnno(source_NoReturnAnno : NoReturnAnno
) -> NoReturnAnno:
    return NoReturnAnno(
    )

        

# case handlers for type return_annotation
@dataclass(frozen=True, eq=True)
class ReturnAnnotationHandlers(Generic[T]):
    case_SomeReturnAnno : Callable[[SomeReturnAnno], T]
    case_NoReturnAnno : Callable[[NoReturnAnno], T]


# matching for type return_annotation
def match_return_annotation(o : return_annotation, handlers : ReturnAnnotationHandlers[T]) -> T :
    return o.match(handlers)
    

# type except_arg
@dataclass(frozen=True, eq=True)
class except_arg(ABC):
    # @abstractmethod
    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        raise Exception()


# constructors for type except_arg

@dataclass(frozen=True, eq=True)
class SomeExceptArg(except_arg):
    content : expr | None

    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArg(self)

def make_SomeExceptArg(
    content : expr | None
) -> except_arg:
    return SomeExceptArg(
        content
    )

def update_SomeExceptArg(source_SomeExceptArg : SomeExceptArg,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SomeExceptArg:
    return SomeExceptArg(
        source_SomeExceptArg.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class SomeExceptArgName(except_arg):
    content : expr | None
    name : str

    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArgName(self)

def make_SomeExceptArgName(
    content : expr | None, 
    name : str
) -> except_arg:
    return SomeExceptArgName(
        content,
        name
    )

def update_SomeExceptArgName(source_SomeExceptArgName : SomeExceptArgName,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    name : Union[str, SourceFlag] = SourceFlag()
) -> SomeExceptArgName:
    return SomeExceptArgName(
        source_SomeExceptArgName.content if isinstance(content, SourceFlag) else content,
        source_SomeExceptArgName.name if isinstance(name, SourceFlag) else name
    )

        

@dataclass(frozen=True, eq=True)
class NoExceptArg(except_arg):


    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_NoExceptArg(self)

def make_NoExceptArg(
) -> except_arg:
    return NoExceptArg(
    )

def update_NoExceptArg(source_NoExceptArg : NoExceptArg
) -> NoExceptArg:
    return NoExceptArg(
    )

        

# case handlers for type except_arg
@dataclass(frozen=True, eq=True)
class ExceptArgHandlers(Generic[T]):
    case_SomeExceptArg : Callable[[SomeExceptArg], T]
    case_SomeExceptArgName : Callable[[SomeExceptArgName], T]
    case_NoExceptArg : Callable[[NoExceptArg], T]


# matching for type except_arg
def match_except_arg(o : except_arg, handlers : ExceptArgHandlers[T]) -> T :
    return o.match(handlers)
    

# type param_annotation
@dataclass(frozen=True, eq=True)
class param_annotation(ABC):
    # @abstractmethod
    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        raise Exception()


# constructors for type param_annotation

@dataclass(frozen=True, eq=True)
class SomeParamAnno(param_annotation):
    content : expr | None

    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_SomeParamAnno(self)

def make_SomeParamAnno(
    content : expr | None
) -> param_annotation:
    return SomeParamAnno(
        content
    )

def update_SomeParamAnno(source_SomeParamAnno : SomeParamAnno,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SomeParamAnno:
    return SomeParamAnno(
        source_SomeParamAnno.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoParamAnno(param_annotation):


    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_NoParamAnno(self)

def make_NoParamAnno(
) -> param_annotation:
    return NoParamAnno(
    )

def update_NoParamAnno(source_NoParamAnno : NoParamAnno
) -> NoParamAnno:
    return NoParamAnno(
    )

        

# case handlers for type param_annotation
@dataclass(frozen=True, eq=True)
class ParamAnnotationHandlers(Generic[T]):
    case_SomeParamAnno : Callable[[SomeParamAnno], T]
    case_NoParamAnno : Callable[[NoParamAnno], T]


# matching for type param_annotation
def match_param_annotation(o : param_annotation, handlers : ParamAnnotationHandlers[T]) -> T :
    return o.match(handlers)
    

# type param_default
@dataclass(frozen=True, eq=True)
class param_default(ABC):
    # @abstractmethod
    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        raise Exception()


# constructors for type param_default

@dataclass(frozen=True, eq=True)
class SomeParamDefault(param_default):
    content : expr | None

    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_SomeParamDefault(self)

def make_SomeParamDefault(
    content : expr | None
) -> param_default:
    return SomeParamDefault(
        content
    )

def update_SomeParamDefault(source_SomeParamDefault : SomeParamDefault,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SomeParamDefault:
    return SomeParamDefault(
        source_SomeParamDefault.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoParamDefault(param_default):


    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_NoParamDefault(self)

def make_NoParamDefault(
) -> param_default:
    return NoParamDefault(
    )

def update_NoParamDefault(source_NoParamDefault : NoParamDefault
) -> NoParamDefault:
    return NoParamDefault(
    )

        

# case handlers for type param_default
@dataclass(frozen=True, eq=True)
class ParamDefaultHandlers(Generic[T]):
    case_SomeParamDefault : Callable[[SomeParamDefault], T]
    case_NoParamDefault : Callable[[NoParamDefault], T]


# matching for type param_default
def match_param_default(o : param_default, handlers : ParamDefaultHandlers[T]) -> T :
    return o.match(handlers)
    

# type parameters_d
@dataclass(frozen=True, eq=True)
class parameters_d(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersDHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_d

@dataclass(frozen=True, eq=True)
class ConsKwParam(parameters_d):
    head : Param | None
    tail : parameters_d | None

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_ConsKwParam(self)

def make_ConsKwParam(
    head : Param | None, 
    tail : parameters_d | None
) -> parameters_d:
    return ConsKwParam(
        head,
        tail
    )

def update_ConsKwParam(source_ConsKwParam : ConsKwParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_d | None, SourceFlag] = SourceFlag()
) -> ConsKwParam:
    return ConsKwParam(
        source_ConsKwParam.head if isinstance(head, SourceFlag) else head,
        source_ConsKwParam.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleKwParam(parameters_d):
    content : Param | None

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_SingleKwParam(self)

def make_SingleKwParam(
    content : Param | None
) -> parameters_d:
    return SingleKwParam(
        content
    )

def update_SingleKwParam(source_SingleKwParam : SingleKwParam,
    content : Union[Param | None, SourceFlag] = SourceFlag()
) -> SingleKwParam:
    return SingleKwParam(
        source_SingleKwParam.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class DictionarySplatParam(parameters_d):
    content : Param | None

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_DictionarySplatParam(self)

def make_DictionarySplatParam(
    content : Param | None
) -> parameters_d:
    return DictionarySplatParam(
        content
    )

def update_DictionarySplatParam(source_DictionarySplatParam : DictionarySplatParam,
    content : Union[Param | None, SourceFlag] = SourceFlag()
) -> DictionarySplatParam:
    return DictionarySplatParam(
        source_DictionarySplatParam.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type parameters_d
@dataclass(frozen=True, eq=True)
class ParametersDHandlers(Generic[T]):
    case_ConsKwParam : Callable[[ConsKwParam], T]
    case_SingleKwParam : Callable[[SingleKwParam], T]
    case_DictionarySplatParam : Callable[[DictionarySplatParam], T]


# matching for type parameters_d
def match_parameters_d(o : parameters_d, handlers : ParametersDHandlers[T]) -> T :
    return o.match(handlers)
    

# type parameters_c
@dataclass(frozen=True, eq=True)
class parameters_c(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersCHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_c

@dataclass(frozen=True, eq=True)
class SingleListSplatParam(parameters_c):
    content : Param | None

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_SingleListSplatParam(self)

def make_SingleListSplatParam(
    content : Param | None
) -> parameters_c:
    return SingleListSplatParam(
        content
    )

def update_SingleListSplatParam(source_SingleListSplatParam : SingleListSplatParam,
    content : Union[Param | None, SourceFlag] = SourceFlag()
) -> SingleListSplatParam:
    return SingleListSplatParam(
        source_SingleListSplatParam.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class TransListSplatParam(parameters_c):
    head : Param | None
    tail : parameters_d | None

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_TransListSplatParam(self)

def make_TransListSplatParam(
    head : Param | None, 
    tail : parameters_d | None
) -> parameters_c:
    return TransListSplatParam(
        head,
        tail
    )

def update_TransListSplatParam(source_TransListSplatParam : TransListSplatParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_d | None, SourceFlag] = SourceFlag()
) -> TransListSplatParam:
    return TransListSplatParam(
        source_TransListSplatParam.head if isinstance(head, SourceFlag) else head,
        source_TransListSplatParam.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class ParamsD(parameters_c):
    content : parameters_d | None

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_ParamsD(self)

def make_ParamsD(
    content : parameters_d | None
) -> parameters_c:
    return ParamsD(
        content
    )

def update_ParamsD(source_ParamsD : ParamsD,
    content : Union[parameters_d | None, SourceFlag] = SourceFlag()
) -> ParamsD:
    return ParamsD(
        source_ParamsD.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type parameters_c
@dataclass(frozen=True, eq=True)
class ParametersCHandlers(Generic[T]):
    case_SingleListSplatParam : Callable[[SingleListSplatParam], T]
    case_TransListSplatParam : Callable[[TransListSplatParam], T]
    case_ParamsD : Callable[[ParamsD], T]


# matching for type parameters_c
def match_parameters_c(o : parameters_c, handlers : ParametersCHandlers[T]) -> T :
    return o.match(handlers)
    

# type parameters_b
@dataclass(frozen=True, eq=True)
class parameters_b(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersBHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_b

@dataclass(frozen=True, eq=True)
class ConsPosKeyParam(parameters_b):
    head : Param | None
    tail : parameters_b | None

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ConsPosKeyParam(self)

def make_ConsPosKeyParam(
    head : Param | None, 
    tail : parameters_b | None
) -> parameters_b:
    return ConsPosKeyParam(
        head,
        tail
    )

def update_ConsPosKeyParam(source_ConsPosKeyParam : ConsPosKeyParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_b | None, SourceFlag] = SourceFlag()
) -> ConsPosKeyParam:
    return ConsPosKeyParam(
        source_ConsPosKeyParam.head if isinstance(head, SourceFlag) else head,
        source_ConsPosKeyParam.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SinglePosKeyParam(parameters_b):
    content : Param | None

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_SinglePosKeyParam(self)

def make_SinglePosKeyParam(
    content : Param | None
) -> parameters_b:
    return SinglePosKeyParam(
        content
    )

def update_SinglePosKeyParam(source_SinglePosKeyParam : SinglePosKeyParam,
    content : Union[Param | None, SourceFlag] = SourceFlag()
) -> SinglePosKeyParam:
    return SinglePosKeyParam(
        source_SinglePosKeyParam.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class ParamsC(parameters_b):
    content : parameters_c | None

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ParamsC(self)

def make_ParamsC(
    content : parameters_c | None
) -> parameters_b:
    return ParamsC(
        content
    )

def update_ParamsC(source_ParamsC : ParamsC,
    content : Union[parameters_c | None, SourceFlag] = SourceFlag()
) -> ParamsC:
    return ParamsC(
        source_ParamsC.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type parameters_b
@dataclass(frozen=True, eq=True)
class ParametersBHandlers(Generic[T]):
    case_ConsPosKeyParam : Callable[[ConsPosKeyParam], T]
    case_SinglePosKeyParam : Callable[[SinglePosKeyParam], T]
    case_ParamsC : Callable[[ParamsC], T]


# matching for type parameters_b
def match_parameters_b(o : parameters_b, handlers : ParametersBHandlers[T]) -> T :
    return o.match(handlers)
    

# type parameters_a
@dataclass(frozen=True, eq=True)
class parameters_a(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersAHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_a

@dataclass(frozen=True, eq=True)
class ConsPosParam(parameters_a):
    head : Param | None
    tail : parameters_a | None

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_ConsPosParam(self)

def make_ConsPosParam(
    head : Param | None, 
    tail : parameters_a | None
) -> parameters_a:
    return ConsPosParam(
        head,
        tail
    )

def update_ConsPosParam(source_ConsPosParam : ConsPosParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_a | None, SourceFlag] = SourceFlag()
) -> ConsPosParam:
    return ConsPosParam(
        source_ConsPosParam.head if isinstance(head, SourceFlag) else head,
        source_ConsPosParam.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SinglePosParam(parameters_a):
    content : Param | None

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_SinglePosParam(self)

def make_SinglePosParam(
    content : Param | None
) -> parameters_a:
    return SinglePosParam(
        content
    )

def update_SinglePosParam(source_SinglePosParam : SinglePosParam,
    content : Union[Param | None, SourceFlag] = SourceFlag()
) -> SinglePosParam:
    return SinglePosParam(
        source_SinglePosParam.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class TransPosParam(parameters_a):
    head : Param | None
    tail : parameters_b | None

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_TransPosParam(self)

def make_TransPosParam(
    head : Param | None, 
    tail : parameters_b | None
) -> parameters_a:
    return TransPosParam(
        head,
        tail
    )

def update_TransPosParam(source_TransPosParam : TransPosParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_b | None, SourceFlag] = SourceFlag()
) -> TransPosParam:
    return TransPosParam(
        source_TransPosParam.head if isinstance(head, SourceFlag) else head,
        source_TransPosParam.tail if isinstance(tail, SourceFlag) else tail
    )

        

# case handlers for type parameters_a
@dataclass(frozen=True, eq=True)
class ParametersAHandlers(Generic[T]):
    case_ConsPosParam : Callable[[ConsPosParam], T]
    case_SinglePosParam : Callable[[SinglePosParam], T]
    case_TransPosParam : Callable[[TransPosParam], T]


# matching for type parameters_a
def match_parameters_a(o : parameters_a, handlers : ParametersAHandlers[T]) -> T :
    return o.match(handlers)
    

# type parameters
@dataclass(frozen=True, eq=True)
class parameters(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters

@dataclass(frozen=True, eq=True)
class ParamsA(parameters):
    content : parameters_a | None

    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsA(self)

def make_ParamsA(
    content : parameters_a | None
) -> parameters:
    return ParamsA(
        content
    )

def update_ParamsA(source_ParamsA : ParamsA,
    content : Union[parameters_a | None, SourceFlag] = SourceFlag()
) -> ParamsA:
    return ParamsA(
        source_ParamsA.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class ParamsB(parameters):
    content : parameters_b | None

    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsB(self)

def make_ParamsB(
    content : parameters_b | None
) -> parameters:
    return ParamsB(
        content
    )

def update_ParamsB(source_ParamsB : ParamsB,
    content : Union[parameters_b | None, SourceFlag] = SourceFlag()
) -> ParamsB:
    return ParamsB(
        source_ParamsB.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoParam(parameters):


    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_NoParam(self)

def make_NoParam(
) -> parameters:
    return NoParam(
    )

def update_NoParam(source_NoParam : NoParam
) -> NoParam:
    return NoParam(
    )

        

# case handlers for type parameters
@dataclass(frozen=True, eq=True)
class ParametersHandlers(Generic[T]):
    case_ParamsA : Callable[[ParamsA], T]
    case_ParamsB : Callable[[ParamsB], T]
    case_NoParam : Callable[[NoParam], T]


# matching for type parameters
def match_parameters(o : parameters, handlers : ParametersHandlers[T]) -> T :
    return o.match(handlers)
    

# type keyword
@dataclass(frozen=True, eq=True)
class keyword(ABC):
    # @abstractmethod
    def match(self, handlers : KeywordHandlers[T]) -> T:
        raise Exception()


# constructors for type keyword

@dataclass(frozen=True, eq=True)
class NamedKeyword(keyword):
    name : str
    content : expr | None

    def match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_NamedKeyword(self)

def make_NamedKeyword(
    name : str, 
    content : expr | None
) -> keyword:
    return NamedKeyword(
        name,
        content
    )

def update_NamedKeyword(source_NamedKeyword : NamedKeyword,
    name : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> NamedKeyword:
    return NamedKeyword(
        source_NamedKeyword.name if isinstance(name, SourceFlag) else name,
        source_NamedKeyword.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class SplatKeyword(keyword):
    content : expr | None

    def match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_SplatKeyword(self)

def make_SplatKeyword(
    content : expr | None
) -> keyword:
    return SplatKeyword(
        content
    )

def update_SplatKeyword(source_SplatKeyword : SplatKeyword,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SplatKeyword:
    return SplatKeyword(
        source_SplatKeyword.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type keyword
@dataclass(frozen=True, eq=True)
class KeywordHandlers(Generic[T]):
    case_NamedKeyword : Callable[[NamedKeyword], T]
    case_SplatKeyword : Callable[[SplatKeyword], T]


# matching for type keyword
def match_keyword(o : keyword, handlers : KeywordHandlers[T]) -> T :
    return o.match(handlers)
    

# type import_name
@dataclass(frozen=True, eq=True)
class import_name(ABC):
    # @abstractmethod
    def match(self, handlers : ImportNameHandlers[T]) -> T:
        raise Exception()


# constructors for type import_name

@dataclass(frozen=True, eq=True)
class ImportNameAlias(import_name):
    name : str
    alias : str

    def match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameAlias(self)

def make_ImportNameAlias(
    name : str, 
    alias : str
) -> import_name:
    return ImportNameAlias(
        name,
        alias
    )

def update_ImportNameAlias(source_ImportNameAlias : ImportNameAlias,
    name : Union[str, SourceFlag] = SourceFlag(),
    alias : Union[str, SourceFlag] = SourceFlag()
) -> ImportNameAlias:
    return ImportNameAlias(
        source_ImportNameAlias.name if isinstance(name, SourceFlag) else name,
        source_ImportNameAlias.alias if isinstance(alias, SourceFlag) else alias
    )

        

@dataclass(frozen=True, eq=True)
class ImportNameOnly(import_name):
    name : str

    def match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameOnly(self)

def make_ImportNameOnly(
    name : str
) -> import_name:
    return ImportNameOnly(
        name
    )

def update_ImportNameOnly(source_ImportNameOnly : ImportNameOnly,
    name : Union[str, SourceFlag] = SourceFlag()
) -> ImportNameOnly:
    return ImportNameOnly(
        source_ImportNameOnly.name if isinstance(name, SourceFlag) else name
    )

        

# case handlers for type import_name
@dataclass(frozen=True, eq=True)
class ImportNameHandlers(Generic[T]):
    case_ImportNameAlias : Callable[[ImportNameAlias], T]
    case_ImportNameOnly : Callable[[ImportNameOnly], T]


# matching for type import_name
def match_import_name(o : import_name, handlers : ImportNameHandlers[T]) -> T :
    return o.match(handlers)
    

# type with_item
@dataclass(frozen=True, eq=True)
class with_item(ABC):
    # @abstractmethod
    def match(self, handlers : WithItemHandlers[T]) -> T:
        raise Exception()


# constructors for type with_item

@dataclass(frozen=True, eq=True)
class WithItemAlias(with_item):
    content : expr | None
    alias : expr | None

    def match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemAlias(self)

def make_WithItemAlias(
    content : expr | None, 
    alias : expr | None
) -> with_item:
    return WithItemAlias(
        content,
        alias
    )

def update_WithItemAlias(source_WithItemAlias : WithItemAlias,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    alias : Union[expr | None, SourceFlag] = SourceFlag()
) -> WithItemAlias:
    return WithItemAlias(
        source_WithItemAlias.content if isinstance(content, SourceFlag) else content,
        source_WithItemAlias.alias if isinstance(alias, SourceFlag) else alias
    )

        

@dataclass(frozen=True, eq=True)
class WithItemOnly(with_item):
    content : expr | None

    def match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemOnly(self)

def make_WithItemOnly(
    content : expr | None
) -> with_item:
    return WithItemOnly(
        content
    )

def update_WithItemOnly(source_WithItemOnly : WithItemOnly,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> WithItemOnly:
    return WithItemOnly(
        source_WithItemOnly.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type with_item
@dataclass(frozen=True, eq=True)
class WithItemHandlers(Generic[T]):
    case_WithItemAlias : Callable[[WithItemAlias], T]
    case_WithItemOnly : Callable[[WithItemOnly], T]


# matching for type with_item
def match_with_item(o : with_item, handlers : WithItemHandlers[T]) -> T :
    return o.match(handlers)
    

# type bases
@dataclass(frozen=True, eq=True)
class bases(ABC):
    # @abstractmethod
    def match(self, handlers : BasesHandlers[T]) -> T:
        raise Exception()


# constructors for type bases

@dataclass(frozen=True, eq=True)
class SomeBases(bases):
    bases : bases_a | None

    def match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_SomeBases(self)

def make_SomeBases(
    bases : bases_a | None
) -> bases:
    return SomeBases(
        bases
    )

def update_SomeBases(source_SomeBases : SomeBases,
    bases : Union[bases_a | None, SourceFlag] = SourceFlag()
) -> SomeBases:
    return SomeBases(
        source_SomeBases.bases if isinstance(bases, SourceFlag) else bases
    )

        

@dataclass(frozen=True, eq=True)
class NoBases(bases):


    def match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_NoBases(self)

def make_NoBases(
) -> bases:
    return NoBases(
    )

def update_NoBases(source_NoBases : NoBases
) -> NoBases:
    return NoBases(
    )

        

# case handlers for type bases
@dataclass(frozen=True, eq=True)
class BasesHandlers(Generic[T]):
    case_SomeBases : Callable[[SomeBases], T]
    case_NoBases : Callable[[NoBases], T]


# matching for type bases
def match_bases(o : bases, handlers : BasesHandlers[T]) -> T :
    return o.match(handlers)
    

# type bases_a
@dataclass(frozen=True, eq=True)
class bases_a(ABC):
    # @abstractmethod
    def match(self, handlers : BasesAHandlers[T]) -> T:
        raise Exception()


# constructors for type bases_a

@dataclass(frozen=True, eq=True)
class ConsBase(bases_a):
    head : expr | None
    tail : bases_a | None

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_ConsBase(self)

def make_ConsBase(
    head : expr | None, 
    tail : bases_a | None
) -> bases_a:
    return ConsBase(
        head,
        tail
    )

def update_ConsBase(source_ConsBase : ConsBase,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[bases_a | None, SourceFlag] = SourceFlag()
) -> ConsBase:
    return ConsBase(
        source_ConsBase.head if isinstance(head, SourceFlag) else head,
        source_ConsBase.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleBase(bases_a):
    content : expr | None

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_SingleBase(self)

def make_SingleBase(
    content : expr | None
) -> bases_a:
    return SingleBase(
        content
    )

def update_SingleBase(source_SingleBase : SingleBase,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SingleBase:
    return SingleBase(
        source_SingleBase.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class KeywordBases(bases_a):
    kws : keywords | None

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_KeywordBases(self)

def make_KeywordBases(
    kws : keywords | None
) -> bases_a:
    return KeywordBases(
        kws
    )

def update_KeywordBases(source_KeywordBases : KeywordBases,
    kws : Union[keywords | None, SourceFlag] = SourceFlag()
) -> KeywordBases:
    return KeywordBases(
        source_KeywordBases.kws if isinstance(kws, SourceFlag) else kws
    )

        

# case handlers for type bases_a
@dataclass(frozen=True, eq=True)
class BasesAHandlers(Generic[T]):
    case_ConsBase : Callable[[ConsBase], T]
    case_SingleBase : Callable[[SingleBase], T]
    case_KeywordBases : Callable[[KeywordBases], T]


# matching for type bases_a
def match_bases_a(o : bases_a, handlers : BasesAHandlers[T]) -> T :
    return o.match(handlers)
    

# type keywords
@dataclass(frozen=True, eq=True)
class keywords(ABC):
    # @abstractmethod
    def match(self, handlers : KeywordsHandlers[T]) -> T:
        raise Exception()


# constructors for type keywords

@dataclass(frozen=True, eq=True)
class ConsKeyword(keywords):
    head : keyword | None
    tail : keywords | None

    def match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_ConsKeyword(self)

def make_ConsKeyword(
    head : keyword | None, 
    tail : keywords | None
) -> keywords:
    return ConsKeyword(
        head,
        tail
    )

def update_ConsKeyword(source_ConsKeyword : ConsKeyword,
    head : Union[keyword | None, SourceFlag] = SourceFlag(),
    tail : Union[keywords | None, SourceFlag] = SourceFlag()
) -> ConsKeyword:
    return ConsKeyword(
        source_ConsKeyword.head if isinstance(head, SourceFlag) else head,
        source_ConsKeyword.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleKeyword(keywords):
    content : keyword | None

    def match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_SingleKeyword(self)

def make_SingleKeyword(
    content : keyword | None
) -> keywords:
    return SingleKeyword(
        content
    )

def update_SingleKeyword(source_SingleKeyword : SingleKeyword,
    content : Union[keyword | None, SourceFlag] = SourceFlag()
) -> SingleKeyword:
    return SingleKeyword(
        source_SingleKeyword.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type keywords
@dataclass(frozen=True, eq=True)
class KeywordsHandlers(Generic[T]):
    case_ConsKeyword : Callable[[ConsKeyword], T]
    case_SingleKeyword : Callable[[SingleKeyword], T]


# matching for type keywords
def match_keywords(o : keywords, handlers : KeywordsHandlers[T]) -> T :
    return o.match(handlers)
    

# type comparisons
@dataclass(frozen=True, eq=True)
class comparisons(ABC):
    # @abstractmethod
    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        raise Exception()


# constructors for type comparisons

@dataclass(frozen=True, eq=True)
class ConsCompareRight(comparisons):
    head : CompareRight | None
    tail : comparisons | None

    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_ConsCompareRight(self)

def make_ConsCompareRight(
    head : CompareRight | None, 
    tail : comparisons | None
) -> comparisons:
    return ConsCompareRight(
        head,
        tail
    )

def update_ConsCompareRight(source_ConsCompareRight : ConsCompareRight,
    head : Union[CompareRight | None, SourceFlag] = SourceFlag(),
    tail : Union[comparisons | None, SourceFlag] = SourceFlag()
) -> ConsCompareRight:
    return ConsCompareRight(
        source_ConsCompareRight.head if isinstance(head, SourceFlag) else head,
        source_ConsCompareRight.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleCompareRight(comparisons):
    content : CompareRight | None

    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_SingleCompareRight(self)

def make_SingleCompareRight(
    content : CompareRight | None
) -> comparisons:
    return SingleCompareRight(
        content
    )

def update_SingleCompareRight(source_SingleCompareRight : SingleCompareRight,
    content : Union[CompareRight | None, SourceFlag] = SourceFlag()
) -> SingleCompareRight:
    return SingleCompareRight(
        source_SingleCompareRight.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type comparisons
@dataclass(frozen=True, eq=True)
class ComparisonsHandlers(Generic[T]):
    case_ConsCompareRight : Callable[[ConsCompareRight], T]
    case_SingleCompareRight : Callable[[SingleCompareRight], T]


# matching for type comparisons
def match_comparisons(o : comparisons, handlers : ComparisonsHandlers[T]) -> T :
    return o.match(handlers)
    

# type option_expr
@dataclass(frozen=True, eq=True)
class option_expr(ABC):
    # @abstractmethod
    def match(self, handlers : OptionExprHandlers[T]) -> T:
        raise Exception()


# constructors for type option_expr

@dataclass(frozen=True, eq=True)
class SomeExpr(option_expr):
    content : expr | None

    def match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_SomeExpr(self)

def make_SomeExpr(
    content : expr | None
) -> option_expr:
    return SomeExpr(
        content
    )

def update_SomeExpr(source_SomeExpr : SomeExpr,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SomeExpr:
    return SomeExpr(
        source_SomeExpr.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoExpr(option_expr):


    def match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_NoExpr(self)

def make_NoExpr(
) -> option_expr:
    return NoExpr(
    )

def update_NoExpr(source_NoExpr : NoExpr
) -> NoExpr:
    return NoExpr(
    )

        

# case handlers for type option_expr
@dataclass(frozen=True, eq=True)
class OptionExprHandlers(Generic[T]):
    case_SomeExpr : Callable[[SomeExpr], T]
    case_NoExpr : Callable[[NoExpr], T]


# matching for type option_expr
def match_option_expr(o : option_expr, handlers : OptionExprHandlers[T]) -> T :
    return o.match(handlers)
    

# type comma_exprs
@dataclass(frozen=True, eq=True)
class comma_exprs(ABC):
    # @abstractmethod
    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        raise Exception()


# constructors for type comma_exprs

@dataclass(frozen=True, eq=True)
class ConsExpr(comma_exprs):
    head : expr | None
    tail : comma_exprs | None

    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_ConsExpr(self)

def make_ConsExpr(
    head : expr | None, 
    tail : comma_exprs | None
) -> comma_exprs:
    return ConsExpr(
        head,
        tail
    )

def update_ConsExpr(source_ConsExpr : ConsExpr,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[comma_exprs | None, SourceFlag] = SourceFlag()
) -> ConsExpr:
    return ConsExpr(
        source_ConsExpr.head if isinstance(head, SourceFlag) else head,
        source_ConsExpr.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleExpr(comma_exprs):
    content : expr | None

    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_SingleExpr(self)

def make_SingleExpr(
    content : expr | None
) -> comma_exprs:
    return SingleExpr(
        content
    )

def update_SingleExpr(source_SingleExpr : SingleExpr,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SingleExpr:
    return SingleExpr(
        source_SingleExpr.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type comma_exprs
@dataclass(frozen=True, eq=True)
class CommaExprsHandlers(Generic[T]):
    case_ConsExpr : Callable[[ConsExpr], T]
    case_SingleExpr : Callable[[SingleExpr], T]


# matching for type comma_exprs
def match_comma_exprs(o : comma_exprs, handlers : CommaExprsHandlers[T]) -> T :
    return o.match(handlers)
    

# type target_exprs
@dataclass(frozen=True, eq=True)
class target_exprs(ABC):
    # @abstractmethod
    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        raise Exception()


# constructors for type target_exprs

@dataclass(frozen=True, eq=True)
class ConsTargetExpr(target_exprs):
    head : expr | None
    tail : target_exprs | None

    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_ConsTargetExpr(self)

def make_ConsTargetExpr(
    head : expr | None, 
    tail : target_exprs | None
) -> target_exprs:
    return ConsTargetExpr(
        head,
        tail
    )

def update_ConsTargetExpr(source_ConsTargetExpr : ConsTargetExpr,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[target_exprs | None, SourceFlag] = SourceFlag()
) -> ConsTargetExpr:
    return ConsTargetExpr(
        source_ConsTargetExpr.head if isinstance(head, SourceFlag) else head,
        source_ConsTargetExpr.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleTargetExpr(target_exprs):
    content : expr | None

    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_SingleTargetExpr(self)

def make_SingleTargetExpr(
    content : expr | None
) -> target_exprs:
    return SingleTargetExpr(
        content
    )

def update_SingleTargetExpr(source_SingleTargetExpr : SingleTargetExpr,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SingleTargetExpr:
    return SingleTargetExpr(
        source_SingleTargetExpr.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type target_exprs
@dataclass(frozen=True, eq=True)
class TargetExprsHandlers(Generic[T]):
    case_ConsTargetExpr : Callable[[ConsTargetExpr], T]
    case_SingleTargetExpr : Callable[[SingleTargetExpr], T]


# matching for type target_exprs
def match_target_exprs(o : target_exprs, handlers : TargetExprsHandlers[T]) -> T :
    return o.match(handlers)
    

# type decorators
@dataclass(frozen=True, eq=True)
class decorators(ABC):
    # @abstractmethod
    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        raise Exception()


# constructors for type decorators

@dataclass(frozen=True, eq=True)
class ConsDec(decorators):
    head : expr | None
    tail : decorators | None

    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_ConsDec(self)

def make_ConsDec(
    head : expr | None, 
    tail : decorators | None
) -> decorators:
    return ConsDec(
        head,
        tail
    )

def update_ConsDec(source_ConsDec : ConsDec,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[decorators | None, SourceFlag] = SourceFlag()
) -> ConsDec:
    return ConsDec(
        source_ConsDec.head if isinstance(head, SourceFlag) else head,
        source_ConsDec.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class NoDec(decorators):


    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_NoDec(self)

def make_NoDec(
) -> decorators:
    return NoDec(
    )

def update_NoDec(source_NoDec : NoDec
) -> NoDec:
    return NoDec(
    )

        

# case handlers for type decorators
@dataclass(frozen=True, eq=True)
class DecoratorsHandlers(Generic[T]):
    case_ConsDec : Callable[[ConsDec], T]
    case_NoDec : Callable[[NoDec], T]


# matching for type decorators
def match_decorators(o : decorators, handlers : DecoratorsHandlers[T]) -> T :
    return o.match(handlers)
    

# type constraint_filters
@dataclass(frozen=True, eq=True)
class constraint_filters(ABC):
    # @abstractmethod
    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        raise Exception()


# constructors for type constraint_filters

@dataclass(frozen=True, eq=True)
class ConsFilter(constraint_filters):
    head : expr | None
    tail : constraint_filters | None

    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_ConsFilter(self)

def make_ConsFilter(
    head : expr | None, 
    tail : constraint_filters | None
) -> constraint_filters:
    return ConsFilter(
        head,
        tail
    )

def update_ConsFilter(source_ConsFilter : ConsFilter,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[constraint_filters | None, SourceFlag] = SourceFlag()
) -> ConsFilter:
    return ConsFilter(
        source_ConsFilter.head if isinstance(head, SourceFlag) else head,
        source_ConsFilter.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleFilter(constraint_filters):
    content : expr | None

    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_SingleFilter(self)

def make_SingleFilter(
    content : expr | None
) -> constraint_filters:
    return SingleFilter(
        content
    )

def update_SingleFilter(source_SingleFilter : SingleFilter,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SingleFilter:
    return SingleFilter(
        source_SingleFilter.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoFilter(constraint_filters):


    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_NoFilter(self)

def make_NoFilter(
) -> constraint_filters:
    return NoFilter(
    )

def update_NoFilter(source_NoFilter : NoFilter
) -> NoFilter:
    return NoFilter(
    )

        

# case handlers for type constraint_filters
@dataclass(frozen=True, eq=True)
class ConstraintFiltersHandlers(Generic[T]):
    case_ConsFilter : Callable[[ConsFilter], T]
    case_SingleFilter : Callable[[SingleFilter], T]
    case_NoFilter : Callable[[NoFilter], T]


# matching for type constraint_filters
def match_constraint_filters(o : constraint_filters, handlers : ConstraintFiltersHandlers[T]) -> T :
    return o.match(handlers)
    

# type sequence_string
@dataclass(frozen=True, eq=True)
class sequence_string(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_string

@dataclass(frozen=True, eq=True)
class ConsStr(sequence_string):
    head : str
    tail : sequence_string | None

    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_ConsStr(self)

def make_ConsStr(
    head : str, 
    tail : sequence_string | None
) -> sequence_string:
    return ConsStr(
        head,
        tail
    )

def update_ConsStr(source_ConsStr : ConsStr,
    head : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[sequence_string | None, SourceFlag] = SourceFlag()
) -> ConsStr:
    return ConsStr(
        source_ConsStr.head if isinstance(head, SourceFlag) else head,
        source_ConsStr.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleStr(sequence_string):
    content : str

    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_SingleStr(self)

def make_SingleStr(
    content : str
) -> sequence_string:
    return SingleStr(
        content
    )

def update_SingleStr(source_SingleStr : SingleStr,
    content : Union[str, SourceFlag] = SourceFlag()
) -> SingleStr:
    return SingleStr(
        source_SingleStr.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type sequence_string
@dataclass(frozen=True, eq=True)
class SequenceStringHandlers(Generic[T]):
    case_ConsStr : Callable[[ConsStr], T]
    case_SingleStr : Callable[[SingleStr], T]


# matching for type sequence_string
def match_sequence_string(o : sequence_string, handlers : SequenceStringHandlers[T]) -> T :
    return o.match(handlers)
    

# type arguments
@dataclass(frozen=True, eq=True)
class arguments(ABC):
    # @abstractmethod
    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        raise Exception()


# constructors for type arguments

@dataclass(frozen=True, eq=True)
class ConsArg(arguments):
    head : expr | None
    tail : arguments | None

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_ConsArg(self)

def make_ConsArg(
    head : expr | None, 
    tail : arguments | None
) -> arguments:
    return ConsArg(
        head,
        tail
    )

def update_ConsArg(source_ConsArg : ConsArg,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[arguments | None, SourceFlag] = SourceFlag()
) -> ConsArg:
    return ConsArg(
        source_ConsArg.head if isinstance(head, SourceFlag) else head,
        source_ConsArg.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleArg(arguments):
    content : expr | None

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_SingleArg(self)

def make_SingleArg(
    content : expr | None
) -> arguments:
    return SingleArg(
        content
    )

def update_SingleArg(source_SingleArg : SingleArg,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> SingleArg:
    return SingleArg(
        source_SingleArg.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class KeywordsArg(arguments):
    kws : keywords | None

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_KeywordsArg(self)

def make_KeywordsArg(
    kws : keywords | None
) -> arguments:
    return KeywordsArg(
        kws
    )

def update_KeywordsArg(source_KeywordsArg : KeywordsArg,
    kws : Union[keywords | None, SourceFlag] = SourceFlag()
) -> KeywordsArg:
    return KeywordsArg(
        source_KeywordsArg.kws if isinstance(kws, SourceFlag) else kws
    )

        

# case handlers for type arguments
@dataclass(frozen=True, eq=True)
class ArgumentsHandlers(Generic[T]):
    case_ConsArg : Callable[[ConsArg], T]
    case_SingleArg : Callable[[SingleArg], T]
    case_KeywordsArg : Callable[[KeywordsArg], T]


# matching for type arguments
def match_arguments(o : arguments, handlers : ArgumentsHandlers[T]) -> T :
    return o.match(handlers)
    

# type dictionary_item
@dataclass(frozen=True, eq=True)
class dictionary_item(ABC):
    # @abstractmethod
    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        raise Exception()


# constructors for type dictionary_item

@dataclass(frozen=True, eq=True)
class Field(dictionary_item):
    key : expr | None
    content : expr | None

    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_Field(self)

def make_Field(
    key : expr | None, 
    content : expr | None
) -> dictionary_item:
    return Field(
        key,
        content
    )

def update_Field(source_Field : Field,
    key : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Field:
    return Field(
        source_Field.key if isinstance(key, SourceFlag) else key,
        source_Field.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class DictionarySplatFields(dictionary_item):
    content : expr | None

    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_DictionarySplatFields(self)

def make_DictionarySplatFields(
    content : expr | None
) -> dictionary_item:
    return DictionarySplatFields(
        content
    )

def update_DictionarySplatFields(source_DictionarySplatFields : DictionarySplatFields,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> DictionarySplatFields:
    return DictionarySplatFields(
        source_DictionarySplatFields.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type dictionary_item
@dataclass(frozen=True, eq=True)
class DictionaryItemHandlers(Generic[T]):
    case_Field : Callable[[Field], T]
    case_DictionarySplatFields : Callable[[DictionarySplatFields], T]


# matching for type dictionary_item
def match_dictionary_item(o : dictionary_item, handlers : DictionaryItemHandlers[T]) -> T :
    return o.match(handlers)
    

# type dictionary_content
@dataclass(frozen=True, eq=True)
class dictionary_content(ABC):
    # @abstractmethod
    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        raise Exception()


# constructors for type dictionary_content

@dataclass(frozen=True, eq=True)
class ConsDictionaryItem(dictionary_content):
    head : dictionary_item | None
    tail : dictionary_content | None

    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_ConsDictionaryItem(self)

def make_ConsDictionaryItem(
    head : dictionary_item | None, 
    tail : dictionary_content | None
) -> dictionary_content:
    return ConsDictionaryItem(
        head,
        tail
    )

def update_ConsDictionaryItem(source_ConsDictionaryItem : ConsDictionaryItem,
    head : Union[dictionary_item | None, SourceFlag] = SourceFlag(),
    tail : Union[dictionary_content | None, SourceFlag] = SourceFlag()
) -> ConsDictionaryItem:
    return ConsDictionaryItem(
        source_ConsDictionaryItem.head if isinstance(head, SourceFlag) else head,
        source_ConsDictionaryItem.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleDictionaryItem(dictionary_content):
    content : dictionary_item | None

    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_SingleDictionaryItem(self)

def make_SingleDictionaryItem(
    content : dictionary_item | None
) -> dictionary_content:
    return SingleDictionaryItem(
        content
    )

def update_SingleDictionaryItem(source_SingleDictionaryItem : SingleDictionaryItem,
    content : Union[dictionary_item | None, SourceFlag] = SourceFlag()
) -> SingleDictionaryItem:
    return SingleDictionaryItem(
        source_SingleDictionaryItem.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type dictionary_content
@dataclass(frozen=True, eq=True)
class DictionaryContentHandlers(Generic[T]):
    case_ConsDictionaryItem : Callable[[ConsDictionaryItem], T]
    case_SingleDictionaryItem : Callable[[SingleDictionaryItem], T]


# matching for type dictionary_content
def match_dictionary_content(o : dictionary_content, handlers : DictionaryContentHandlers[T]) -> T :
    return o.match(handlers)
    

# type sequence_name
@dataclass(frozen=True, eq=True)
class sequence_name(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_name

@dataclass(frozen=True, eq=True)
class ConsId(sequence_name):
    head : str
    tail : sequence_name | None

    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_ConsId(self)

def make_ConsId(
    head : str, 
    tail : sequence_name | None
) -> sequence_name:
    return ConsId(
        head,
        tail
    )

def update_ConsId(source_ConsId : ConsId,
    head : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[sequence_name | None, SourceFlag] = SourceFlag()
) -> ConsId:
    return ConsId(
        source_ConsId.head if isinstance(head, SourceFlag) else head,
        source_ConsId.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleId(sequence_name):
    content : str

    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_SingleId(self)

def make_SingleId(
    content : str
) -> sequence_name:
    return SingleId(
        content
    )

def update_SingleId(source_SingleId : SingleId,
    content : Union[str, SourceFlag] = SourceFlag()
) -> SingleId:
    return SingleId(
        source_SingleId.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type sequence_name
@dataclass(frozen=True, eq=True)
class SequenceNameHandlers(Generic[T]):
    case_ConsId : Callable[[ConsId], T]
    case_SingleId : Callable[[SingleId], T]


# matching for type sequence_name
def match_sequence_name(o : sequence_name, handlers : SequenceNameHandlers[T]) -> T :
    return o.match(handlers)
    

# type sequence_import_name
@dataclass(frozen=True, eq=True)
class sequence_import_name(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_import_name

@dataclass(frozen=True, eq=True)
class ConsImportName(sequence_import_name):
    head : import_name | None
    tail : sequence_import_name | None

    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_ConsImportName(self)

def make_ConsImportName(
    head : import_name | None, 
    tail : sequence_import_name | None
) -> sequence_import_name:
    return ConsImportName(
        head,
        tail
    )

def update_ConsImportName(source_ConsImportName : ConsImportName,
    head : Union[import_name | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_import_name | None, SourceFlag] = SourceFlag()
) -> ConsImportName:
    return ConsImportName(
        source_ConsImportName.head if isinstance(head, SourceFlag) else head,
        source_ConsImportName.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleImportName(sequence_import_name):
    content : import_name | None

    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_SingleImportName(self)

def make_SingleImportName(
    content : import_name | None
) -> sequence_import_name:
    return SingleImportName(
        content
    )

def update_SingleImportName(source_SingleImportName : SingleImportName,
    content : Union[import_name | None, SourceFlag] = SourceFlag()
) -> SingleImportName:
    return SingleImportName(
        source_SingleImportName.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type sequence_import_name
@dataclass(frozen=True, eq=True)
class SequenceImportNameHandlers(Generic[T]):
    case_ConsImportName : Callable[[ConsImportName], T]
    case_SingleImportName : Callable[[SingleImportName], T]


# matching for type sequence_import_name
def match_sequence_import_name(o : sequence_import_name, handlers : SequenceImportNameHandlers[T]) -> T :
    return o.match(handlers)
    

# type sequence_with_item
@dataclass(frozen=True, eq=True)
class sequence_with_item(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_with_item

@dataclass(frozen=True, eq=True)
class ConsWithItem(sequence_with_item):
    head : with_item | None
    tail : sequence_with_item | None

    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_ConsWithItem(self)

def make_ConsWithItem(
    head : with_item | None, 
    tail : sequence_with_item | None
) -> sequence_with_item:
    return ConsWithItem(
        head,
        tail
    )

def update_ConsWithItem(source_ConsWithItem : ConsWithItem,
    head : Union[with_item | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_with_item | None, SourceFlag] = SourceFlag()
) -> ConsWithItem:
    return ConsWithItem(
        source_ConsWithItem.head if isinstance(head, SourceFlag) else head,
        source_ConsWithItem.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleWithItem(sequence_with_item):
    content : with_item | None

    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_SingleWithItem(self)

def make_SingleWithItem(
    content : with_item | None
) -> sequence_with_item:
    return SingleWithItem(
        content
    )

def update_SingleWithItem(source_SingleWithItem : SingleWithItem,
    content : Union[with_item | None, SourceFlag] = SourceFlag()
) -> SingleWithItem:
    return SingleWithItem(
        source_SingleWithItem.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type sequence_with_item
@dataclass(frozen=True, eq=True)
class SequenceWithItemHandlers(Generic[T]):
    case_ConsWithItem : Callable[[ConsWithItem], T]
    case_SingleWithItem : Callable[[SingleWithItem], T]


# matching for type sequence_with_item
def match_sequence_with_item(o : sequence_with_item, handlers : SequenceWithItemHandlers[T]) -> T :
    return o.match(handlers)
    

# type module
@dataclass(frozen=True, eq=True)
class module(ABC):
    # @abstractmethod
    def match(self, handlers : ModuleHandlers[T]) -> T:
        raise Exception()


# constructors for type module

@dataclass(frozen=True, eq=True)
class FutureMod(module):
    names : sequence_import_name | None
    body : statements | None

    def match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_FutureMod(self)

def make_FutureMod(
    names : sequence_import_name | None, 
    body : statements | None
) -> module:
    return FutureMod(
        names,
        body
    )

def update_FutureMod(source_FutureMod : FutureMod,
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> FutureMod:
    return FutureMod(
        source_FutureMod.names if isinstance(names, SourceFlag) else names,
        source_FutureMod.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class SimpleMod(module):
    body : statements | None

    def match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_SimpleMod(self)

def make_SimpleMod(
    body : statements | None
) -> module:
    return SimpleMod(
        body
    )

def update_SimpleMod(source_SimpleMod : SimpleMod,
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> SimpleMod:
    return SimpleMod(
        source_SimpleMod.body if isinstance(body, SourceFlag) else body
    )

        

# case handlers for type module
@dataclass(frozen=True, eq=True)
class ModuleHandlers(Generic[T]):
    case_FutureMod : Callable[[FutureMod], T]
    case_SimpleMod : Callable[[SimpleMod], T]


# matching for type module
def match_module(o : module, handlers : ModuleHandlers[T]) -> T :
    return o.match(handlers)
    

# type statements
@dataclass(frozen=True, eq=True)
class statements(ABC):
    # @abstractmethod
    def match(self, handlers : StatementsHandlers[T]) -> T:
        raise Exception()


# constructors for type statements

@dataclass(frozen=True, eq=True)
class ConsStmt(statements):
    head : stmt | None
    tail : statements | None

    def match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_ConsStmt(self)

def make_ConsStmt(
    head : stmt | None, 
    tail : statements | None
) -> statements:
    return ConsStmt(
        head,
        tail
    )

def update_ConsStmt(source_ConsStmt : ConsStmt,
    head : Union[stmt | None, SourceFlag] = SourceFlag(),
    tail : Union[statements | None, SourceFlag] = SourceFlag()
) -> ConsStmt:
    return ConsStmt(
        source_ConsStmt.head if isinstance(head, SourceFlag) else head,
        source_ConsStmt.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleStmt(statements):
    content : stmt | None

    def match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_SingleStmt(self)

def make_SingleStmt(
    content : stmt | None
) -> statements:
    return SingleStmt(
        content
    )

def update_SingleStmt(source_SingleStmt : SingleStmt,
    content : Union[stmt | None, SourceFlag] = SourceFlag()
) -> SingleStmt:
    return SingleStmt(
        source_SingleStmt.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type statements
@dataclass(frozen=True, eq=True)
class StatementsHandlers(Generic[T]):
    case_ConsStmt : Callable[[ConsStmt], T]
    case_SingleStmt : Callable[[SingleStmt], T]


# matching for type statements
def match_statements(o : statements, handlers : StatementsHandlers[T]) -> T :
    return o.match(handlers)
    

# type comprehension_constraints
@dataclass(frozen=True, eq=True)
class comprehension_constraints(ABC):
    # @abstractmethod
    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        raise Exception()


# constructors for type comprehension_constraints

@dataclass(frozen=True, eq=True)
class ConsConstraint(comprehension_constraints):
    head : constraint | None
    tail : comprehension_constraints | None

    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_ConsConstraint(self)

def make_ConsConstraint(
    head : constraint | None, 
    tail : comprehension_constraints | None
) -> comprehension_constraints:
    return ConsConstraint(
        head,
        tail
    )

def update_ConsConstraint(source_ConsConstraint : ConsConstraint,
    head : Union[constraint | None, SourceFlag] = SourceFlag(),
    tail : Union[comprehension_constraints | None, SourceFlag] = SourceFlag()
) -> ConsConstraint:
    return ConsConstraint(
        source_ConsConstraint.head if isinstance(head, SourceFlag) else head,
        source_ConsConstraint.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleConstraint(comprehension_constraints):
    content : constraint | None

    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_SingleConstraint(self)

def make_SingleConstraint(
    content : constraint | None
) -> comprehension_constraints:
    return SingleConstraint(
        content
    )

def update_SingleConstraint(source_SingleConstraint : SingleConstraint,
    content : Union[constraint | None, SourceFlag] = SourceFlag()
) -> SingleConstraint:
    return SingleConstraint(
        source_SingleConstraint.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type comprehension_constraints
@dataclass(frozen=True, eq=True)
class ComprehensionConstraintsHandlers(Generic[T]):
    case_ConsConstraint : Callable[[ConsConstraint], T]
    case_SingleConstraint : Callable[[SingleConstraint], T]


# matching for type comprehension_constraints
def match_comprehension_constraints(o : comprehension_constraints, handlers : ComprehensionConstraintsHandlers[T]) -> T :
    return o.match(handlers)
    

# type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class sequence_ExceptHandler(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_ExceptHandler

@dataclass(frozen=True, eq=True)
class ConsExceptHandler(sequence_ExceptHandler):
    head : ExceptHandler | None
    tail : sequence_ExceptHandler | None

    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_ConsExceptHandler(self)

def make_ConsExceptHandler(
    head : ExceptHandler | None, 
    tail : sequence_ExceptHandler | None
) -> sequence_ExceptHandler:
    return ConsExceptHandler(
        head,
        tail
    )

def update_ConsExceptHandler(source_ConsExceptHandler : ConsExceptHandler,
    head : Union[ExceptHandler | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag()
) -> ConsExceptHandler:
    return ConsExceptHandler(
        source_ConsExceptHandler.head if isinstance(head, SourceFlag) else head,
        source_ConsExceptHandler.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class SingleExceptHandler(sequence_ExceptHandler):
    content : ExceptHandler | None

    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_SingleExceptHandler(self)

def make_SingleExceptHandler(
    content : ExceptHandler | None
) -> sequence_ExceptHandler:
    return SingleExceptHandler(
        content
    )

def update_SingleExceptHandler(source_SingleExceptHandler : SingleExceptHandler,
    content : Union[ExceptHandler | None, SourceFlag] = SourceFlag()
) -> SingleExceptHandler:
    return SingleExceptHandler(
        source_SingleExceptHandler.content if isinstance(content, SourceFlag) else content
    )

        

# case handlers for type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class SequenceExceptHandlerHandlers(Generic[T]):
    case_ConsExceptHandler : Callable[[ConsExceptHandler], T]
    case_SingleExceptHandler : Callable[[SingleExceptHandler], T]


# matching for type sequence_ExceptHandler
def match_sequence_ExceptHandler(o : sequence_ExceptHandler, handlers : SequenceExceptHandlerHandlers[T]) -> T :
    return o.match(handlers)
    

# type conditions
@dataclass(frozen=True, eq=True)
class conditions(ABC):
    # @abstractmethod
    def match(self, handlers : ConditionsHandlers[T]) -> T:
        raise Exception()


# constructors for type conditions

@dataclass(frozen=True, eq=True)
class ElifCond(conditions):
    content : ElifBlock | None
    tail : conditions | None

    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElifCond(self)

def make_ElifCond(
    content : ElifBlock | None, 
    tail : conditions | None
) -> conditions:
    return ElifCond(
        content,
        tail
    )

def update_ElifCond(source_ElifCond : ElifCond,
    content : Union[ElifBlock | None, SourceFlag] = SourceFlag(),
    tail : Union[conditions | None, SourceFlag] = SourceFlag()
) -> ElifCond:
    return ElifCond(
        source_ElifCond.content if isinstance(content, SourceFlag) else content,
        source_ElifCond.tail if isinstance(tail, SourceFlag) else tail
    )

        

@dataclass(frozen=True, eq=True)
class ElseCond(conditions):
    content : ElseBlock | None

    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElseCond(self)

def make_ElseCond(
    content : ElseBlock | None
) -> conditions:
    return ElseCond(
        content
    )

def update_ElseCond(source_ElseCond : ElseCond,
    content : Union[ElseBlock | None, SourceFlag] = SourceFlag()
) -> ElseCond:
    return ElseCond(
        source_ElseCond.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class NoCond(conditions):


    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_NoCond(self)

def make_NoCond(
) -> conditions:
    return NoCond(
    )

def update_NoCond(source_NoCond : NoCond
) -> NoCond:
    return NoCond(
    )

        

# case handlers for type conditions
@dataclass(frozen=True, eq=True)
class ConditionsHandlers(Generic[T]):
    case_ElifCond : Callable[[ElifCond], T]
    case_ElseCond : Callable[[ElseCond], T]
    case_NoCond : Callable[[NoCond], T]


# matching for type conditions
def match_conditions(o : conditions, handlers : ConditionsHandlers[T]) -> T :
    return o.match(handlers)
    

# type function_def
@dataclass(frozen=True, eq=True)
class function_def(ABC):
    # @abstractmethod
    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        raise Exception()


# constructors for type function_def

@dataclass(frozen=True, eq=True)
class FunctionDef(function_def):
    name : str
    params : parameters | None
    ret_anno : return_annotation | None
    body : statements | None

    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_FunctionDef(self)

def make_FunctionDef(
    name : str, 
    params : parameters | None, 
    ret_anno : return_annotation | None, 
    body : statements | None
) -> function_def:
    return FunctionDef(
        name,
        params,
        ret_anno,
        body
    )

def update_FunctionDef(source_FunctionDef : FunctionDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    ret_anno : Union[return_annotation | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> FunctionDef:
    return FunctionDef(
        source_FunctionDef.name if isinstance(name, SourceFlag) else name,
        source_FunctionDef.params if isinstance(params, SourceFlag) else params,
        source_FunctionDef.ret_anno if isinstance(ret_anno, SourceFlag) else ret_anno,
        source_FunctionDef.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class AsyncFunctionDef(function_def):
    name : str
    params : parameters | None
    ret_anno : return_annotation | None
    body : statements | None

    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_AsyncFunctionDef(self)

def make_AsyncFunctionDef(
    name : str, 
    params : parameters | None, 
    ret_anno : return_annotation | None, 
    body : statements | None
) -> function_def:
    return AsyncFunctionDef(
        name,
        params,
        ret_anno,
        body
    )

def update_AsyncFunctionDef(source_AsyncFunctionDef : AsyncFunctionDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    ret_anno : Union[return_annotation | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> AsyncFunctionDef:
    return AsyncFunctionDef(
        source_AsyncFunctionDef.name if isinstance(name, SourceFlag) else name,
        source_AsyncFunctionDef.params if isinstance(params, SourceFlag) else params,
        source_AsyncFunctionDef.ret_anno if isinstance(ret_anno, SourceFlag) else ret_anno,
        source_AsyncFunctionDef.body if isinstance(body, SourceFlag) else body
    )

        

# case handlers for type function_def
@dataclass(frozen=True, eq=True)
class FunctionDefHandlers(Generic[T]):
    case_FunctionDef : Callable[[FunctionDef], T]
    case_AsyncFunctionDef : Callable[[AsyncFunctionDef], T]


# matching for type function_def
def match_function_def(o : function_def, handlers : FunctionDefHandlers[T]) -> T :
    return o.match(handlers)
    

# type stmt
@dataclass(frozen=True, eq=True)
class stmt(ABC):
    # @abstractmethod
    def match(self, handlers : StmtHandlers[T]) -> T:
        raise Exception()


# constructors for type stmt

@dataclass(frozen=True, eq=True)
class DecFunctionDef(stmt):
    decs : decorators | None
    fun_def : function_def | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecFunctionDef(self)

def make_DecFunctionDef(
    decs : decorators | None, 
    fun_def : function_def | None
) -> stmt:
    return DecFunctionDef(
        decs,
        fun_def
    )

def update_DecFunctionDef(source_DecFunctionDef : DecFunctionDef,
    decs : Union[decorators | None, SourceFlag] = SourceFlag(),
    fun_def : Union[function_def | None, SourceFlag] = SourceFlag()
) -> DecFunctionDef:
    return DecFunctionDef(
        source_DecFunctionDef.decs if isinstance(decs, SourceFlag) else decs,
        source_DecFunctionDef.fun_def if isinstance(fun_def, SourceFlag) else fun_def
    )

        

@dataclass(frozen=True, eq=True)
class DecClassDef(stmt):
    decs : decorators | None
    class_def : ClassDef | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecClassDef(self)

def make_DecClassDef(
    decs : decorators | None, 
    class_def : ClassDef | None
) -> stmt:
    return DecClassDef(
        decs,
        class_def
    )

def update_DecClassDef(source_DecClassDef : DecClassDef,
    decs : Union[decorators | None, SourceFlag] = SourceFlag(),
    class_def : Union[ClassDef | None, SourceFlag] = SourceFlag()
) -> DecClassDef:
    return DecClassDef(
        source_DecClassDef.decs if isinstance(decs, SourceFlag) else decs,
        source_DecClassDef.class_def if isinstance(class_def, SourceFlag) else class_def
    )

        

@dataclass(frozen=True, eq=True)
class ReturnSomething(stmt):
    content : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ReturnSomething(self)

def make_ReturnSomething(
    content : expr | None
) -> stmt:
    return ReturnSomething(
        content
    )

def update_ReturnSomething(source_ReturnSomething : ReturnSomething,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> ReturnSomething:
    return ReturnSomething(
        source_ReturnSomething.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class Return(stmt):


    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Return(self)

def make_Return(
) -> stmt:
    return Return(
    )

def update_Return(source_Return : Return
) -> Return:
    return Return(
    )

        

@dataclass(frozen=True, eq=True)
class Delete(stmt):
    targets : comma_exprs | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Delete(self)

def make_Delete(
    targets : comma_exprs | None
) -> stmt:
    return Delete(
        targets
    )

def update_Delete(source_Delete : Delete,
    targets : Union[comma_exprs | None, SourceFlag] = SourceFlag()
) -> Delete:
    return Delete(
        source_Delete.targets if isinstance(targets, SourceFlag) else targets
    )

        

@dataclass(frozen=True, eq=True)
class Assign(stmt):
    targets : target_exprs | None
    content : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assign(self)

def make_Assign(
    targets : target_exprs | None, 
    content : expr | None
) -> stmt:
    return Assign(
        targets,
        content
    )

def update_Assign(source_Assign : Assign,
    targets : Union[target_exprs | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Assign:
    return Assign(
        source_Assign.targets if isinstance(targets, SourceFlag) else targets,
        source_Assign.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class AugAssign(stmt):
    target : expr | None
    op : bin_rator | None
    content : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AugAssign(self)

def make_AugAssign(
    target : expr | None, 
    op : bin_rator | None, 
    content : expr | None
) -> stmt:
    return AugAssign(
        target,
        op,
        content
    )

def update_AugAssign(source_AugAssign : AugAssign,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    op : Union[bin_rator | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> AugAssign:
    return AugAssign(
        source_AugAssign.target if isinstance(target, SourceFlag) else target,
        source_AugAssign.op if isinstance(op, SourceFlag) else op,
        source_AugAssign.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class AnnoAssign(stmt):
    target : expr | None
    anno : expr | None
    content : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoAssign(self)

def make_AnnoAssign(
    target : expr | None, 
    anno : expr | None, 
    content : expr | None
) -> stmt:
    return AnnoAssign(
        target,
        anno,
        content
    )

def update_AnnoAssign(source_AnnoAssign : AnnoAssign,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    anno : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> AnnoAssign:
    return AnnoAssign(
        source_AnnoAssign.target if isinstance(target, SourceFlag) else target,
        source_AnnoAssign.anno if isinstance(anno, SourceFlag) else anno,
        source_AnnoAssign.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class AnnoDeclar(stmt):
    target : expr | None
    anno : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoDeclar(self)

def make_AnnoDeclar(
    target : expr | None, 
    anno : expr | None
) -> stmt:
    return AnnoDeclar(
        target,
        anno
    )

def update_AnnoDeclar(source_AnnoDeclar : AnnoDeclar,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    anno : Union[expr | None, SourceFlag] = SourceFlag()
) -> AnnoDeclar:
    return AnnoDeclar(
        source_AnnoDeclar.target if isinstance(target, SourceFlag) else target,
        source_AnnoDeclar.anno if isinstance(anno, SourceFlag) else anno
    )

        

@dataclass(frozen=True, eq=True)
class For(stmt):
    target : expr | None
    iter : expr | None
    body : statements | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_For(self)

def make_For(
    target : expr | None, 
    iter : expr | None, 
    body : statements | None
) -> stmt:
    return For(
        target,
        iter,
        body
    )

def update_For(source_For : For,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> For:
    return For(
        source_For.target if isinstance(target, SourceFlag) else target,
        source_For.iter if isinstance(iter, SourceFlag) else iter,
        source_For.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class ForElse(stmt):
    target : expr | None
    iter : expr | None
    body : statements | None
    orelse : ElseBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ForElse(self)

def make_ForElse(
    target : expr | None, 
    iter : expr | None, 
    body : statements | None, 
    orelse : ElseBlock | None
) -> stmt:
    return ForElse(
        target,
        iter,
        body,
        orelse
    )

def update_ForElse(source_ForElse : ForElse,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag()
) -> ForElse:
    return ForElse(
        source_ForElse.target if isinstance(target, SourceFlag) else target,
        source_ForElse.iter if isinstance(iter, SourceFlag) else iter,
        source_ForElse.body if isinstance(body, SourceFlag) else body,
        source_ForElse.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class AsyncFor(stmt):
    target : expr | None
    iter : expr | None
    body : statements | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncFor(self)

def make_AsyncFor(
    target : expr | None, 
    iter : expr | None, 
    body : statements | None
) -> stmt:
    return AsyncFor(
        target,
        iter,
        body
    )

def update_AsyncFor(source_AsyncFor : AsyncFor,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> AsyncFor:
    return AsyncFor(
        source_AsyncFor.target if isinstance(target, SourceFlag) else target,
        source_AsyncFor.iter if isinstance(iter, SourceFlag) else iter,
        source_AsyncFor.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class AsyncForElse(stmt):
    target : expr | None
    iter : expr | None
    body : statements | None
    orelse : ElseBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncForElse(self)

def make_AsyncForElse(
    target : expr | None, 
    iter : expr | None, 
    body : statements | None, 
    orelse : ElseBlock | None
) -> stmt:
    return AsyncForElse(
        target,
        iter,
        body,
        orelse
    )

def update_AsyncForElse(source_AsyncForElse : AsyncForElse,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag()
) -> AsyncForElse:
    return AsyncForElse(
        source_AsyncForElse.target if isinstance(target, SourceFlag) else target,
        source_AsyncForElse.iter if isinstance(iter, SourceFlag) else iter,
        source_AsyncForElse.body if isinstance(body, SourceFlag) else body,
        source_AsyncForElse.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class While(stmt):
    test : expr | None
    body : statements | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_While(self)

def make_While(
    test : expr | None, 
    body : statements | None
) -> stmt:
    return While(
        test,
        body
    )

def update_While(source_While : While,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> While:
    return While(
        source_While.test if isinstance(test, SourceFlag) else test,
        source_While.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class WhileElse(stmt):
    test : expr | None
    body : statements | None
    orelse : ElseBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_WhileElse(self)

def make_WhileElse(
    test : expr | None, 
    body : statements | None, 
    orelse : ElseBlock | None
) -> stmt:
    return WhileElse(
        test,
        body,
        orelse
    )

def update_WhileElse(source_WhileElse : WhileElse,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag()
) -> WhileElse:
    return WhileElse(
        source_WhileElse.test if isinstance(test, SourceFlag) else test,
        source_WhileElse.body if isinstance(body, SourceFlag) else body,
        source_WhileElse.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class If(stmt):
    test : expr | None
    body : statements | None
    orelse : conditions | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_If(self)

def make_If(
    test : expr | None, 
    body : statements | None, 
    orelse : conditions | None
) -> stmt:
    return If(
        test,
        body,
        orelse
    )

def update_If(source_If : If,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[conditions | None, SourceFlag] = SourceFlag()
) -> If:
    return If(
        source_If.test if isinstance(test, SourceFlag) else test,
        source_If.body if isinstance(body, SourceFlag) else body,
        source_If.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class With(stmt):
    items : sequence_with_item | None
    body : statements | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_With(self)

def make_With(
    items : sequence_with_item | None, 
    body : statements | None
) -> stmt:
    return With(
        items,
        body
    )

def update_With(source_With : With,
    items : Union[sequence_with_item | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> With:
    return With(
        source_With.items if isinstance(items, SourceFlag) else items,
        source_With.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class AsyncWith(stmt):
    items : sequence_with_item | None
    body : statements | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncWith(self)

def make_AsyncWith(
    items : sequence_with_item | None, 
    body : statements | None
) -> stmt:
    return AsyncWith(
        items,
        body
    )

def update_AsyncWith(source_AsyncWith : AsyncWith,
    items : Union[sequence_with_item | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> AsyncWith:
    return AsyncWith(
        source_AsyncWith.items if isinstance(items, SourceFlag) else items,
        source_AsyncWith.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class Raise(stmt):


    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Raise(self)

def make_Raise(
) -> stmt:
    return Raise(
    )

def update_Raise(source_Raise : Raise
) -> Raise:
    return Raise(
    )

        

@dataclass(frozen=True, eq=True)
class RaiseExc(stmt):
    exc : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseExc(self)

def make_RaiseExc(
    exc : expr | None
) -> stmt:
    return RaiseExc(
        exc
    )

def update_RaiseExc(source_RaiseExc : RaiseExc,
    exc : Union[expr | None, SourceFlag] = SourceFlag()
) -> RaiseExc:
    return RaiseExc(
        source_RaiseExc.exc if isinstance(exc, SourceFlag) else exc
    )

        

@dataclass(frozen=True, eq=True)
class RaiseFrom(stmt):
    exc : expr | None
    caus : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseFrom(self)

def make_RaiseFrom(
    exc : expr | None, 
    caus : expr | None
) -> stmt:
    return RaiseFrom(
        exc,
        caus
    )

def update_RaiseFrom(source_RaiseFrom : RaiseFrom,
    exc : Union[expr | None, SourceFlag] = SourceFlag(),
    caus : Union[expr | None, SourceFlag] = SourceFlag()
) -> RaiseFrom:
    return RaiseFrom(
        source_RaiseFrom.exc if isinstance(exc, SourceFlag) else exc,
        source_RaiseFrom.caus if isinstance(caus, SourceFlag) else caus
    )

        

@dataclass(frozen=True, eq=True)
class Try(stmt):
    body : statements | None
    handlers : sequence_ExceptHandler | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Try(self)

def make_Try(
    body : statements | None, 
    handlers : sequence_ExceptHandler | None
) -> stmt:
    return Try(
        body,
        handlers
    )

def update_Try(source_Try : Try,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag()
) -> Try:
    return Try(
        source_Try.body if isinstance(body, SourceFlag) else body,
        source_Try.handlers if isinstance(handlers, SourceFlag) else handlers
    )

        

@dataclass(frozen=True, eq=True)
class TryElse(stmt):
    body : statements | None
    handlers : sequence_ExceptHandler | None
    orelse : ElseBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElse(self)

def make_TryElse(
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    orelse : ElseBlock | None
) -> stmt:
    return TryElse(
        body,
        handlers,
        orelse
    )

def update_TryElse(source_TryElse : TryElse,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag()
) -> TryElse:
    return TryElse(
        source_TryElse.body if isinstance(body, SourceFlag) else body,
        source_TryElse.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryElse.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class TryExceptFin(stmt):
    body : statements | None
    handlers : sequence_ExceptHandler | None
    fin : FinallyBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryExceptFin(self)

def make_TryExceptFin(
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    fin : FinallyBlock | None
) -> stmt:
    return TryExceptFin(
        body,
        handlers,
        fin
    )

def update_TryExceptFin(source_TryExceptFin : TryExceptFin,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag()
) -> TryExceptFin:
    return TryExceptFin(
        source_TryExceptFin.body if isinstance(body, SourceFlag) else body,
        source_TryExceptFin.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryExceptFin.fin if isinstance(fin, SourceFlag) else fin
    )

        

@dataclass(frozen=True, eq=True)
class TryFin(stmt):
    body : statements | None
    fin : FinallyBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryFin(self)

def make_TryFin(
    body : statements | None, 
    fin : FinallyBlock | None
) -> stmt:
    return TryFin(
        body,
        fin
    )

def update_TryFin(source_TryFin : TryFin,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag()
) -> TryFin:
    return TryFin(
        source_TryFin.body if isinstance(body, SourceFlag) else body,
        source_TryFin.fin if isinstance(fin, SourceFlag) else fin
    )

        

@dataclass(frozen=True, eq=True)
class TryElseFin(stmt):
    body : statements | None
    handlers : sequence_ExceptHandler | None
    orelse : ElseBlock | None
    fin : FinallyBlock | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElseFin(self)

def make_TryElseFin(
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    orelse : ElseBlock | None, 
    fin : FinallyBlock | None
) -> stmt:
    return TryElseFin(
        body,
        handlers,
        orelse,
        fin
    )

def update_TryElseFin(source_TryElseFin : TryElseFin,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag()
) -> TryElseFin:
    return TryElseFin(
        source_TryElseFin.body if isinstance(body, SourceFlag) else body,
        source_TryElseFin.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryElseFin.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_TryElseFin.fin if isinstance(fin, SourceFlag) else fin
    )

        

@dataclass(frozen=True, eq=True)
class Assert(stmt):
    test : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assert(self)

def make_Assert(
    test : expr | None
) -> stmt:
    return Assert(
        test
    )

def update_Assert(source_Assert : Assert,
    test : Union[expr | None, SourceFlag] = SourceFlag()
) -> Assert:
    return Assert(
        source_Assert.test if isinstance(test, SourceFlag) else test
    )

        

@dataclass(frozen=True, eq=True)
class AssertMsg(stmt):
    test : expr | None
    msg : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AssertMsg(self)

def make_AssertMsg(
    test : expr | None, 
    msg : expr | None
) -> stmt:
    return AssertMsg(
        test,
        msg
    )

def update_AssertMsg(source_AssertMsg : AssertMsg,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    msg : Union[expr | None, SourceFlag] = SourceFlag()
) -> AssertMsg:
    return AssertMsg(
        source_AssertMsg.test if isinstance(test, SourceFlag) else test,
        source_AssertMsg.msg if isinstance(msg, SourceFlag) else msg
    )

        

@dataclass(frozen=True, eq=True)
class Import(stmt):
    names : sequence_import_name | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Import(self)

def make_Import(
    names : sequence_import_name | None
) -> stmt:
    return Import(
        names
    )

def update_Import(source_Import : Import,
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag()
) -> Import:
    return Import(
        source_Import.names if isinstance(names, SourceFlag) else names
    )

        

@dataclass(frozen=True, eq=True)
class ImportFrom(stmt):
    module : str
    names : sequence_import_name | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportFrom(self)

def make_ImportFrom(
    module : str, 
    names : sequence_import_name | None
) -> stmt:
    return ImportFrom(
        module,
        names
    )

def update_ImportFrom(source_ImportFrom : ImportFrom,
    module : Union[str, SourceFlag] = SourceFlag(),
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag()
) -> ImportFrom:
    return ImportFrom(
        source_ImportFrom.module if isinstance(module, SourceFlag) else module,
        source_ImportFrom.names if isinstance(names, SourceFlag) else names
    )

        

@dataclass(frozen=True, eq=True)
class ImportWildCard(stmt):
    module : str

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportWildCard(self)

def make_ImportWildCard(
    module : str
) -> stmt:
    return ImportWildCard(
        module
    )

def update_ImportWildCard(source_ImportWildCard : ImportWildCard,
    module : Union[str, SourceFlag] = SourceFlag()
) -> ImportWildCard:
    return ImportWildCard(
        source_ImportWildCard.module if isinstance(module, SourceFlag) else module
    )

        

@dataclass(frozen=True, eq=True)
class Global(stmt):
    names : sequence_name | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Global(self)

def make_Global(
    names : sequence_name | None
) -> stmt:
    return Global(
        names
    )

def update_Global(source_Global : Global,
    names : Union[sequence_name | None, SourceFlag] = SourceFlag()
) -> Global:
    return Global(
        source_Global.names if isinstance(names, SourceFlag) else names
    )

        

@dataclass(frozen=True, eq=True)
class Nonlocal(stmt):
    names : sequence_name | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Nonlocal(self)

def make_Nonlocal(
    names : sequence_name | None
) -> stmt:
    return Nonlocal(
        names
    )

def update_Nonlocal(source_Nonlocal : Nonlocal,
    names : Union[sequence_name | None, SourceFlag] = SourceFlag()
) -> Nonlocal:
    return Nonlocal(
        source_Nonlocal.names if isinstance(names, SourceFlag) else names
    )

        

@dataclass(frozen=True, eq=True)
class Expr(stmt):
    content : expr | None

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Expr(self)

def make_Expr(
    content : expr | None
) -> stmt:
    return Expr(
        content
    )

def update_Expr(source_Expr : Expr,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Expr:
    return Expr(
        source_Expr.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class Pass(stmt):


    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Pass(self)

def make_Pass(
) -> stmt:
    return Pass(
    )

def update_Pass(source_Pass : Pass
) -> Pass:
    return Pass(
    )

        

@dataclass(frozen=True, eq=True)
class Break(stmt):


    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Break(self)

def make_Break(
) -> stmt:
    return Break(
    )

def update_Break(source_Break : Break
) -> Break:
    return Break(
    )

        

@dataclass(frozen=True, eq=True)
class Continue(stmt):


    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Continue(self)

def make_Continue(
) -> stmt:
    return Continue(
    )

def update_Continue(source_Continue : Continue
) -> Continue:
    return Continue(
    )

        

# case handlers for type stmt
@dataclass(frozen=True, eq=True)
class StmtHandlers(Generic[T]):
    case_DecFunctionDef : Callable[[DecFunctionDef], T]
    case_DecClassDef : Callable[[DecClassDef], T]
    case_ReturnSomething : Callable[[ReturnSomething], T]
    case_Return : Callable[[Return], T]
    case_Delete : Callable[[Delete], T]
    case_Assign : Callable[[Assign], T]
    case_AugAssign : Callable[[AugAssign], T]
    case_AnnoAssign : Callable[[AnnoAssign], T]
    case_AnnoDeclar : Callable[[AnnoDeclar], T]
    case_For : Callable[[For], T]
    case_ForElse : Callable[[ForElse], T]
    case_AsyncFor : Callable[[AsyncFor], T]
    case_AsyncForElse : Callable[[AsyncForElse], T]
    case_While : Callable[[While], T]
    case_WhileElse : Callable[[WhileElse], T]
    case_If : Callable[[If], T]
    case_With : Callable[[With], T]
    case_AsyncWith : Callable[[AsyncWith], T]
    case_Raise : Callable[[Raise], T]
    case_RaiseExc : Callable[[RaiseExc], T]
    case_RaiseFrom : Callable[[RaiseFrom], T]
    case_Try : Callable[[Try], T]
    case_TryElse : Callable[[TryElse], T]
    case_TryExceptFin : Callable[[TryExceptFin], T]
    case_TryFin : Callable[[TryFin], T]
    case_TryElseFin : Callable[[TryElseFin], T]
    case_Assert : Callable[[Assert], T]
    case_AssertMsg : Callable[[AssertMsg], T]
    case_Import : Callable[[Import], T]
    case_ImportFrom : Callable[[ImportFrom], T]
    case_ImportWildCard : Callable[[ImportWildCard], T]
    case_Global : Callable[[Global], T]
    case_Nonlocal : Callable[[Nonlocal], T]
    case_Expr : Callable[[Expr], T]
    case_Pass : Callable[[Pass], T]
    case_Break : Callable[[Break], T]
    case_Continue : Callable[[Continue], T]


# matching for type stmt
def match_stmt(o : stmt, handlers : StmtHandlers[T]) -> T :
    return o.match(handlers)
    

# type expr
@dataclass(frozen=True, eq=True)
class expr(ABC):
    # @abstractmethod
    def match(self, handlers : ExprHandlers[T]) -> T:
        raise Exception()


# constructors for type expr

@dataclass(frozen=True, eq=True)
class BoolOp(expr):
    left : expr | None
    op : bool_rator | None
    right : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BoolOp(self)

def make_BoolOp(
    left : expr | None, 
    op : bool_rator | None, 
    right : expr | None
) -> expr:
    return BoolOp(
        left,
        op,
        right
    )

def update_BoolOp(source_BoolOp : BoolOp,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    op : Union[bool_rator | None, SourceFlag] = SourceFlag(),
    right : Union[expr | None, SourceFlag] = SourceFlag()
) -> BoolOp:
    return BoolOp(
        source_BoolOp.left if isinstance(left, SourceFlag) else left,
        source_BoolOp.op if isinstance(op, SourceFlag) else op,
        source_BoolOp.right if isinstance(right, SourceFlag) else right
    )

        

@dataclass(frozen=True, eq=True)
class AssignExpr(expr):
    target : expr | None
    content : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_AssignExpr(self)

def make_AssignExpr(
    target : expr | None, 
    content : expr | None
) -> expr:
    return AssignExpr(
        target,
        content
    )

def update_AssignExpr(source_AssignExpr : AssignExpr,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> AssignExpr:
    return AssignExpr(
        source_AssignExpr.target if isinstance(target, SourceFlag) else target,
        source_AssignExpr.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class BinOp(expr):
    left : expr | None
    rator : bin_rator | None
    right : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BinOp(self)

def make_BinOp(
    left : expr | None, 
    rator : bin_rator | None, 
    right : expr | None
) -> expr:
    return BinOp(
        left,
        rator,
        right
    )

def update_BinOp(source_BinOp : BinOp,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    rator : Union[bin_rator | None, SourceFlag] = SourceFlag(),
    right : Union[expr | None, SourceFlag] = SourceFlag()
) -> BinOp:
    return BinOp(
        source_BinOp.left if isinstance(left, SourceFlag) else left,
        source_BinOp.rator if isinstance(rator, SourceFlag) else rator,
        source_BinOp.right if isinstance(right, SourceFlag) else right
    )

        

@dataclass(frozen=True, eq=True)
class UnaryOp(expr):
    rator : unary_rator | None
    rand : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_UnaryOp(self)

def make_UnaryOp(
    rator : unary_rator | None, 
    rand : expr | None
) -> expr:
    return UnaryOp(
        rator,
        rand
    )

def update_UnaryOp(source_UnaryOp : UnaryOp,
    rator : Union[unary_rator | None, SourceFlag] = SourceFlag(),
    rand : Union[expr | None, SourceFlag] = SourceFlag()
) -> UnaryOp:
    return UnaryOp(
        source_UnaryOp.rator if isinstance(rator, SourceFlag) else rator,
        source_UnaryOp.rand if isinstance(rand, SourceFlag) else rand
    )

        

@dataclass(frozen=True, eq=True)
class Lambda(expr):
    params : parameters | None
    body : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Lambda(self)

def make_Lambda(
    params : parameters | None, 
    body : expr | None
) -> expr:
    return Lambda(
        params,
        body
    )

def update_Lambda(source_Lambda : Lambda,
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    body : Union[expr | None, SourceFlag] = SourceFlag()
) -> Lambda:
    return Lambda(
        source_Lambda.params if isinstance(params, SourceFlag) else params,
        source_Lambda.body if isinstance(body, SourceFlag) else body
    )

        

@dataclass(frozen=True, eq=True)
class IfExp(expr):
    body : expr | None
    test : expr | None
    orelse : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_IfExp(self)

def make_IfExp(
    body : expr | None, 
    test : expr | None, 
    orelse : expr | None
) -> expr:
    return IfExp(
        body,
        test,
        orelse
    )

def update_IfExp(source_IfExp : IfExp,
    body : Union[expr | None, SourceFlag] = SourceFlag(),
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    orelse : Union[expr | None, SourceFlag] = SourceFlag()
) -> IfExp:
    return IfExp(
        source_IfExp.body if isinstance(body, SourceFlag) else body,
        source_IfExp.test if isinstance(test, SourceFlag) else test,
        source_IfExp.orelse if isinstance(orelse, SourceFlag) else orelse
    )

        

@dataclass(frozen=True, eq=True)
class Dictionary(expr):
    content : dictionary_content | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Dictionary(self)

def make_Dictionary(
    content : dictionary_content | None
) -> expr:
    return Dictionary(
        content
    )

def update_Dictionary(source_Dictionary : Dictionary,
    content : Union[dictionary_content | None, SourceFlag] = SourceFlag()
) -> Dictionary:
    return Dictionary(
        source_Dictionary.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class EmptyDictionary(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyDictionary(self)

def make_EmptyDictionary(
) -> expr:
    return EmptyDictionary(
    )

def update_EmptyDictionary(source_EmptyDictionary : EmptyDictionary
) -> EmptyDictionary:
    return EmptyDictionary(
    )

        

@dataclass(frozen=True, eq=True)
class Set(expr):
    content : comma_exprs | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Set(self)

def make_Set(
    content : comma_exprs | None
) -> expr:
    return Set(
        content
    )

def update_Set(source_Set : Set,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag()
) -> Set:
    return Set(
        source_Set.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class ListComp(expr):
    content : expr | None
    constraints : comprehension_constraints | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ListComp(self)

def make_ListComp(
    content : expr | None, 
    constraints : comprehension_constraints | None
) -> expr:
    return ListComp(
        content,
        constraints
    )

def update_ListComp(source_ListComp : ListComp,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag()
) -> ListComp:
    return ListComp(
        source_ListComp.content if isinstance(content, SourceFlag) else content,
        source_ListComp.constraints if isinstance(constraints, SourceFlag) else constraints
    )

        

@dataclass(frozen=True, eq=True)
class SetComp(expr):
    content : expr | None
    constraints : comprehension_constraints | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_SetComp(self)

def make_SetComp(
    content : expr | None, 
    constraints : comprehension_constraints | None
) -> expr:
    return SetComp(
        content,
        constraints
    )

def update_SetComp(source_SetComp : SetComp,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag()
) -> SetComp:
    return SetComp(
        source_SetComp.content if isinstance(content, SourceFlag) else content,
        source_SetComp.constraints if isinstance(constraints, SourceFlag) else constraints
    )

        

@dataclass(frozen=True, eq=True)
class DictionaryComp(expr):
    key : expr | None
    content : expr | None
    constraints : comprehension_constraints | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_DictionaryComp(self)

def make_DictionaryComp(
    key : expr | None, 
    content : expr | None, 
    constraints : comprehension_constraints | None
) -> expr:
    return DictionaryComp(
        key,
        content,
        constraints
    )

def update_DictionaryComp(source_DictionaryComp : DictionaryComp,
    key : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag()
) -> DictionaryComp:
    return DictionaryComp(
        source_DictionaryComp.key if isinstance(key, SourceFlag) else key,
        source_DictionaryComp.content if isinstance(content, SourceFlag) else content,
        source_DictionaryComp.constraints if isinstance(constraints, SourceFlag) else constraints
    )

        

@dataclass(frozen=True, eq=True)
class GeneratorExp(expr):
    content : expr | None
    constraints : comprehension_constraints | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_GeneratorExp(self)

def make_GeneratorExp(
    content : expr | None, 
    constraints : comprehension_constraints | None
) -> expr:
    return GeneratorExp(
        content,
        constraints
    )

def update_GeneratorExp(source_GeneratorExp : GeneratorExp,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag()
) -> GeneratorExp:
    return GeneratorExp(
        source_GeneratorExp.content if isinstance(content, SourceFlag) else content,
        source_GeneratorExp.constraints if isinstance(constraints, SourceFlag) else constraints
    )

        

@dataclass(frozen=True, eq=True)
class Await(expr):
    content : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Await(self)

def make_Await(
    content : expr | None
) -> expr:
    return Await(
        content
    )

def update_Await(source_Await : Await,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Await:
    return Await(
        source_Await.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class YieldNothing(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldNothing(self)

def make_YieldNothing(
) -> expr:
    return YieldNothing(
    )

def update_YieldNothing(source_YieldNothing : YieldNothing
) -> YieldNothing:
    return YieldNothing(
    )

        

@dataclass(frozen=True, eq=True)
class Yield(expr):
    content : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Yield(self)

def make_Yield(
    content : expr | None
) -> expr:
    return Yield(
        content
    )

def update_Yield(source_Yield : Yield,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Yield:
    return Yield(
        source_Yield.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class YieldFrom(expr):
    content : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldFrom(self)

def make_YieldFrom(
    content : expr | None
) -> expr:
    return YieldFrom(
        content
    )

def update_YieldFrom(source_YieldFrom : YieldFrom,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> YieldFrom:
    return YieldFrom(
        source_YieldFrom.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class Compare(expr):
    left : expr | None
    comps : comparisons | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Compare(self)

def make_Compare(
    left : expr | None, 
    comps : comparisons | None
) -> expr:
    return Compare(
        left,
        comps
    )

def update_Compare(source_Compare : Compare,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    comps : Union[comparisons | None, SourceFlag] = SourceFlag()
) -> Compare:
    return Compare(
        source_Compare.left if isinstance(left, SourceFlag) else left,
        source_Compare.comps if isinstance(comps, SourceFlag) else comps
    )

        

@dataclass(frozen=True, eq=True)
class Call(expr):
    func : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Call(self)

def make_Call(
    func : expr | None
) -> expr:
    return Call(
        func
    )

def update_Call(source_Call : Call,
    func : Union[expr | None, SourceFlag] = SourceFlag()
) -> Call:
    return Call(
        source_Call.func if isinstance(func, SourceFlag) else func
    )

        

@dataclass(frozen=True, eq=True)
class CallArgs(expr):
    func : expr | None
    args : arguments | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_CallArgs(self)

def make_CallArgs(
    func : expr | None, 
    args : arguments | None
) -> expr:
    return CallArgs(
        func,
        args
    )

def update_CallArgs(source_CallArgs : CallArgs,
    func : Union[expr | None, SourceFlag] = SourceFlag(),
    args : Union[arguments | None, SourceFlag] = SourceFlag()
) -> CallArgs:
    return CallArgs(
        source_CallArgs.func if isinstance(func, SourceFlag) else func,
        source_CallArgs.args if isinstance(args, SourceFlag) else args
    )

        

@dataclass(frozen=True, eq=True)
class Integer(expr):
    content : str

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Integer(self)

def make_Integer(
    content : str
) -> expr:
    return Integer(
        content
    )

def update_Integer(source_Integer : Integer,
    content : Union[str, SourceFlag] = SourceFlag()
) -> Integer:
    return Integer(
        source_Integer.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class Float(expr):
    content : str

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Float(self)

def make_Float(
    content : str
) -> expr:
    return Float(
        content
    )

def update_Float(source_Float : Float,
    content : Union[str, SourceFlag] = SourceFlag()
) -> Float:
    return Float(
        source_Float.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class ConcatString(expr):
    content : sequence_string | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ConcatString(self)

def make_ConcatString(
    content : sequence_string | None
) -> expr:
    return ConcatString(
        content
    )

def update_ConcatString(source_ConcatString : ConcatString,
    content : Union[sequence_string | None, SourceFlag] = SourceFlag()
) -> ConcatString:
    return ConcatString(
        source_ConcatString.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class True_(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_True_(self)

def make_True_(
) -> expr:
    return True_(
    )

def update_True_(source_True_ : True_
) -> True_:
    return True_(
    )

        

@dataclass(frozen=True, eq=True)
class False_(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_False_(self)

def make_False_(
) -> expr:
    return False_(
    )

def update_False_(source_False_ : False_
) -> False_:
    return False_(
    )

        

@dataclass(frozen=True, eq=True)
class None_(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_None_(self)

def make_None_(
) -> expr:
    return None_(
    )

def update_None_(source_None_ : None_
) -> None_:
    return None_(
    )

        

@dataclass(frozen=True, eq=True)
class Ellip(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Ellip(self)

def make_Ellip(
) -> expr:
    return Ellip(
    )

def update_Ellip(source_Ellip : Ellip
) -> Ellip:
    return Ellip(
    )

        

@dataclass(frozen=True, eq=True)
class Attribute(expr):
    content : expr | None
    name : str

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Attribute(self)

def make_Attribute(
    content : expr | None, 
    name : str
) -> expr:
    return Attribute(
        content,
        name
    )

def update_Attribute(source_Attribute : Attribute,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    name : Union[str, SourceFlag] = SourceFlag()
) -> Attribute:
    return Attribute(
        source_Attribute.content if isinstance(content, SourceFlag) else content,
        source_Attribute.name if isinstance(name, SourceFlag) else name
    )

        

@dataclass(frozen=True, eq=True)
class Subscript(expr):
    content : expr | None
    slice : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Subscript(self)

def make_Subscript(
    content : expr | None, 
    slice : expr | None
) -> expr:
    return Subscript(
        content,
        slice
    )

def update_Subscript(source_Subscript : Subscript,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    slice : Union[expr | None, SourceFlag] = SourceFlag()
) -> Subscript:
    return Subscript(
        source_Subscript.content if isinstance(content, SourceFlag) else content,
        source_Subscript.slice if isinstance(slice, SourceFlag) else slice
    )

        

@dataclass(frozen=True, eq=True)
class Starred(expr):
    content : expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Starred(self)

def make_Starred(
    content : expr | None
) -> expr:
    return Starred(
        content
    )

def update_Starred(source_Starred : Starred,
    content : Union[expr | None, SourceFlag] = SourceFlag()
) -> Starred:
    return Starred(
        source_Starred.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class Name(expr):
    content : str

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Name(self)

def make_Name(
    content : str
) -> expr:
    return Name(
        content
    )

def update_Name(source_Name : Name,
    content : Union[str, SourceFlag] = SourceFlag()
) -> Name:
    return Name(
        source_Name.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class List(expr):
    content : comma_exprs | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_List(self)

def make_List(
    content : comma_exprs | None
) -> expr:
    return List(
        content
    )

def update_List(source_List : List,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag()
) -> List:
    return List(
        source_List.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class EmptyList(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyList(self)

def make_EmptyList(
) -> expr:
    return EmptyList(
    )

def update_EmptyList(source_EmptyList : EmptyList
) -> EmptyList:
    return EmptyList(
    )

        

@dataclass(frozen=True, eq=True)
class Tuple(expr):
    content : comma_exprs | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Tuple(self)

def make_Tuple(
    content : comma_exprs | None
) -> expr:
    return Tuple(
        content
    )

def update_Tuple(source_Tuple : Tuple,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag()
) -> Tuple:
    return Tuple(
        source_Tuple.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class EmptyTuple(expr):


    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyTuple(self)

def make_EmptyTuple(
) -> expr:
    return EmptyTuple(
    )

def update_EmptyTuple(source_EmptyTuple : EmptyTuple
) -> EmptyTuple:
    return EmptyTuple(
    )

        

@dataclass(frozen=True, eq=True)
class Slice(expr):
    lower : option_expr | None
    upper : option_expr | None
    step : option_expr | None

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Slice(self)

def make_Slice(
    lower : option_expr | None, 
    upper : option_expr | None, 
    step : option_expr | None
) -> expr:
    return Slice(
        lower,
        upper,
        step
    )

def update_Slice(source_Slice : Slice,
    lower : Union[option_expr | None, SourceFlag] = SourceFlag(),
    upper : Union[option_expr | None, SourceFlag] = SourceFlag(),
    step : Union[option_expr | None, SourceFlag] = SourceFlag()
) -> Slice:
    return Slice(
        source_Slice.lower if isinstance(lower, SourceFlag) else lower,
        source_Slice.upper if isinstance(upper, SourceFlag) else upper,
        source_Slice.step if isinstance(step, SourceFlag) else step
    )

        

# case handlers for type expr
@dataclass(frozen=True, eq=True)
class ExprHandlers(Generic[T]):
    case_BoolOp : Callable[[BoolOp], T]
    case_AssignExpr : Callable[[AssignExpr], T]
    case_BinOp : Callable[[BinOp], T]
    case_UnaryOp : Callable[[UnaryOp], T]
    case_Lambda : Callable[[Lambda], T]
    case_IfExp : Callable[[IfExp], T]
    case_Dictionary : Callable[[Dictionary], T]
    case_EmptyDictionary : Callable[[EmptyDictionary], T]
    case_Set : Callable[[Set], T]
    case_ListComp : Callable[[ListComp], T]
    case_SetComp : Callable[[SetComp], T]
    case_DictionaryComp : Callable[[DictionaryComp], T]
    case_GeneratorExp : Callable[[GeneratorExp], T]
    case_Await : Callable[[Await], T]
    case_YieldNothing : Callable[[YieldNothing], T]
    case_Yield : Callable[[Yield], T]
    case_YieldFrom : Callable[[YieldFrom], T]
    case_Compare : Callable[[Compare], T]
    case_Call : Callable[[Call], T]
    case_CallArgs : Callable[[CallArgs], T]
    case_Integer : Callable[[Integer], T]
    case_Float : Callable[[Float], T]
    case_ConcatString : Callable[[ConcatString], T]
    case_True_ : Callable[[True_], T]
    case_False_ : Callable[[False_], T]
    case_None_ : Callable[[None_], T]
    case_Ellip : Callable[[Ellip], T]
    case_Attribute : Callable[[Attribute], T]
    case_Subscript : Callable[[Subscript], T]
    case_Starred : Callable[[Starred], T]
    case_Name : Callable[[Name], T]
    case_List : Callable[[List], T]
    case_EmptyList : Callable[[EmptyList], T]
    case_Tuple : Callable[[Tuple], T]
    case_EmptyTuple : Callable[[EmptyTuple], T]
    case_Slice : Callable[[Slice], T]


# matching for type expr
def match_expr(o : expr, handlers : ExprHandlers[T]) -> T :
    return o.match(handlers)
    

# type bool_rator
@dataclass(frozen=True, eq=True)
class bool_rator(ABC):
    # @abstractmethod
    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type bool_rator

@dataclass(frozen=True, eq=True)
class And(bool_rator):


    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        return handlers.case_And(self)

def make_And(
) -> bool_rator:
    return And(
    )

def update_And(source_And : And
) -> And:
    return And(
    )

        

@dataclass(frozen=True, eq=True)
class Or(bool_rator):


    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        return handlers.case_Or(self)

def make_Or(
) -> bool_rator:
    return Or(
    )

def update_Or(source_Or : Or
) -> Or:
    return Or(
    )

        

# case handlers for type bool_rator
@dataclass(frozen=True, eq=True)
class BoolRatorHandlers(Generic[T]):
    case_And : Callable[[And], T]
    case_Or : Callable[[Or], T]


# matching for type bool_rator
def match_bool_rator(o : bool_rator, handlers : BoolRatorHandlers[T]) -> T :
    return o.match(handlers)
    

# type bin_rator
@dataclass(frozen=True, eq=True)
class bin_rator(ABC):
    # @abstractmethod
    def match(self, handlers : BinRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type bin_rator

@dataclass(frozen=True, eq=True)
class Add(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Add(self)

def make_Add(
) -> bin_rator:
    return Add(
    )

def update_Add(source_Add : Add
) -> Add:
    return Add(
    )

        

@dataclass(frozen=True, eq=True)
class Sub(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Sub(self)

def make_Sub(
) -> bin_rator:
    return Sub(
    )

def update_Sub(source_Sub : Sub
) -> Sub:
    return Sub(
    )

        

@dataclass(frozen=True, eq=True)
class Mult(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Mult(self)

def make_Mult(
) -> bin_rator:
    return Mult(
    )

def update_Mult(source_Mult : Mult
) -> Mult:
    return Mult(
    )

        

@dataclass(frozen=True, eq=True)
class MatMult(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_MatMult(self)

def make_MatMult(
) -> bin_rator:
    return MatMult(
    )

def update_MatMult(source_MatMult : MatMult
) -> MatMult:
    return MatMult(
    )

        

@dataclass(frozen=True, eq=True)
class Div(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Div(self)

def make_Div(
) -> bin_rator:
    return Div(
    )

def update_Div(source_Div : Div
) -> Div:
    return Div(
    )

        

@dataclass(frozen=True, eq=True)
class Mod(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Mod(self)

def make_Mod(
) -> bin_rator:
    return Mod(
    )

def update_Mod(source_Mod : Mod
) -> Mod:
    return Mod(
    )

        

@dataclass(frozen=True, eq=True)
class Pow(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Pow(self)

def make_Pow(
) -> bin_rator:
    return Pow(
    )

def update_Pow(source_Pow : Pow
) -> Pow:
    return Pow(
    )

        

@dataclass(frozen=True, eq=True)
class LShift(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_LShift(self)

def make_LShift(
) -> bin_rator:
    return LShift(
    )

def update_LShift(source_LShift : LShift
) -> LShift:
    return LShift(
    )

        

@dataclass(frozen=True, eq=True)
class RShift(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_RShift(self)

def make_RShift(
) -> bin_rator:
    return RShift(
    )

def update_RShift(source_RShift : RShift
) -> RShift:
    return RShift(
    )

        

@dataclass(frozen=True, eq=True)
class BitOr(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitOr(self)

def make_BitOr(
) -> bin_rator:
    return BitOr(
    )

def update_BitOr(source_BitOr : BitOr
) -> BitOr:
    return BitOr(
    )

        

@dataclass(frozen=True, eq=True)
class BitXor(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitXor(self)

def make_BitXor(
) -> bin_rator:
    return BitXor(
    )

def update_BitXor(source_BitXor : BitXor
) -> BitXor:
    return BitXor(
    )

        

@dataclass(frozen=True, eq=True)
class BitAnd(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitAnd(self)

def make_BitAnd(
) -> bin_rator:
    return BitAnd(
    )

def update_BitAnd(source_BitAnd : BitAnd
) -> BitAnd:
    return BitAnd(
    )

        

@dataclass(frozen=True, eq=True)
class FloorDiv(bin_rator):


    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_FloorDiv(self)

def make_FloorDiv(
) -> bin_rator:
    return FloorDiv(
    )

def update_FloorDiv(source_FloorDiv : FloorDiv
) -> FloorDiv:
    return FloorDiv(
    )

        

# case handlers for type bin_rator
@dataclass(frozen=True, eq=True)
class BinRatorHandlers(Generic[T]):
    case_Add : Callable[[Add], T]
    case_Sub : Callable[[Sub], T]
    case_Mult : Callable[[Mult], T]
    case_MatMult : Callable[[MatMult], T]
    case_Div : Callable[[Div], T]
    case_Mod : Callable[[Mod], T]
    case_Pow : Callable[[Pow], T]
    case_LShift : Callable[[LShift], T]
    case_RShift : Callable[[RShift], T]
    case_BitOr : Callable[[BitOr], T]
    case_BitXor : Callable[[BitXor], T]
    case_BitAnd : Callable[[BitAnd], T]
    case_FloorDiv : Callable[[FloorDiv], T]


# matching for type bin_rator
def match_bin_rator(o : bin_rator, handlers : BinRatorHandlers[T]) -> T :
    return o.match(handlers)
    

# type unary_rator
@dataclass(frozen=True, eq=True)
class unary_rator(ABC):
    # @abstractmethod
    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type unary_rator

@dataclass(frozen=True, eq=True)
class Invert(unary_rator):


    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_Invert(self)

def make_Invert(
) -> unary_rator:
    return Invert(
    )

def update_Invert(source_Invert : Invert
) -> Invert:
    return Invert(
    )

        

@dataclass(frozen=True, eq=True)
class Not(unary_rator):


    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_Not(self)

def make_Not(
) -> unary_rator:
    return Not(
    )

def update_Not(source_Not : Not
) -> Not:
    return Not(
    )

        

@dataclass(frozen=True, eq=True)
class UAdd(unary_rator):


    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_UAdd(self)

def make_UAdd(
) -> unary_rator:
    return UAdd(
    )

def update_UAdd(source_UAdd : UAdd
) -> UAdd:
    return UAdd(
    )

        

@dataclass(frozen=True, eq=True)
class USub(unary_rator):


    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_USub(self)

def make_USub(
) -> unary_rator:
    return USub(
    )

def update_USub(source_USub : USub
) -> USub:
    return USub(
    )

        

# case handlers for type unary_rator
@dataclass(frozen=True, eq=True)
class UnaryRatorHandlers(Generic[T]):
    case_Invert : Callable[[Invert], T]
    case_Not : Callable[[Not], T]
    case_UAdd : Callable[[UAdd], T]
    case_USub : Callable[[USub], T]


# matching for type unary_rator
def match_unary_rator(o : unary_rator, handlers : UnaryRatorHandlers[T]) -> T :
    return o.match(handlers)
    

# type cmp_rator
@dataclass(frozen=True, eq=True)
class cmp_rator(ABC):
    # @abstractmethod
    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type cmp_rator

@dataclass(frozen=True, eq=True)
class Eq(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Eq(self)

def make_Eq(
) -> cmp_rator:
    return Eq(
    )

def update_Eq(source_Eq : Eq
) -> Eq:
    return Eq(
    )

        

@dataclass(frozen=True, eq=True)
class NotEq(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_NotEq(self)

def make_NotEq(
) -> cmp_rator:
    return NotEq(
    )

def update_NotEq(source_NotEq : NotEq
) -> NotEq:
    return NotEq(
    )

        

@dataclass(frozen=True, eq=True)
class Lt(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Lt(self)

def make_Lt(
) -> cmp_rator:
    return Lt(
    )

def update_Lt(source_Lt : Lt
) -> Lt:
    return Lt(
    )

        

@dataclass(frozen=True, eq=True)
class LtE(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_LtE(self)

def make_LtE(
) -> cmp_rator:
    return LtE(
    )

def update_LtE(source_LtE : LtE
) -> LtE:
    return LtE(
    )

        

@dataclass(frozen=True, eq=True)
class Gt(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Gt(self)

def make_Gt(
) -> cmp_rator:
    return Gt(
    )

def update_Gt(source_Gt : Gt
) -> Gt:
    return Gt(
    )

        

@dataclass(frozen=True, eq=True)
class GtE(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_GtE(self)

def make_GtE(
) -> cmp_rator:
    return GtE(
    )

def update_GtE(source_GtE : GtE
) -> GtE:
    return GtE(
    )

        

@dataclass(frozen=True, eq=True)
class Is(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Is(self)

def make_Is(
) -> cmp_rator:
    return Is(
    )

def update_Is(source_Is : Is
) -> Is:
    return Is(
    )

        

@dataclass(frozen=True, eq=True)
class IsNot(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_IsNot(self)

def make_IsNot(
) -> cmp_rator:
    return IsNot(
    )

def update_IsNot(source_IsNot : IsNot
) -> IsNot:
    return IsNot(
    )

        

@dataclass(frozen=True, eq=True)
class In(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_In(self)

def make_In(
) -> cmp_rator:
    return In(
    )

def update_In(source_In : In
) -> In:
    return In(
    )

        

@dataclass(frozen=True, eq=True)
class NotIn(cmp_rator):


    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_NotIn(self)

def make_NotIn(
) -> cmp_rator:
    return NotIn(
    )

def update_NotIn(source_NotIn : NotIn
) -> NotIn:
    return NotIn(
    )

        

# case handlers for type cmp_rator
@dataclass(frozen=True, eq=True)
class CmpRatorHandlers(Generic[T]):
    case_Eq : Callable[[Eq], T]
    case_NotEq : Callable[[NotEq], T]
    case_Lt : Callable[[Lt], T]
    case_LtE : Callable[[LtE], T]
    case_Gt : Callable[[Gt], T]
    case_GtE : Callable[[GtE], T]
    case_Is : Callable[[Is], T]
    case_IsNot : Callable[[IsNot], T]
    case_In : Callable[[In], T]
    case_NotIn : Callable[[NotIn], T]


# matching for type cmp_rator
def match_cmp_rator(o : cmp_rator, handlers : CmpRatorHandlers[T]) -> T :
    return o.match(handlers)
    

# type constraint
@dataclass(frozen=True, eq=True)
class constraint(ABC):
    # @abstractmethod
    def match(self, handlers : ConstraintHandlers[T]) -> T:
        raise Exception()


# constructors for type constraint

@dataclass(frozen=True, eq=True)
class AsyncConstraint(constraint):
    target : expr | None
    search_space : expr | None
    filts : constraint_filters | None

    def match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_AsyncConstraint(self)

def make_AsyncConstraint(
    target : expr | None, 
    search_space : expr | None, 
    filts : constraint_filters | None
) -> constraint:
    return AsyncConstraint(
        target,
        search_space,
        filts
    )

def update_AsyncConstraint(source_AsyncConstraint : AsyncConstraint,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    search_space : Union[expr | None, SourceFlag] = SourceFlag(),
    filts : Union[constraint_filters | None, SourceFlag] = SourceFlag()
) -> AsyncConstraint:
    return AsyncConstraint(
        source_AsyncConstraint.target if isinstance(target, SourceFlag) else target,
        source_AsyncConstraint.search_space if isinstance(search_space, SourceFlag) else search_space,
        source_AsyncConstraint.filts if isinstance(filts, SourceFlag) else filts
    )

        

@dataclass(frozen=True, eq=True)
class Constraint(constraint):
    target : expr | None
    search_space : expr | None
    filts : constraint_filters | None

    def match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_Constraint(self)

def make_Constraint(
    target : expr | None, 
    search_space : expr | None, 
    filts : constraint_filters | None
) -> constraint:
    return Constraint(
        target,
        search_space,
        filts
    )

def update_Constraint(source_Constraint : Constraint,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    search_space : Union[expr | None, SourceFlag] = SourceFlag(),
    filts : Union[constraint_filters | None, SourceFlag] = SourceFlag()
) -> Constraint:
    return Constraint(
        source_Constraint.target if isinstance(target, SourceFlag) else target,
        source_Constraint.search_space if isinstance(search_space, SourceFlag) else search_space,
        source_Constraint.filts if isinstance(filts, SourceFlag) else filts
    )

        

# case handlers for type constraint
@dataclass(frozen=True, eq=True)
class ConstraintHandlers(Generic[T]):
    case_AsyncConstraint : Callable[[AsyncConstraint], T]
    case_Constraint : Callable[[Constraint], T]


# matching for type constraint
def match_constraint(o : constraint, handlers : ConstraintHandlers[T]) -> T :
    return o.match(handlers)
     


# type and constructor CompareRight
@dataclass(frozen=True, eq=True)
class CompareRight:
    rator : cmp_rator | None
    rand : expr | None


def make_CompareRight(
    rator : cmp_rator | None,
    rand : expr | None
) -> CompareRight:
    return CompareRight(
        rator,
        rand)

def update_CompareRight(source_CompareRight : CompareRight,
    rator : Union[cmp_rator | None, SourceFlag] = SourceFlag(),
    rand : Union[expr | None, SourceFlag] = SourceFlag()
) -> CompareRight:
    return CompareRight(
        source_CompareRight.rator if isinstance(rator, SourceFlag) else rator, 
        source_CompareRight.rand if isinstance(rand, SourceFlag) else rand)

    

# type and constructor ExceptHandler
@dataclass(frozen=True, eq=True)
class ExceptHandler:
    arg : except_arg | None
    body : statements | None


def make_ExceptHandler(
    arg : except_arg | None,
    body : statements | None
) -> ExceptHandler:
    return ExceptHandler(
        arg,
        body)

def update_ExceptHandler(source_ExceptHandler : ExceptHandler,
    arg : Union[except_arg | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> ExceptHandler:
    return ExceptHandler(
        source_ExceptHandler.arg if isinstance(arg, SourceFlag) else arg, 
        source_ExceptHandler.body if isinstance(body, SourceFlag) else body)

    

# type and constructor Param
@dataclass(frozen=True, eq=True)
class Param:
    name : str
    anno : param_annotation | None
    default : param_default | None


def make_Param(
    name : str,
    anno : param_annotation | None,
    default : param_default | None
) -> Param:
    return Param(
        name,
        anno,
        default)

def update_Param(source_Param : Param,
    name : Union[str, SourceFlag] = SourceFlag(),
    anno : Union[param_annotation | None, SourceFlag] = SourceFlag(),
    default : Union[param_default | None, SourceFlag] = SourceFlag()
) -> Param:
    return Param(
        source_Param.name if isinstance(name, SourceFlag) else name, 
        source_Param.anno if isinstance(anno, SourceFlag) else anno, 
        source_Param.default if isinstance(default, SourceFlag) else default)

    

# type and constructor ClassDef
@dataclass(frozen=True, eq=True)
class ClassDef:
    name : str
    bs : bases | None
    body : statements | None


def make_ClassDef(
    name : str,
    bs : bases | None,
    body : statements | None
) -> ClassDef:
    return ClassDef(
        name,
        bs,
        body)

def update_ClassDef(source_ClassDef : ClassDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    bs : Union[bases | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> ClassDef:
    return ClassDef(
        source_ClassDef.name if isinstance(name, SourceFlag) else name, 
        source_ClassDef.bs if isinstance(bs, SourceFlag) else bs, 
        source_ClassDef.body if isinstance(body, SourceFlag) else body)

    

# type and constructor ElifBlock
@dataclass(frozen=True, eq=True)
class ElifBlock:
    test : expr | None
    body : statements | None


def make_ElifBlock(
    test : expr | None,
    body : statements | None
) -> ElifBlock:
    return ElifBlock(
        test,
        body)

def update_ElifBlock(source_ElifBlock : ElifBlock,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> ElifBlock:
    return ElifBlock(
        source_ElifBlock.test if isinstance(test, SourceFlag) else test, 
        source_ElifBlock.body if isinstance(body, SourceFlag) else body)

    

# type and constructor ElseBlock
@dataclass(frozen=True, eq=True)
class ElseBlock:
    body : statements | None


def make_ElseBlock(
    body : statements | None
) -> ElseBlock:
    return ElseBlock(
        body)

def update_ElseBlock(source_ElseBlock : ElseBlock,
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> ElseBlock:
    return ElseBlock(
        source_ElseBlock.body if isinstance(body, SourceFlag) else body)

    

# type and constructor FinallyBlock
@dataclass(frozen=True, eq=True)
class FinallyBlock:
    body : statements | None


def make_FinallyBlock(
    body : statements | None
) -> FinallyBlock:
    return FinallyBlock(
        body)

def update_FinallyBlock(source_FinallyBlock : FinallyBlock,
    body : Union[statements | None, SourceFlag] = SourceFlag()
) -> FinallyBlock:
    return FinallyBlock(
        source_FinallyBlock.body if isinstance(body, SourceFlag) else body)

     
    

ast = Union[
    CompareRight,
    ExceptHandler,
    Param,
    ClassDef,
    ElifBlock,
    ElseBlock,
    FinallyBlock,
    SomeReturnAnno,
    NoReturnAnno,
    SomeExceptArg,
    SomeExceptArgName,
    NoExceptArg,
    SomeParamAnno,
    NoParamAnno,
    SomeParamDefault,
    NoParamDefault,
    ConsKwParam,
    SingleKwParam,
    DictionarySplatParam,
    SingleListSplatParam,
    TransListSplatParam,
    ParamsD,
    ConsPosKeyParam,
    SinglePosKeyParam,
    ParamsC,
    ConsPosParam,
    SinglePosParam,
    TransPosParam,
    ParamsA,
    ParamsB,
    NoParam,
    NamedKeyword,
    SplatKeyword,
    ImportNameAlias,
    ImportNameOnly,
    WithItemAlias,
    WithItemOnly,
    SomeBases,
    NoBases,
    ConsBase,
    SingleBase,
    KeywordBases,
    ConsKeyword,
    SingleKeyword,
    ConsCompareRight,
    SingleCompareRight,
    SomeExpr,
    NoExpr,
    ConsExpr,
    SingleExpr,
    ConsTargetExpr,
    SingleTargetExpr,
    ConsDec,
    NoDec,
    ConsFilter,
    SingleFilter,
    NoFilter,
    ConsStr,
    SingleStr,
    ConsArg,
    SingleArg,
    KeywordsArg,
    Field,
    DictionarySplatFields,
    ConsDictionaryItem,
    SingleDictionaryItem,
    ConsId,
    SingleId,
    ConsImportName,
    SingleImportName,
    ConsWithItem,
    SingleWithItem,
    FutureMod,
    SimpleMod,
    ConsStmt,
    SingleStmt,
    ConsConstraint,
    SingleConstraint,
    ConsExceptHandler,
    SingleExceptHandler,
    ElifCond,
    ElseCond,
    NoCond,
    FunctionDef,
    AsyncFunctionDef,
    DecFunctionDef,
    DecClassDef,
    ReturnSomething,
    Return,
    Delete,
    Assign,
    AugAssign,
    AnnoAssign,
    AnnoDeclar,
    For,
    ForElse,
    AsyncFor,
    AsyncForElse,
    While,
    WhileElse,
    If,
    With,
    AsyncWith,
    Raise,
    RaiseExc,
    RaiseFrom,
    Try,
    TryElse,
    TryExceptFin,
    TryFin,
    TryElseFin,
    Assert,
    AssertMsg,
    Import,
    ImportFrom,
    ImportWildCard,
    Global,
    Nonlocal,
    Expr,
    Pass,
    Break,
    Continue,
    BoolOp,
    AssignExpr,
    BinOp,
    UnaryOp,
    Lambda,
    IfExp,
    Dictionary,
    EmptyDictionary,
    Set,
    ListComp,
    SetComp,
    DictionaryComp,
    GeneratorExp,
    Await,
    YieldNothing,
    Yield,
    YieldFrom,
    Compare,
    Call,
    CallArgs,
    Integer,
    Float,
    ConcatString,
    True_,
    False_,
    None_,
    Ellip,
    Attribute,
    Subscript,
    Starred,
    Name,
    List,
    EmptyList,
    Tuple,
    EmptyTuple,
    Slice,
    And,
    Or,
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
    Invert,
    Not,
    UAdd,
    USub,
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
    AsyncConstraint,
    Constraint,
    return_annotation,
    except_arg,
    param_annotation,
    param_default,
    parameters_d,
    parameters_c,
    parameters_b,
    parameters_a,
    parameters,
    keyword,
    import_name,
    with_item,
    bases,
    bases_a,
    keywords,
    comparisons,
    option_expr,
    comma_exprs,
    target_exprs,
    decorators,
    constraint_filters,
    sequence_string,
    arguments,
    dictionary_item,
    dictionary_content,
    sequence_name,
    sequence_import_name,
    sequence_with_item,
    module,
    statements,
    comprehension_constraints,
    sequence_ExceptHandler,
    conditions,
    function_def,
    stmt,
    expr,
    bool_rator,
    bin_rator,
    unary_rator,
    cmp_rator,
    constraint,
    str
] 
    