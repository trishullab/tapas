# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass





# type abstract_token
@dataclass(frozen=True, eq=True)
class abstract_token(ABC):
    # @abstractmethod
    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        raise Exception()


# constructors for type abstract_token

@dataclass(frozen=True, eq=True)
class Grammar(abstract_token):
    options : str
    selection : str

    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Grammar(self)

def make_Grammar(
    options : str, 
    selection : str
) -> abstract_token:
    return Grammar(
        options,
        selection
    )

def update_Grammar(source_Grammar : Grammar,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag()
) -> Grammar:
    return Grammar(
        source_Grammar.options if isinstance(options, SourceFlag) else options,
        source_Grammar.selection if isinstance(selection, SourceFlag) else selection
    )

        

@dataclass(frozen=True, eq=True)
class Vocab(abstract_token):
    options : str
    selection : str

    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Vocab(self)

def make_Vocab(
    options : str, 
    selection : str
) -> abstract_token:
    return Vocab(
        options,
        selection
    )

def update_Vocab(source_Vocab : Vocab,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag()
) -> Vocab:
    return Vocab(
        source_Vocab.options if isinstance(options, SourceFlag) else options,
        source_Vocab.selection if isinstance(selection, SourceFlag) else selection
    )

        

# case handlers for type abstract_token
@dataclass(frozen=True, eq=True)
class AbstractTokenHandlers(Generic[T]):
    case_Grammar : Callable[[Grammar], T]
    case_Vocab : Callable[[Vocab], T]


# matching for type abstract_token
def match_abstract_token(o : abstract_token, handlers : AbstractTokenHandlers[T]) -> T :
    return o.match(handlers)
     

 
    