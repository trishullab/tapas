# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST


from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')



# type abstract_token
@dataclass(frozen=True, eq=True)
class abstract_token(ABC):
    @abstractmethod
    def _match(self, handlers : AbstractTokenHandlers[T]) -> T: pass


# constructors for type abstract_token

@dataclass(frozen=True, eq=True)
class Grammar(abstract_token):
    options : str
    selection : str

    def _match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Grammar(self)

def make_Grammar(options : str, selection : str) -> abstract_token:
    return Grammar(options, selection)
        

@dataclass(frozen=True, eq=True)
class Vocab(abstract_token):
    options : str
    selection : str

    def _match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Vocab(self)

def make_Vocab(options : str, selection : str) -> abstract_token:
    return Vocab(options, selection)
        

# case handlers for type abstract_token
@dataclass(frozen=True, eq=True)
class AbstractTokenHandlers(Generic[T]):
    case_Grammar : Callable[[Grammar], T]
    case_Vocab : Callable[[Vocab], T]


# matching for type abstract_token
def match_abstract_token(o : abstract_token, handlers : AbstractTokenHandlers[T]) -> T :
    return o._match(handlers)
     

 
    