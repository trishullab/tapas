# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST


from __future__ import annotations
from lib import abstract_token_system as ats
from lib.abstract_token_system import abstract_token, Vocab, Grammar
from lib.line_format_construct_autogen import InLine, NewLine, IndentLine
    


from lib.python_ast_system import *
    

# definitions operate on reversed lists of abstract tokens, starting from the right, going left. 

def to_return_annotation(xs : tuple[abstract_token, ...]) -> tuple[return_annotation, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "return_annotation"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeReturnAnno": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeReturnAnno(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoReturnAnno": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoReturnAnno(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], return_annotation)
    return stack_result
    

def to_except_arg(xs : tuple[abstract_token, ...]) -> tuple[except_arg, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "except_arg"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeExceptArg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeExceptArg(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SomeExceptArgName": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeExceptArgName(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoExceptArg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoExceptArg(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], except_arg)
    return stack_result
    

def to_param_annotation(xs : tuple[abstract_token, ...]) -> tuple[param_annotation, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "param_annotation"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeParamAnno": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeParamAnno(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoParamAnno": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoParamAnno(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], param_annotation)
    return stack_result
    

def to_param_default(xs : tuple[abstract_token, ...]) -> tuple[param_default, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "param_default"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeParamDefault": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeParamDefault(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoParamDefault": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoParamDefault(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], param_default)
    return stack_result
    

def to_parameters_d(xs : tuple[abstract_token, ...]) -> tuple[parameters_d, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "parameters_d"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsKwParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsKwParam(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleKwParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleKwParam(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "DictionarySplatParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    DictionarySplatParam(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], parameters_d)
    return stack_result
    

def to_parameters_c(xs : tuple[abstract_token, ...]) -> tuple[parameters_c, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "parameters_c"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SingleListSplatParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleListSplatParam(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TransListSplatParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TransListSplatParam(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_d(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ParamsD": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ParamsD(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_d(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], parameters_c)
    return stack_result
    

def to_parameters_b(xs : tuple[abstract_token, ...]) -> tuple[parameters_b, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "parameters_b"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsPosKeyParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsPosKeyParam(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SinglePosKeyParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SinglePosKeyParam(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ParamsC": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ParamsC(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_c(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], parameters_b)
    return stack_result
    

def to_parameters_a(xs : tuple[abstract_token, ...]) -> tuple[parameters_a, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "parameters_a"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsPosParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsPosParam(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SinglePosParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SinglePosParam(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TransPosParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TransPosParam(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_Param(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_b(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], parameters_a)
    return stack_result
    

def to_parameters(xs : tuple[abstract_token, ...]) -> tuple[parameters, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "parameters"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ParamsA": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ParamsA(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_a(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ParamsB": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ParamsB(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters_b(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoParam": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoParam(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], parameters)
    return stack_result
    

def to_keyword(xs : tuple[abstract_token, ...]) -> tuple[keyword, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "keyword"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "NamedKeyword": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NamedKeyword(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SplatKeyword": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SplatKeyword(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], keyword)
    return stack_result
    

def to_import_name(xs : tuple[abstract_token, ...]) -> tuple[import_name, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "import_name"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ImportNameAlias": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ImportNameAlias(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ImportNameOnly": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ImportNameOnly(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], import_name)
    return stack_result
    

def to_with_item(xs : tuple[abstract_token, ...]) -> tuple[with_item, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "with_item"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "WithItemAlias": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    WithItemAlias(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "WithItemOnly": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    WithItemOnly(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], with_item)
    return stack_result
    

def to_bases(xs : tuple[abstract_token, ...]) -> tuple[bases, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "bases"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeBases": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeBases(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_bases_a(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoBases": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoBases(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], bases)
    return stack_result
    

def to_bases_a(xs : tuple[abstract_token, ...]) -> tuple[bases_a, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "bases_a"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsBase": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsBase(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleBase": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleBase(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "KeywordBases": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    KeywordBases(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_keywords(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], bases_a)
    return stack_result
    

def to_keywords(xs : tuple[abstract_token, ...]) -> tuple[keywords, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "keywords"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsKeyword": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsKeyword(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_keyword(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleKeyword": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleKeyword(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_keyword(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], keywords)
    return stack_result
    

def to_comparisons(xs : tuple[abstract_token, ...]) -> tuple[comparisons, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "comparisons"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsCompareRight": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsCompareRight(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_CompareRight(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleCompareRight": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleCompareRight(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_CompareRight(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], comparisons)
    return stack_result
    

def to_option_expr(xs : tuple[abstract_token, ...]) -> tuple[option_expr, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "option_expr"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "SomeExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SomeExpr(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoExpr(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], option_expr)
    return stack_result
    

def to_comma_exprs(xs : tuple[abstract_token, ...]) -> tuple[comma_exprs, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "comma_exprs"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsExpr(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleExpr(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], comma_exprs)
    return stack_result
    

def to_target_exprs(xs : tuple[abstract_token, ...]) -> tuple[target_exprs, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "target_exprs"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsTargetExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsTargetExpr(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleTargetExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleTargetExpr(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], target_exprs)
    return stack_result
    

def to_decorators(xs : tuple[abstract_token, ...]) -> tuple[decorators, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "decorators"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsDec": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsDec(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoDec": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoDec(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], decorators)
    return stack_result
    

def to_constraint_filters(xs : tuple[abstract_token, ...]) -> tuple[constraint_filters, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "constraint_filters"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsFilter": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsFilter(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleFilter": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleFilter(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoFilter": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoFilter(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], constraint_filters)
    return stack_result
    

def to_sequence_string(xs : tuple[abstract_token, ...]) -> tuple[sequence_string, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "sequence_string"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsStr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsStr(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleStr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleStr(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], sequence_string)
    return stack_result
    

def to_arguments(xs : tuple[abstract_token, ...]) -> tuple[arguments, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "arguments"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsArg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsArg(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleArg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleArg(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "KeywordsArg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    KeywordsArg(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_keywords(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], arguments)
    return stack_result
    

def to_dictionary_item(xs : tuple[abstract_token, ...]) -> tuple[dictionary_item, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "dictionary_item"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "Field": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Field(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "DictionarySplatFields": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    DictionarySplatFields(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], dictionary_item)
    return stack_result
    

def to_dictionary_content(xs : tuple[abstract_token, ...]) -> tuple[dictionary_content, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "dictionary_content"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsDictionaryItem": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsDictionaryItem(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_dictionary_item(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleDictionaryItem": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleDictionaryItem(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_dictionary_item(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], dictionary_content)
    return stack_result
    

def to_sequence_name(xs : tuple[abstract_token, ...]) -> tuple[sequence_name, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "sequence_name"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsId": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsId(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleId": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleId(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], sequence_name)
    return stack_result
    

def to_sequence_import_name(xs : tuple[abstract_token, ...]) -> tuple[sequence_import_name, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "sequence_import_name"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsImportName": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsImportName(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_import_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleImportName": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleImportName(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_import_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], sequence_import_name)
    return stack_result
    

def to_sequence_with_item(xs : tuple[abstract_token, ...]) -> tuple[sequence_with_item, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "sequence_with_item"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsWithItem": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsWithItem(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_with_item(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleWithItem": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleWithItem(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_with_item(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], sequence_with_item)
    return stack_result
    

def to_module(xs : tuple[abstract_token, ...]) -> tuple[module, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "module"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "FutureMod": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    FutureMod(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_import_name(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SimpleMod": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SimpleMod(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], module)
    return stack_result
    

def to_statements(xs : tuple[abstract_token, ...]) -> tuple[statements, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "statements"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsStmt": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsStmt(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_stmt(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleStmt": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleStmt(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_stmt(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], statements)
    return stack_result
    

def to_comprehension_constraints(xs : tuple[abstract_token, ...]) -> tuple[comprehension_constraints, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "comprehension_constraints"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsConstraint": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsConstraint(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_constraint(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleConstraint": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleConstraint(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_constraint(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], comprehension_constraints)
    return stack_result
    

def to_sequence_ExceptHandler(xs : tuple[abstract_token, ...]) -> tuple[sequence_ExceptHandler, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "sequence_ExceptHandler"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ConsExceptHandler": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConsExceptHandler(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SingleExceptHandler": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SingleExceptHandler(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], sequence_ExceptHandler)
    return stack_result
    

def to_conditions(xs : tuple[abstract_token, ...]) -> tuple[conditions, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "conditions"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "ElifCond": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ElifCond(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_ElifBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ElseCond": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ElseCond(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NoCond": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NoCond(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], conditions)
    return stack_result
    

def to_function_def(xs : tuple[abstract_token, ...]) -> tuple[function_def, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "function_def"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "FunctionDef": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 4

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    FunctionDef(children[0], children[1], children[2], children[3]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_return_annotation(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 3: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AsyncFunctionDef": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 4

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AsyncFunctionDef(children[0], children[1], children[2], children[3]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_return_annotation(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 3: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], function_def)
    return stack_result
    

def to_stmt(xs : tuple[abstract_token, ...]) -> tuple[stmt, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "stmt"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "DecFunctionDef": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    DecFunctionDef(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_decorators(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_function_def(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "DecClassDef": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    DecClassDef(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_decorators(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_ClassDef(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ReturnSomething": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ReturnSomething(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Return": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Return(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Delete": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Delete(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_comma_exprs(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Assign": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Assign(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_target_exprs(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AugAssign": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AugAssign(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_bin_rator(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AnnoAssign": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AnnoAssign(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AnnoDeclar": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AnnoDeclar(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "For": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    For(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ForElse": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 4

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ForElse(children[0], children[1], children[2], children[3]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 3: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AsyncFor": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AsyncFor(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AsyncForElse": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 4

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AsyncForElse(children[0], children[1], children[2], children[3]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 3: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "While": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    While(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "WhileElse": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    WhileElse(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "If": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    If(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_conditions(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "With": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    With(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_with_item(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AsyncWith": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AsyncWith(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_with_item(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Raise": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Raise(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "RaiseExc": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    RaiseExc(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "RaiseFrom": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    RaiseFrom(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Try": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Try(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TryElse": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TryElse(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TryExceptFin": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TryExceptFin(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_FinallyBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TryFin": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TryFin(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_FinallyBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "TryElseFin": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 4

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    TryElseFin(children[0], children[1], children[2], children[3]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_statements(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_ExceptHandler(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_ElseBlock(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 3: # index does *not* refer to an inductive child
                (child, remainder) = to_FinallyBlock(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Assert": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Assert(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AssertMsg": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AssertMsg(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Import": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Import(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_import_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ImportFrom": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ImportFrom(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_import_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ImportWildCard": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ImportWildCard(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Global": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Global(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Nonlocal": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Nonlocal(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_name(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Expr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Expr(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Pass": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Pass(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Break": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Break(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Continue": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Continue(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], stmt)
    return stack_result
    

def to_expr(xs : tuple[abstract_token, ...]) -> tuple[expr, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "expr"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "BoolOp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    BoolOp(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_bool_rator(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "AssignExpr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AssignExpr(children[0], children[1]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "BinOp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    BinOp(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_bin_rator(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "UnaryOp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    UnaryOp(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_unary_rator(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Lambda": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Lambda(children[0], children[1]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_parameters(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "IfExp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    IfExp(children[0], children[1], children[2]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Dictionary": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Dictionary(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_dictionary_content(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "EmptyDictionary": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    EmptyDictionary(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Set": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Set(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_comma_exprs(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ListComp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ListComp(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_comprehension_constraints(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "SetComp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    SetComp(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_comprehension_constraints(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "DictionaryComp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    DictionaryComp(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_comprehension_constraints(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "GeneratorExp": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    GeneratorExp(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_comprehension_constraints(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Await": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Await(children[0]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "YieldNothing": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    YieldNothing(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Yield": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Yield(children[0]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "YieldFrom": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    YieldFrom(children[0]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Compare": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Compare(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_comparisons(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Call": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Call(children[0]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "CallArgs": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    CallArgs(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_arguments(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Integer": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Integer(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Float": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Float(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "ConcatString": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    ConcatString(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_sequence_string(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "True_": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    True_(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "False_": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    False_(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "None_": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    None_(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Ellip": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Ellip(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Attribute": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Attribute(children[0], children[1]),
                    remainder
                )
            
            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Subscript": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 2

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Subscript(children[0], children[1]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Starred": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Starred(children[0]),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Name": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Name(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_str(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "List": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    List(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_comma_exprs(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "EmptyList": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    EmptyList(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Tuple": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 1

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Tuple(children[0]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_comma_exprs(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "EmptyTuple": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    EmptyTuple(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Slice": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Slice(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_option_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_option_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_option_expr(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], expr)
    return stack_result
    

def to_bool_rator(xs : tuple[abstract_token, ...]) -> tuple[bool_rator, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "bool_rator"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "And": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    And(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Or": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Or(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], bool_rator)
    return stack_result
    

def to_bin_rator(xs : tuple[abstract_token, ...]) -> tuple[bin_rator, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "bin_rator"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "Add": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Add(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Sub": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Sub(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Mult": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Mult(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "MatMult": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    MatMult(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Div": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Div(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Mod": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Mod(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Pow": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Pow(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "LShift": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    LShift(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "RShift": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    RShift(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "BitOr": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    BitOr(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "BitXor": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    BitXor(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "BitAnd": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    BitAnd(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "FloorDiv": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    FloorDiv(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], bin_rator)
    return stack_result
    

def to_unary_rator(xs : tuple[abstract_token, ...]) -> tuple[unary_rator, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "unary_rator"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "Invert": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Invert(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Not": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Not(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "UAdd": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    UAdd(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "USub": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    USub(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], unary_rator)
    return stack_result
    

def to_cmp_rator(xs : tuple[abstract_token, ...]) -> tuple[cmp_rator, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "cmp_rator"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "Eq": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Eq(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NotEq": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NotEq(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Lt": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Lt(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "LtE": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    LtE(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Gt": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Gt(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "GtE": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    GtE(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Is": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Is(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "IsNot": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    IsNot(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "In": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    In(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "NotIn": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 0

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    NotIn(),
                    remainder
                )
            
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], cmp_rator)
    return stack_result
    

def to_constraint(xs : tuple[abstract_token, ...]) -> tuple[constraint, tuple[abstract_token, ...]]:

    initial = (xs[-1], [], xs[:-1])
    stack : list[tuple[abstract_token, list[Any], tuple[abstract_token, ...]]] = [initial]

    stack_result = None 
    while stack:
        (x, children, remainder) = stack.pop()
        assert isinstance(x, Grammar)
        assert x.options == "constraint"
        rule_name = x.selection

        if False:
            pass
        
        elif rule_name == "AsyncConstraint": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    AsyncConstraint(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_constraint_filters(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

        elif rule_name == "Constraint": 
            children = children
            remainder = remainder
            if stack_result:
                # get the result from the child in the stack
                (child, remainder) = stack_result
                children = children + [child]
                stack_result = None

            total_num_children = 3

            index = len(children)
            if index == total_num_children:
                # the processing of the current rule has completed
                # return the result to the parent in the stack 
                stack_result = (
                    Constraint(children[0], children[1], children[2]),
                    remainder
                )
            
            elif index == 0: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 1: # index does *not* refer to an inductive child
                (child, remainder) = to_expr(remainder)
                stack.append((x, children + [child], remainder))
                

            elif index == 2: # index does *not* refer to an inductive child
                (child, remainder) = to_constraint_filters(remainder)
                stack.append((x, children + [child], remainder))
                
            else: # index refers to an inductive child
                stack.append((x, children, remainder))
                stack.append((remainder[-1], [], remainder[:-1]))
        

    assert stack_result
    assert isinstance(stack_result[0], constraint)
    return stack_result
     


def to_CompareRight(xs : tuple[abstract_token, ...]) -> tuple[CompareRight, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "CompareRight"
    assert x.selection == "CompareRight"

    (rator, xs) = to_cmp_rator(xs)
    (rand, xs) = to_expr(xs)
    return (CompareRight(rator, rand), xs)
    

def to_ExceptHandler(xs : tuple[abstract_token, ...]) -> tuple[ExceptHandler, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "ExceptHandler"
    assert x.selection == "ExceptHandler"

    (arg, xs) = to_except_arg(xs)
    (body, xs) = to_statements(xs)
    return (ExceptHandler(arg, body), xs)
    

def to_Param(xs : tuple[abstract_token, ...]) -> tuple[Param, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "Param"
    assert x.selection == "Param"

    (name, xs) = to_str(xs)
    (anno, xs) = to_param_annotation(xs)
    (default, xs) = to_param_default(xs)
    return (Param(name, anno, default), xs)
    

def to_ClassDef(xs : tuple[abstract_token, ...]) -> tuple[ClassDef, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "ClassDef"
    assert x.selection == "ClassDef"

    (name, xs) = to_str(xs)
    (bs, xs) = to_bases(xs)
    (body, xs) = to_statements(xs)
    return (ClassDef(name, bs, body), xs)
    

def to_ElifBlock(xs : tuple[abstract_token, ...]) -> tuple[ElifBlock, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "ElifBlock"
    assert x.selection == "ElifBlock"

    (test, xs) = to_expr(xs)
    (body, xs) = to_statements(xs)
    return (ElifBlock(test, body), xs)
    

def to_ElseBlock(xs : tuple[abstract_token, ...]) -> tuple[ElseBlock, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "ElseBlock"
    assert x.selection == "ElseBlock"

    (body, xs) = to_statements(xs)
    return (ElseBlock(body), xs)
    

def to_FinallyBlock(xs : tuple[abstract_token, ...]) -> tuple[FinallyBlock, tuple[abstract_token, ...]]:
    x = xs[-1]
    xs = xs[:-1]
    assert isinstance(x, Grammar)
    assert x.options == "FinallyBlock"
    assert x.selection == "FinallyBlock"

    (body, xs) = to_statements(xs)
    return (FinallyBlock(body), xs)
     


def to_str(xs : tuple[abstract_token, ...]) -> tuple[str, tuple[abstract_token, ...]]:
    hd = xs[-1]
    tl = xs[:-1]
    assert isinstance(hd, Vocab)
    return (hd.selection, tl)
    