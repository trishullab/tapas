# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass



from pyrsistent.typing import PMap, PSet
from pyrsistent import pmap, m, pset, s
from base.abstract_token_construct_autogen import abstract_token 
from lib.python_ast_construct_autogen import ast 
    


# type variant
@dataclass(frozen=True, eq=True)
class variant(ABC):
    # @abstractmethod
    def match(self, handlers : VariantHandlers[T]) -> T:
        raise Exception()


# constructors for type variant

@dataclass(frozen=True, eq=True)
class CoVariant(variant):


    def match(self, handlers : VariantHandlers[T]) -> T:
        return handlers.case_CoVariant(self)

def make_CoVariant(
) -> variant:
    return CoVariant(
    )

def update_CoVariant(source_CoVariant : CoVariant
) -> CoVariant:
    return CoVariant(
    )

        

@dataclass(frozen=True, eq=True)
class ContraVariant(variant):


    def match(self, handlers : VariantHandlers[T]) -> T:
        return handlers.case_ContraVariant(self)

def make_ContraVariant(
) -> variant:
    return ContraVariant(
    )

def update_ContraVariant(source_ContraVariant : ContraVariant
) -> ContraVariant:
    return ContraVariant(
    )

        

@dataclass(frozen=True, eq=True)
class NoVariant(variant):


    def match(self, handlers : VariantHandlers[T]) -> T:
        return handlers.case_NoVariant(self)

def make_NoVariant(
) -> variant:
    return NoVariant(
    )

def update_NoVariant(source_NoVariant : NoVariant
) -> NoVariant:
    return NoVariant(
    )

        

# case handlers for type variant
@dataclass(frozen=True, eq=True)
class VariantHandlers(Generic[T]):
    case_CoVariant : Callable[[CoVariant], T]
    case_ContraVariant : Callable[[ContraVariant], T]
    case_NoVariant : Callable[[NoVariant], T]


# matching for type variant
def match_variant(o : variant, handlers : VariantHandlers[T]) -> T :
    return o.match(handlers)
    

# type type
@dataclass(frozen=True, eq=True)
class type(ABC):
    # @abstractmethod
    def match(self, handlers : TypeHandlers[T]) -> T:
        raise Exception()


# constructors for type type

@dataclass(frozen=True, eq=True)
class TypeType(type):
    class_key : str
    content : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_TypeType(self)

def make_TypeType(
    class_key : str, 
    content : type
) -> type:
    return TypeType(
        class_key,
        content
    )

def update_TypeType(source_TypeType : TypeType,
    class_key : Union[str, SourceFlag] = SourceFlag(),
    content : Union[type, SourceFlag] = SourceFlag()
) -> TypeType:
    return TypeType(
        source_TypeType.class_key if isinstance(class_key, SourceFlag) else class_key,
        source_TypeType.content if isinstance(content, SourceFlag) else content
    )

        

@dataclass(frozen=True, eq=True)
class VarType(type):
    name : str
    variant : variant

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_VarType(self)

def make_VarType(
    name : str, 
    variant : variant = NoVariant()
) -> type:
    return VarType(
        name,
        variant
    )

def update_VarType(source_VarType : VarType,
    name : Union[str, SourceFlag] = SourceFlag(),
    variant : Union[variant, SourceFlag] = SourceFlag()
) -> VarType:
    return VarType(
        source_VarType.name if isinstance(name, SourceFlag) else name,
        source_VarType.variant if isinstance(variant, SourceFlag) else variant
    )

        

@dataclass(frozen=True, eq=True)
class EllipType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_EllipType(self)

def make_EllipType(
) -> type:
    return EllipType(
    )

def update_EllipType(source_EllipType : EllipType
) -> EllipType:
    return EllipType(
    )

        

@dataclass(frozen=True, eq=True)
class AnyType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_AnyType(self)

def make_AnyType(
) -> type:
    return AnyType(
    )

def update_AnyType(source_AnyType : AnyType
) -> AnyType:
    return AnyType(
    )

        

@dataclass(frozen=True, eq=True)
class ObjectType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_ObjectType(self)

def make_ObjectType(
) -> type:
    return ObjectType(
    )

def update_ObjectType(source_ObjectType : ObjectType
) -> ObjectType:
    return ObjectType(
    )

        

@dataclass(frozen=True, eq=True)
class NoneType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_NoneType(self)

def make_NoneType(
) -> type:
    return NoneType(
    )

def update_NoneType(source_NoneType : NoneType
) -> NoneType:
    return NoneType(
    )

        

@dataclass(frozen=True, eq=True)
class ModuleType(type):
    key : str

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_ModuleType(self)

def make_ModuleType(
    key : str
) -> type:
    return ModuleType(
        key
    )

def update_ModuleType(source_ModuleType : ModuleType,
    key : Union[str, SourceFlag] = SourceFlag()
) -> ModuleType:
    return ModuleType(
        source_ModuleType.key if isinstance(key, SourceFlag) else key
    )

        

@dataclass(frozen=True, eq=True)
class FunctionType(type):
    pos_param_types : tuple[type, ...]
    pos_kw_param_sigs : tuple[ParamSig, ...]
    splat_pos_param_type : Optional[type]
    kw_param_sigs : tuple[ParamSig, ...]
    splat_kw_param_type : Optional[type]
    return_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_FunctionType(self)

def make_FunctionType(
    pos_param_types : tuple[type, ...] = (), 
    pos_kw_param_sigs : tuple[ParamSig, ...] = (), 
    splat_pos_param_type : Optional[type] = None, 
    kw_param_sigs : tuple[ParamSig, ...] = (), 
    splat_kw_param_type : Optional[type] = None, 
    return_type : type = AnyType()
) -> type:
    return FunctionType(
        pos_param_types,
        pos_kw_param_sigs,
        splat_pos_param_type,
        kw_param_sigs,
        splat_kw_param_type,
        return_type
    )

def update_FunctionType(source_FunctionType : FunctionType,
    pos_param_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    pos_kw_param_sigs : Union[tuple[ParamSig, ...], SourceFlag] = SourceFlag(),
    splat_pos_param_type : Union[Optional[type], SourceFlag] = SourceFlag(),
    kw_param_sigs : Union[tuple[ParamSig, ...], SourceFlag] = SourceFlag(),
    splat_kw_param_type : Union[Optional[type], SourceFlag] = SourceFlag(),
    return_type : Union[type, SourceFlag] = SourceFlag()
) -> FunctionType:
    return FunctionType(
        source_FunctionType.pos_param_types if isinstance(pos_param_types, SourceFlag) else pos_param_types,
        source_FunctionType.pos_kw_param_sigs if isinstance(pos_kw_param_sigs, SourceFlag) else pos_kw_param_sigs,
        source_FunctionType.splat_pos_param_type if isinstance(splat_pos_param_type, SourceFlag) else splat_pos_param_type,
        source_FunctionType.kw_param_sigs if isinstance(kw_param_sigs, SourceFlag) else kw_param_sigs,
        source_FunctionType.splat_kw_param_type if isinstance(splat_kw_param_type, SourceFlag) else splat_kw_param_type,
        source_FunctionType.return_type if isinstance(return_type, SourceFlag) else return_type
    )

        

@dataclass(frozen=True, eq=True)
class UnionType(type):
    type_choices : tuple[type, ...]

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_UnionType(self)

def make_UnionType(
    type_choices : tuple[type, ...]
) -> type:
    return UnionType(
        type_choices
    )

def update_UnionType(source_UnionType : UnionType,
    type_choices : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> UnionType:
    return UnionType(
        source_UnionType.type_choices if isinstance(type_choices, SourceFlag) else type_choices
    )

        

@dataclass(frozen=True, eq=True)
class InterType(type):
    type_components : tuple[type, ...]

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_InterType(self)

def make_InterType(
    type_components : tuple[type, ...]
) -> type:
    return InterType(
        type_components
    )

def update_InterType(source_InterType : InterType,
    type_components : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> InterType:
    return InterType(
        source_InterType.type_components if isinstance(type_components, SourceFlag) else type_components
    )

        

@dataclass(frozen=True, eq=True)
class RecordType(type):
    class_key : str
    class_uid : int
    type_args : tuple[type, ...]

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_RecordType(self)

def make_RecordType(
    class_key : str, 
    class_uid : int = 0, 
    type_args : tuple[type, ...] = ()
) -> type:
    return RecordType(
        class_key,
        class_uid,
        type_args
    )

def update_RecordType(source_RecordType : RecordType,
    class_key : Union[str, SourceFlag] = SourceFlag(),
    class_uid : Union[int, SourceFlag] = SourceFlag(),
    type_args : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> RecordType:
    return RecordType(
        source_RecordType.class_key if isinstance(class_key, SourceFlag) else class_key,
        source_RecordType.class_uid if isinstance(class_uid, SourceFlag) else class_uid,
        source_RecordType.type_args if isinstance(type_args, SourceFlag) else type_args
    )

        

@dataclass(frozen=True, eq=True)
class TupleLitType(type):
    item_types : tuple[type, ...]

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_TupleLitType(self)

def make_TupleLitType(
    item_types : tuple[type, ...] = ()
) -> type:
    return TupleLitType(
        item_types
    )

def update_TupleLitType(source_TupleLitType : TupleLitType,
    item_types : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> TupleLitType:
    return TupleLitType(
        source_TupleLitType.item_types if isinstance(item_types, SourceFlag) else item_types
    )

        

@dataclass(frozen=True, eq=True)
class VariedTupleType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_VariedTupleType(self)

def make_VariedTupleType(
    item_type : type = AnyType()
) -> type:
    return VariedTupleType(
        item_type
    )

def update_VariedTupleType(source_VariedTupleType : VariedTupleType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> VariedTupleType:
    return VariedTupleType(
        source_VariedTupleType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class MappingType(type):
    key_type : type
    value_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_MappingType(self)

def make_MappingType(
    key_type : type = AnyType(), 
    value_type : type = AnyType()
) -> type:
    return MappingType(
        key_type,
        value_type
    )

def update_MappingType(source_MappingType : MappingType,
    key_type : Union[type, SourceFlag] = SourceFlag(),
    value_type : Union[type, SourceFlag] = SourceFlag()
) -> MappingType:
    return MappingType(
        source_MappingType.key_type if isinstance(key_type, SourceFlag) else key_type,
        source_MappingType.value_type if isinstance(value_type, SourceFlag) else value_type
    )

        

@dataclass(frozen=True, eq=True)
class DictType(type):
    key_type : type
    value_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_DictType(self)

def make_DictType(
    key_type : type = AnyType(), 
    value_type : type = AnyType()
) -> type:
    return DictType(
        key_type,
        value_type
    )

def update_DictType(source_DictType : DictType,
    key_type : Union[type, SourceFlag] = SourceFlag(),
    value_type : Union[type, SourceFlag] = SourceFlag()
) -> DictType:
    return DictType(
        source_DictType.key_type if isinstance(key_type, SourceFlag) else key_type,
        source_DictType.value_type if isinstance(value_type, SourceFlag) else value_type
    )

        

@dataclass(frozen=True, eq=True)
class SetType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_SetType(self)

def make_SetType(
    item_type : type = AnyType()
) -> type:
    return SetType(
        item_type
    )

def update_SetType(source_SetType : SetType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> SetType:
    return SetType(
        source_SetType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class IterableType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_IterableType(self)

def make_IterableType(
    item_type : type = AnyType()
) -> type:
    return IterableType(
        item_type
    )

def update_IterableType(source_IterableType : IterableType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> IterableType:
    return IterableType(
        source_IterableType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class DictKeysType(type):
    key_type : type
    value_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_DictKeysType(self)

def make_DictKeysType(
    key_type : type = AnyType(), 
    value_type : type = AnyType()
) -> type:
    return DictKeysType(
        key_type,
        value_type
    )

def update_DictKeysType(source_DictKeysType : DictKeysType,
    key_type : Union[type, SourceFlag] = SourceFlag(),
    value_type : Union[type, SourceFlag] = SourceFlag()
) -> DictKeysType:
    return DictKeysType(
        source_DictKeysType.key_type if isinstance(key_type, SourceFlag) else key_type,
        source_DictKeysType.value_type if isinstance(value_type, SourceFlag) else value_type
    )

        

@dataclass(frozen=True, eq=True)
class DictValuesType(type):
    key_type : type
    value_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_DictValuesType(self)

def make_DictValuesType(
    key_type : type = AnyType(), 
    value_type : type = AnyType()
) -> type:
    return DictValuesType(
        key_type,
        value_type
    )

def update_DictValuesType(source_DictValuesType : DictValuesType,
    key_type : Union[type, SourceFlag] = SourceFlag(),
    value_type : Union[type, SourceFlag] = SourceFlag()
) -> DictValuesType:
    return DictValuesType(
        source_DictValuesType.key_type if isinstance(key_type, SourceFlag) else key_type,
        source_DictValuesType.value_type if isinstance(value_type, SourceFlag) else value_type
    )

        

@dataclass(frozen=True, eq=True)
class DictItemsType(type):
    key_type : type
    value_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_DictItemsType(self)

def make_DictItemsType(
    key_type : type = AnyType(), 
    value_type : type = AnyType()
) -> type:
    return DictItemsType(
        key_type,
        value_type
    )

def update_DictItemsType(source_DictItemsType : DictItemsType,
    key_type : Union[type, SourceFlag] = SourceFlag(),
    value_type : Union[type, SourceFlag] = SourceFlag()
) -> DictItemsType:
    return DictItemsType(
        source_DictItemsType.key_type if isinstance(key_type, SourceFlag) else key_type,
        source_DictItemsType.value_type if isinstance(value_type, SourceFlag) else value_type
    )

        

@dataclass(frozen=True, eq=True)
class SequenceType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_SequenceType(self)

def make_SequenceType(
    item_type : type = AnyType()
) -> type:
    return SequenceType(
        item_type
    )

def update_SequenceType(source_SequenceType : SequenceType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> SequenceType:
    return SequenceType(
        source_SequenceType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class RangeType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_RangeType(self)

def make_RangeType(
    item_type : type = AnyType()
) -> type:
    return RangeType(
        item_type
    )

def update_RangeType(source_RangeType : RangeType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> RangeType:
    return RangeType(
        source_RangeType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class ListType(type):
    item_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_ListType(self)

def make_ListType(
    item_type : type = AnyType()
) -> type:
    return ListType(
        item_type
    )

def update_ListType(source_ListType : ListType,
    item_type : Union[type, SourceFlag] = SourceFlag()
) -> ListType:
    return ListType(
        source_ListType.item_type if isinstance(item_type, SourceFlag) else item_type
    )

        

@dataclass(frozen=True, eq=True)
class ListLitType(type):
    item_types : tuple[type, ...]

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_ListLitType(self)

def make_ListLitType(
    item_types : tuple[type, ...] = ()
) -> type:
    return ListLitType(
        item_types
    )

def update_ListLitType(source_ListLitType : ListLitType,
    item_types : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> ListLitType:
    return ListLitType(
        source_ListLitType.item_types if isinstance(item_types, SourceFlag) else item_types
    )

        

@dataclass(frozen=True, eq=True)
class GeneratorType(type):
    yield_type : type
    return_type : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_GeneratorType(self)

def make_GeneratorType(
    yield_type : type = NoneType(), 
    return_type : type = NoneType()
) -> type:
    return GeneratorType(
        yield_type,
        return_type
    )

def update_GeneratorType(source_GeneratorType : GeneratorType,
    yield_type : Union[type, SourceFlag] = SourceFlag(),
    return_type : Union[type, SourceFlag] = SourceFlag()
) -> GeneratorType:
    return GeneratorType(
        source_GeneratorType.yield_type if isinstance(yield_type, SourceFlag) else yield_type,
        source_GeneratorType.return_type if isinstance(return_type, SourceFlag) else return_type
    )

        

@dataclass(frozen=True, eq=True)
class BoolType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_BoolType(self)

def make_BoolType(
) -> type:
    return BoolType(
    )

def update_BoolType(source_BoolType : BoolType
) -> BoolType:
    return BoolType(
    )

        

@dataclass(frozen=True, eq=True)
class TrueType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_TrueType(self)

def make_TrueType(
) -> type:
    return TrueType(
    )

def update_TrueType(source_TrueType : TrueType
) -> TrueType:
    return TrueType(
    )

        

@dataclass(frozen=True, eq=True)
class FalseType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_FalseType(self)

def make_FalseType(
) -> type:
    return FalseType(
    )

def update_FalseType(source_FalseType : FalseType
) -> FalseType:
    return FalseType(
    )

        

@dataclass(frozen=True, eq=True)
class IntType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_IntType(self)

def make_IntType(
) -> type:
    return IntType(
    )

def update_IntType(source_IntType : IntType
) -> IntType:
    return IntType(
    )

        

@dataclass(frozen=True, eq=True)
class IntLitType(type):
    literal : str

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_IntLitType(self)

def make_IntLitType(
    literal : str = ''
) -> type:
    return IntLitType(
        literal
    )

def update_IntLitType(source_IntLitType : IntLitType,
    literal : Union[str, SourceFlag] = SourceFlag()
) -> IntLitType:
    return IntLitType(
        source_IntLitType.literal if isinstance(literal, SourceFlag) else literal
    )

        

@dataclass(frozen=True, eq=True)
class FloatType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_FloatType(self)

def make_FloatType(
) -> type:
    return FloatType(
    )

def update_FloatType(source_FloatType : FloatType
) -> FloatType:
    return FloatType(
    )

        

@dataclass(frozen=True, eq=True)
class FloatLitType(type):
    literal : str

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_FloatLitType(self)

def make_FloatLitType(
    literal : str = ''
) -> type:
    return FloatLitType(
        literal
    )

def update_FloatLitType(source_FloatLitType : FloatLitType,
    literal : Union[str, SourceFlag] = SourceFlag()
) -> FloatLitType:
    return FloatLitType(
        source_FloatLitType.literal if isinstance(literal, SourceFlag) else literal
    )

        

@dataclass(frozen=True, eq=True)
class StrType(type):


    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_StrType(self)

def make_StrType(
) -> type:
    return StrType(
    )

def update_StrType(source_StrType : StrType
) -> StrType:
    return StrType(
    )

        

@dataclass(frozen=True, eq=True)
class StrLitType(type):
    literal : str

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_StrLitType(self)

def make_StrLitType(
    literal : str = ''
) -> type:
    return StrLitType(
        literal
    )

def update_StrLitType(source_StrLitType : StrLitType,
    literal : Union[str, SourceFlag] = SourceFlag()
) -> StrLitType:
    return StrLitType(
        source_StrLitType.literal if isinstance(literal, SourceFlag) else literal
    )

        

@dataclass(frozen=True, eq=True)
class SliceType(type):
    start : type
    stop : type
    step : type

    def match(self, handlers : TypeHandlers[T]) -> T:
        return handlers.case_SliceType(self)

def make_SliceType(
    start : type = AnyType(), 
    stop : type = AnyType(), 
    step : type = AnyType()
) -> type:
    return SliceType(
        start,
        stop,
        step
    )

def update_SliceType(source_SliceType : SliceType,
    start : Union[type, SourceFlag] = SourceFlag(),
    stop : Union[type, SourceFlag] = SourceFlag(),
    step : Union[type, SourceFlag] = SourceFlag()
) -> SliceType:
    return SliceType(
        source_SliceType.start if isinstance(start, SourceFlag) else start,
        source_SliceType.stop if isinstance(stop, SourceFlag) else stop,
        source_SliceType.step if isinstance(step, SourceFlag) else step
    )

        

# case handlers for type type
@dataclass(frozen=True, eq=True)
class TypeHandlers(Generic[T]):
    case_TypeType : Callable[[TypeType], T]
    case_VarType : Callable[[VarType], T]
    case_EllipType : Callable[[EllipType], T]
    case_AnyType : Callable[[AnyType], T]
    case_ObjectType : Callable[[ObjectType], T]
    case_NoneType : Callable[[NoneType], T]
    case_ModuleType : Callable[[ModuleType], T]
    case_FunctionType : Callable[[FunctionType], T]
    case_UnionType : Callable[[UnionType], T]
    case_InterType : Callable[[InterType], T]
    case_RecordType : Callable[[RecordType], T]
    case_TupleLitType : Callable[[TupleLitType], T]
    case_VariedTupleType : Callable[[VariedTupleType], T]
    case_MappingType : Callable[[MappingType], T]
    case_DictType : Callable[[DictType], T]
    case_SetType : Callable[[SetType], T]
    case_IterableType : Callable[[IterableType], T]
    case_DictKeysType : Callable[[DictKeysType], T]
    case_DictValuesType : Callable[[DictValuesType], T]
    case_DictItemsType : Callable[[DictItemsType], T]
    case_SequenceType : Callable[[SequenceType], T]
    case_RangeType : Callable[[RangeType], T]
    case_ListType : Callable[[ListType], T]
    case_ListLitType : Callable[[ListLitType], T]
    case_GeneratorType : Callable[[GeneratorType], T]
    case_BoolType : Callable[[BoolType], T]
    case_TrueType : Callable[[TrueType], T]
    case_FalseType : Callable[[FalseType], T]
    case_IntType : Callable[[IntType], T]
    case_IntLitType : Callable[[IntLitType], T]
    case_FloatType : Callable[[FloatType], T]
    case_FloatLitType : Callable[[FloatLitType], T]
    case_StrType : Callable[[StrType], T]
    case_StrLitType : Callable[[StrLitType], T]
    case_SliceType : Callable[[SliceType], T]


# matching for type type
def match_type(o : type, handlers : TypeHandlers[T]) -> T :
    return o.match(handlers)
     


# type and constructor ClassRecord
@dataclass(frozen=True, eq=True)
class ClassRecord:
    key : str
    type_params : tuple[VarType, ...]
    super_types : tuple[TypeType, ...]
    static_fields : PMap[str, type]
    instance_fields : PMap[str, type]


def make_ClassRecord(
    key : str,
    type_params : tuple[VarType, ...],
    super_types : tuple[TypeType, ...],
    static_fields : PMap[str, type],
    instance_fields : PMap[str, type]
) -> ClassRecord:
    return ClassRecord(
        key,
        type_params,
        super_types,
        static_fields,
        instance_fields)

def update_ClassRecord(source_ClassRecord : ClassRecord,
    key : Union[str, SourceFlag] = SourceFlag(),
    type_params : Union[tuple[VarType, ...], SourceFlag] = SourceFlag(),
    super_types : Union[tuple[TypeType, ...], SourceFlag] = SourceFlag(),
    static_fields : Union[PMap[str, type], SourceFlag] = SourceFlag(),
    instance_fields : Union[PMap[str, type], SourceFlag] = SourceFlag()
) -> ClassRecord:
    return ClassRecord(
        source_ClassRecord.key if isinstance(key, SourceFlag) else key, 
        source_ClassRecord.type_params if isinstance(type_params, SourceFlag) else type_params, 
        source_ClassRecord.super_types if isinstance(super_types, SourceFlag) else super_types, 
        source_ClassRecord.static_fields if isinstance(static_fields, SourceFlag) else static_fields, 
        source_ClassRecord.instance_fields if isinstance(instance_fields, SourceFlag) else instance_fields)

    

# type and constructor ModulePackage
@dataclass(frozen=True, eq=True)
class ModulePackage:
    module : PMap[str, Declaration]
    class_env : PMap[str, ClassRecord]
    package : PMap[str, ModulePackage]


def make_ModulePackage(
    module : PMap[str, Declaration] = m(),
    class_env : PMap[str, ClassRecord] = m(),
    package : PMap[str, ModulePackage] = m()
) -> ModulePackage:
    return ModulePackage(
        module,
        class_env,
        package)

def update_ModulePackage(source_ModulePackage : ModulePackage,
    module : Union[PMap[str, Declaration], SourceFlag] = SourceFlag(),
    class_env : Union[PMap[str, ClassRecord], SourceFlag] = SourceFlag(),
    package : Union[PMap[str, ModulePackage], SourceFlag] = SourceFlag()
) -> ModulePackage:
    return ModulePackage(
        source_ModulePackage.module if isinstance(module, SourceFlag) else module, 
        source_ModulePackage.class_env if isinstance(class_env, SourceFlag) else class_env, 
        source_ModulePackage.package if isinstance(package, SourceFlag) else package)

    

# type and constructor ParamSig
@dataclass(frozen=True, eq=True)
class ParamSig:
    key : str
    type : type
    optional : bool


def make_ParamSig(
    key : str,
    type : type,
    optional : bool
) -> ParamSig:
    return ParamSig(
        key,
        type,
        optional)

def update_ParamSig(source_ParamSig : ParamSig,
    key : Union[str, SourceFlag] = SourceFlag(),
    type : Union[type, SourceFlag] = SourceFlag(),
    optional : Union[bool, SourceFlag] = SourceFlag()
) -> ParamSig:
    return ParamSig(
        source_ParamSig.key if isinstance(key, SourceFlag) else key, 
        source_ParamSig.type if isinstance(type, SourceFlag) else type, 
        source_ParamSig.optional if isinstance(optional, SourceFlag) else optional)

    

# type and constructor VarLen
@dataclass(frozen=True, eq=True)
class VarLen:
    pass


def make_VarLen(
) -> VarLen:
    return VarLen()

def update_VarLen(source_VarLen : VarLen
) -> VarLen:
    return VarLen()

    

# type and constructor InherAux
@dataclass(frozen=True, eq=True)
class InherAux:
    package : PMap[str, ModulePackage]
    external_path : str
    internal_path : str
    in_class : bool
    global_env : PMap[str, Declaration]
    nonlocal_env : PMap[str, Declaration]
    local_env : PMap[str, Declaration]
    declared_globals : PSet[str]
    declared_nonlocals : PSet[str]
    usage_env : PMap[str, Usage]
    observed_types : tuple[type, ...]
    class_env : PMap[str, ClassRecord]


def make_InherAux(
    package : PMap[str, ModulePackage] = m(),
    external_path : str = '',
    internal_path : str = '',
    in_class : bool = False,
    global_env : PMap[str, Declaration] = m(),
    nonlocal_env : PMap[str, Declaration] = m(),
    local_env : PMap[str, Declaration] = m(),
    declared_globals : PSet[str] = s(),
    declared_nonlocals : PSet[str] = s(),
    usage_env : PMap[str, Usage] = m(),
    observed_types : tuple[type, ...] = (),
    class_env : PMap[str, ClassRecord] = m()
) -> InherAux:
    return InherAux(
        package,
        external_path,
        internal_path,
        in_class,
        global_env,
        nonlocal_env,
        local_env,
        declared_globals,
        declared_nonlocals,
        usage_env,
        observed_types,
        class_env)

def update_InherAux(source_InherAux : InherAux,
    package : Union[PMap[str, ModulePackage], SourceFlag] = SourceFlag(),
    external_path : Union[str, SourceFlag] = SourceFlag(),
    internal_path : Union[str, SourceFlag] = SourceFlag(),
    in_class : Union[bool, SourceFlag] = SourceFlag(),
    global_env : Union[PMap[str, Declaration], SourceFlag] = SourceFlag(),
    nonlocal_env : Union[PMap[str, Declaration], SourceFlag] = SourceFlag(),
    local_env : Union[PMap[str, Declaration], SourceFlag] = SourceFlag(),
    declared_globals : Union[PSet[str], SourceFlag] = SourceFlag(),
    declared_nonlocals : Union[PSet[str], SourceFlag] = SourceFlag(),
    usage_env : Union[PMap[str, Usage], SourceFlag] = SourceFlag(),
    observed_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    class_env : Union[PMap[str, ClassRecord], SourceFlag] = SourceFlag()
) -> InherAux:
    return InherAux(
        source_InherAux.package if isinstance(package, SourceFlag) else package, 
        source_InherAux.external_path if isinstance(external_path, SourceFlag) else external_path, 
        source_InherAux.internal_path if isinstance(internal_path, SourceFlag) else internal_path, 
        source_InherAux.in_class if isinstance(in_class, SourceFlag) else in_class, 
        source_InherAux.global_env if isinstance(global_env, SourceFlag) else global_env, 
        source_InherAux.nonlocal_env if isinstance(nonlocal_env, SourceFlag) else nonlocal_env, 
        source_InherAux.local_env if isinstance(local_env, SourceFlag) else local_env, 
        source_InherAux.declared_globals if isinstance(declared_globals, SourceFlag) else declared_globals, 
        source_InherAux.declared_nonlocals if isinstance(declared_nonlocals, SourceFlag) else declared_nonlocals, 
        source_InherAux.usage_env if isinstance(usage_env, SourceFlag) else usage_env, 
        source_InherAux.observed_types if isinstance(observed_types, SourceFlag) else observed_types, 
        source_InherAux.class_env if isinstance(class_env, SourceFlag) else class_env)

    

# type and constructor SynthAux
@dataclass(frozen=True, eq=True)
class SynthAux:
    class_additions : PMap[str, ClassRecord]
    decl_subtractions : PSet[str]
    decl_additions : PMap[str, Declaration]
    declared_globals : PSet[str]
    declared_nonlocals : PSet[str]
    usage_additions : PMap[str, Usage]
    cmp_names : tuple[str, ...]
    observed_types : tuple[type, ...]
    kw_types : PMap[str, type]
    return_types : tuple[type, ...]
    yield_types : tuple[type, ...]
    var_types : tuple[VarType, ...]
    param_sig : Optional[ParamSig]
    pos_param_types : tuple[type, ...]
    pos_kw_param_sigs : tuple[ParamSig, ...]
    splat_pos_param_type : Optional[type]
    kw_param_sigs : tuple[ParamSig, ...]
    splat_kw_param_type : Optional[type]
    import_names : PMap[str, str]


def make_SynthAux(
    class_additions : PMap[str, ClassRecord] = m(),
    decl_subtractions : PSet[str] = s(),
    decl_additions : PMap[str, Declaration] = m(),
    declared_globals : PSet[str] = s(),
    declared_nonlocals : PSet[str] = s(),
    usage_additions : PMap[str, Usage] = m(),
    cmp_names : tuple[str, ...] = (),
    observed_types : tuple[type, ...] = (),
    kw_types : PMap[str, type] = m(),
    return_types : tuple[type, ...] = (),
    yield_types : tuple[type, ...] = (),
    var_types : tuple[VarType, ...] = (),
    param_sig : Optional[ParamSig] = None,
    pos_param_types : tuple[type, ...] = (),
    pos_kw_param_sigs : tuple[ParamSig, ...] = (),
    splat_pos_param_type : Optional[type] = None,
    kw_param_sigs : tuple[ParamSig, ...] = (),
    splat_kw_param_type : Optional[type] = None,
    import_names : PMap[str, str] = m()
) -> SynthAux:
    return SynthAux(
        class_additions,
        decl_subtractions,
        decl_additions,
        declared_globals,
        declared_nonlocals,
        usage_additions,
        cmp_names,
        observed_types,
        kw_types,
        return_types,
        yield_types,
        var_types,
        param_sig,
        pos_param_types,
        pos_kw_param_sigs,
        splat_pos_param_type,
        kw_param_sigs,
        splat_kw_param_type,
        import_names)

def update_SynthAux(source_SynthAux : SynthAux,
    class_additions : Union[PMap[str, ClassRecord], SourceFlag] = SourceFlag(),
    decl_subtractions : Union[PSet[str], SourceFlag] = SourceFlag(),
    decl_additions : Union[PMap[str, Declaration], SourceFlag] = SourceFlag(),
    declared_globals : Union[PSet[str], SourceFlag] = SourceFlag(),
    declared_nonlocals : Union[PSet[str], SourceFlag] = SourceFlag(),
    usage_additions : Union[PMap[str, Usage], SourceFlag] = SourceFlag(),
    cmp_names : Union[tuple[str, ...], SourceFlag] = SourceFlag(),
    observed_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    kw_types : Union[PMap[str, type], SourceFlag] = SourceFlag(),
    return_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    yield_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    var_types : Union[tuple[VarType, ...], SourceFlag] = SourceFlag(),
    param_sig : Union[Optional[ParamSig], SourceFlag] = SourceFlag(),
    pos_param_types : Union[tuple[type, ...], SourceFlag] = SourceFlag(),
    pos_kw_param_sigs : Union[tuple[ParamSig, ...], SourceFlag] = SourceFlag(),
    splat_pos_param_type : Union[Optional[type], SourceFlag] = SourceFlag(),
    kw_param_sigs : Union[tuple[ParamSig, ...], SourceFlag] = SourceFlag(),
    splat_kw_param_type : Union[Optional[type], SourceFlag] = SourceFlag(),
    import_names : Union[PMap[str, str], SourceFlag] = SourceFlag()
) -> SynthAux:
    return SynthAux(
        source_SynthAux.class_additions if isinstance(class_additions, SourceFlag) else class_additions, 
        source_SynthAux.decl_subtractions if isinstance(decl_subtractions, SourceFlag) else decl_subtractions, 
        source_SynthAux.decl_additions if isinstance(decl_additions, SourceFlag) else decl_additions, 
        source_SynthAux.declared_globals if isinstance(declared_globals, SourceFlag) else declared_globals, 
        source_SynthAux.declared_nonlocals if isinstance(declared_nonlocals, SourceFlag) else declared_nonlocals, 
        source_SynthAux.usage_additions if isinstance(usage_additions, SourceFlag) else usage_additions, 
        source_SynthAux.cmp_names if isinstance(cmp_names, SourceFlag) else cmp_names, 
        source_SynthAux.observed_types if isinstance(observed_types, SourceFlag) else observed_types, 
        source_SynthAux.kw_types if isinstance(kw_types, SourceFlag) else kw_types, 
        source_SynthAux.return_types if isinstance(return_types, SourceFlag) else return_types, 
        source_SynthAux.yield_types if isinstance(yield_types, SourceFlag) else yield_types, 
        source_SynthAux.var_types if isinstance(var_types, SourceFlag) else var_types, 
        source_SynthAux.param_sig if isinstance(param_sig, SourceFlag) else param_sig, 
        source_SynthAux.pos_param_types if isinstance(pos_param_types, SourceFlag) else pos_param_types, 
        source_SynthAux.pos_kw_param_sigs if isinstance(pos_kw_param_sigs, SourceFlag) else pos_kw_param_sigs, 
        source_SynthAux.splat_pos_param_type if isinstance(splat_pos_param_type, SourceFlag) else splat_pos_param_type, 
        source_SynthAux.kw_param_sigs if isinstance(kw_param_sigs, SourceFlag) else kw_param_sigs, 
        source_SynthAux.splat_kw_param_type if isinstance(splat_kw_param_type, SourceFlag) else splat_kw_param_type, 
        source_SynthAux.import_names if isinstance(import_names, SourceFlag) else import_names)

    

# type and constructor Declaration
@dataclass(frozen=True, eq=True)
class Declaration:
    annotated : bool
    constant : bool
    initialized : bool
    type : type
    decorator_types : tuple[type, ...]


def make_Declaration(
    annotated : bool,
    constant : bool,
    initialized : bool = False,
    type : type = AnyType(),
    decorator_types : tuple[type, ...] = ()
) -> Declaration:
    return Declaration(
        annotated,
        constant,
        initialized,
        type,
        decorator_types)

def update_Declaration(source_Declaration : Declaration,
    annotated : Union[bool, SourceFlag] = SourceFlag(),
    constant : Union[bool, SourceFlag] = SourceFlag(),
    initialized : Union[bool, SourceFlag] = SourceFlag(),
    type : Union[type, SourceFlag] = SourceFlag(),
    decorator_types : Union[tuple[type, ...], SourceFlag] = SourceFlag()
) -> Declaration:
    return Declaration(
        source_Declaration.annotated if isinstance(annotated, SourceFlag) else annotated, 
        source_Declaration.constant if isinstance(constant, SourceFlag) else constant, 
        source_Declaration.initialized if isinstance(initialized, SourceFlag) else initialized, 
        source_Declaration.type if isinstance(type, SourceFlag) else type, 
        source_Declaration.decorator_types if isinstance(decorator_types, SourceFlag) else decorator_types)

    

# type and constructor Usage
@dataclass(frozen=True, eq=True)
class Usage:
    updated : bool


def make_Usage(
    updated : bool = False
) -> Usage:
    return Usage(
        updated)

def update_Usage(source_Usage : Usage,
    updated : Union[bool, SourceFlag] = SourceFlag()
) -> Usage:
    return Usage(
        source_Usage.updated if isinstance(updated, SourceFlag) else updated)

     
    