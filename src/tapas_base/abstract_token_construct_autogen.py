# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass





# type abstract_token
@dataclass(frozen=True, eq=True)
class abstract_token(ABC):
    # @abstractmethod
    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        raise Exception()


# constructors for type abstract_token

@dataclass(frozen=True, eq=True)
class Grammar(abstract_token):
    options : str
    selection : str
    source_start : int
    source_end : int

    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Grammar(self)

def make_Grammar(
    options : str, 
    selection : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> abstract_token:
    return Grammar(
        options,
        selection,
        source_start,
        source_end
    )

def update_Grammar(source_Grammar : Grammar,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Grammar:
    return Grammar(
        source_Grammar.options if isinstance(options, SourceFlag) else options,
        source_Grammar.selection if isinstance(selection, SourceFlag) else selection,
        source_Grammar.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Grammar.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Vocab(abstract_token):
    options : str
    selection : str

    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Vocab(self)

def make_Vocab(
    options : str, 
    selection : str
) -> abstract_token:
    return Vocab(
        options,
        selection
    )

def update_Vocab(source_Vocab : Vocab,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag()
) -> Vocab:
    return Vocab(
        source_Vocab.options if isinstance(options, SourceFlag) else options,
        source_Vocab.selection if isinstance(selection, SourceFlag) else selection
    )

        

@dataclass(frozen=True, eq=True)
class Hole(abstract_token):


    def match(self, handlers : AbstractTokenHandlers[T]) -> T:
        return handlers.case_Hole(self)

def make_Hole(
) -> abstract_token:
    return Hole(
    )

def update_Hole(source_Hole : Hole
) -> Hole:
    return Hole(
    )

        

# case handlers for type abstract_token
@dataclass(frozen=True, eq=True)
class AbstractTokenHandlers(Generic[T]):
    case_Grammar : Callable[[Grammar], T]
    case_Vocab : Callable[[Vocab], T]
    case_Hole : Callable[[Hole], T]


# matching for type abstract_token
def match_abstract_token(o : abstract_token, handlers : AbstractTokenHandlers[T]) -> T :
    return o.match(handlers)


abstract_token_union = Union[Grammar, Vocab, Hole]

# unguarding for type abstract_token
def unguard_abstract_token(o : abstract_token) -> abstract_token_union :
    return match_abstract_token(o, AbstractTokenHandlers(
        case_Grammar = lambda x : x, 
        case_Vocab = lambda x : x, 
        case_Hole = lambda x : x

    ))
     

 
    