from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional, Iterable
from collections.abc import Callable

from abc import ABC, abstractmethod
import json

from pyrsistent import PMap, PSet, pset

import pickle

T = TypeVar('T')

X = TypeVar('X')



def linearize_dict(d : dict) -> list: 
    return ['{'] + [
        item
        for k, v in d.items()
        for item in [k] + (
            linearize_dict(v) if isinstance(v, dict) else
            linearize_list(v) if isinstance(v, list) else
            [v]
        )
    ] +  ['}']

def linearize_list(xs : list) -> list: 
    return ['['] + [
        item
        for x in xs
        for item in (
            linearize_dict(x) if isinstance(x, dict) else
            linearize_list(x) if isinstance(x, list) else
            [x]
        )
    ] + [']']




class Ref(Generic[T]): 
    def __init__(self, item : T):
        self.item  = item 

def fail(msg : str):
    raise Exception(msg)

def match_d(k : T, d : dict[T, Callable[[], Any]], error_msg):
    return d.get(k, lambda: fail(error_msg))()

def exists(it : Iterable[T], f : Callable[[T], bool]) -> bool:
    for item in it:
        if f(item):
            return True
    return False

def every(it : Iterable[T], f : Callable[[T], bool]) -> bool:
    return not exists(it, lambda t : not f(t))


def merge_psets(sets : Iterable[PSet[T]]) -> PSet[T]:
    ts : PSet[T] = pset() 
    for x in sets:
        ts = ts.update(x)
    return ts


import os
import pathlib
# import logging

# logging.basicConfig(level=logging.INFO)

import importlib.resources
def package_path(package : str, path : str) -> str:
    with importlib.resources.path(package, path) as p:
        return str(p)

def project_path(rel_path : str):
    base_path = os.path.join(pathlib.Path(__file__).parent.absolute(), '..')
    return os.path.abspath(os.path.join(base_path, rel_path))


def write(dirpath : str, fname : str, code : str, append : bool = False):
    if not os.path.exists(dirpath):
        os.makedirs(dirpath)

    fpath = os.path.join(dirpath, f"{fname}")

    with open(fpath, 'a' if append else 'w') as f:
        # logging.info(f"Writing file: {fpath}")
        f.write(code)

def write_code(package_name, name, content):
    dirpath = project_path(f'{package_name}')
    return write(dirpath, f"{name}_autogen.py", f"# THIS FILE IS AUTOGENERATED\n# CHANGES MAY BE LOST\n{content}")

def run_jsonl_file(fpath : str, func : Callable[[str], Any]):
    error_count = 0

    with open(fpath, 'r') as f:
        #note: example 101 originally had a typo of using equality '==' instead of assignment '='
        count = 1

        line = f.readline()
        while line: 
            line_obj = json.loads(line)

            concrete = line_obj['code']
            func(concrete)

            # update
            line = f.readline()
            count += 1

        print(f"ERROR COUNT {error_count}")

def run_file(fpath : str, func : Callable[[str], Any]):
    with open(fpath, 'r') as f:
        concrete = f.read()
        func(concrete)




def save_object(o : Any, rel_path : str) -> Any:
    path = project_path(rel_path)
    with open(path, 'wb') as f:
        pickle.dump(o, f)
    return o

def load_object(package : str, file : str) -> Any:
    path = package_path(package, file)
    with open(path, 'rb') as f:
        return pickle.load(f)

