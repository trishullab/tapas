# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass


from tapas_base.line_format_construct_autogen import line_format


# type item
@dataclass(frozen=True, eq=True)
class item(ABC):
    # @abstractmethod
    def match(self, handlers : ItemHandlers[T]) -> T:
        raise Exception()


# constructors for type item

@dataclass(frozen=True, eq=True)
class Terminal(item):
    terminal : str

    def match(self, handlers : ItemHandlers[T]) -> T:
        return handlers.case_Terminal(self)

def make_Terminal(
    terminal : str
) -> item:
    return Terminal(
        terminal
    )

def update_Terminal(source_Terminal : Terminal,
    terminal : Union[str, SourceFlag] = SourceFlag()
) -> Terminal:
    return Terminal(
        source_Terminal.terminal if isinstance(terminal, SourceFlag) else terminal
    )

        

@dataclass(frozen=True, eq=True)
class Nonterm(item):
    relation : str
    nonterminal : str
    format : line_format

    def match(self, handlers : ItemHandlers[T]) -> T:
        return handlers.case_Nonterm(self)

def make_Nonterm(
    relation : str, 
    nonterminal : str, 
    format : line_format
) -> item:
    return Nonterm(
        relation,
        nonterminal,
        format
    )

def update_Nonterm(source_Nonterm : Nonterm,
    relation : Union[str, SourceFlag] = SourceFlag(),
    nonterminal : Union[str, SourceFlag] = SourceFlag(),
    format : Union[line_format, SourceFlag] = SourceFlag()
) -> Nonterm:
    return Nonterm(
        source_Nonterm.relation if isinstance(relation, SourceFlag) else relation,
        source_Nonterm.nonterminal if isinstance(nonterminal, SourceFlag) else nonterminal,
        source_Nonterm.format if isinstance(format, SourceFlag) else format
    )

        

@dataclass(frozen=True, eq=True)
class Vocab(item):
    relation : str
    vocab : str

    def match(self, handlers : ItemHandlers[T]) -> T:
        return handlers.case_Vocab(self)

def make_Vocab(
    relation : str, 
    vocab : str
) -> item:
    return Vocab(
        relation,
        vocab
    )

def update_Vocab(source_Vocab : Vocab,
    relation : Union[str, SourceFlag] = SourceFlag(),
    vocab : Union[str, SourceFlag] = SourceFlag()
) -> Vocab:
    return Vocab(
        source_Vocab.relation if isinstance(relation, SourceFlag) else relation,
        source_Vocab.vocab if isinstance(vocab, SourceFlag) else vocab
    )

        

# case handlers for type item
@dataclass(frozen=True, eq=True)
class ItemHandlers(Generic[T]):
    case_Terminal : Callable[[Terminal], T]
    case_Nonterm : Callable[[Nonterm], T]
    case_Vocab : Callable[[Vocab], T]


# matching for type item
def match_item(o : item, handlers : ItemHandlers[T]) -> T :
    return o.match(handlers)


item_union = Union[Terminal, Nonterm, Vocab]

# unguarding for type item
def unguard_item(o : item) -> item_union :
    return match_item(o, ItemHandlers(
        case_Terminal = lambda x : x, 
        case_Nonterm = lambda x : x, 
        case_Vocab = lambda x : x

    ))
    




# type and constructor Rule
@dataclass(frozen=True, eq=True)
class Rule:
    name : str
    content : list[item]


def make_Rule(
    name : str,
    content : list[item]
) -> Rule:
    return Rule(
        name,
        content)

def update_Rule(source_Rule : Rule,
    name : Union[str, SourceFlag] = SourceFlag(),
    content : Union[list[item], SourceFlag] = SourceFlag()
) -> Rule:
    return Rule(
        source_Rule.name if isinstance(name, SourceFlag) else name, 
        source_Rule.content if isinstance(content, SourceFlag) else content)

    