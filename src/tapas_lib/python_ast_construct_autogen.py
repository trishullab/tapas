# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST





from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass


from typing import Union


# type return_annotation
@dataclass(frozen=True, eq=True)
class return_annotation(ABC):
    # @abstractmethod
    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        raise Exception()


# constructors for type return_annotation

@dataclass(frozen=True, eq=True)
class SomeReturnAnno(return_annotation):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_SomeReturnAnno(self)

def make_SomeReturnAnno(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> return_annotation:
    return SomeReturnAnno(
        content,
        source_start,
        source_end
    )

def update_SomeReturnAnno(source_SomeReturnAnno : SomeReturnAnno,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeReturnAnno:
    return SomeReturnAnno(
        source_SomeReturnAnno.content if isinstance(content, SourceFlag) else content,
        source_SomeReturnAnno.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeReturnAnno.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoReturnAnno(return_annotation):
    source_start : int
    source_end : int

    def match(self, handlers : ReturnAnnotationHandlers[T]) -> T:
        return handlers.case_NoReturnAnno(self)

def make_NoReturnAnno(
    source_start : int = 0, 
    source_end : int = 0
) -> return_annotation:
    return NoReturnAnno(
        source_start,
        source_end
    )

def update_NoReturnAnno(source_NoReturnAnno : NoReturnAnno,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoReturnAnno:
    return NoReturnAnno(
        source_NoReturnAnno.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoReturnAnno.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type return_annotation
@dataclass(frozen=True, eq=True)
class ReturnAnnotationHandlers(Generic[T]):
    case_SomeReturnAnno : Callable[[SomeReturnAnno], T]
    case_NoReturnAnno : Callable[[NoReturnAnno], T]


# matching for type return_annotation
def match_return_annotation(o : return_annotation, handlers : ReturnAnnotationHandlers[T]) -> T :
    return o.match(handlers)


return_annotation_union = Union[SomeReturnAnno, NoReturnAnno]

# unguarding for type return_annotation
def unguard_return_annotation(o : return_annotation) -> return_annotation_union :
    return match_return_annotation(o, ReturnAnnotationHandlers(
        case_SomeReturnAnno = lambda x : x, 
        case_NoReturnAnno = lambda x : x

    ))
    

# type except_arg
@dataclass(frozen=True, eq=True)
class except_arg(ABC):
    # @abstractmethod
    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        raise Exception()


# constructors for type except_arg

@dataclass(frozen=True, eq=True)
class SomeExceptArg(except_arg):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArg(self)

def make_SomeExceptArg(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> except_arg:
    return SomeExceptArg(
        content,
        source_start,
        source_end
    )

def update_SomeExceptArg(source_SomeExceptArg : SomeExceptArg,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeExceptArg:
    return SomeExceptArg(
        source_SomeExceptArg.content if isinstance(content, SourceFlag) else content,
        source_SomeExceptArg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeExceptArg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SomeExceptArgName(except_arg):
    content : expr | None
    name : str
    source_start : int
    source_end : int

    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_SomeExceptArgName(self)

def make_SomeExceptArgName(
    content : expr | None, 
    name : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> except_arg:
    return SomeExceptArgName(
        content,
        name,
        source_start,
        source_end
    )

def update_SomeExceptArgName(source_SomeExceptArgName : SomeExceptArgName,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    name : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeExceptArgName:
    return SomeExceptArgName(
        source_SomeExceptArgName.content if isinstance(content, SourceFlag) else content,
        source_SomeExceptArgName.name if isinstance(name, SourceFlag) else name,
        source_SomeExceptArgName.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeExceptArgName.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoExceptArg(except_arg):
    source_start : int
    source_end : int

    def match(self, handlers : ExceptArgHandlers[T]) -> T:
        return handlers.case_NoExceptArg(self)

def make_NoExceptArg(
    source_start : int = 0, 
    source_end : int = 0
) -> except_arg:
    return NoExceptArg(
        source_start,
        source_end
    )

def update_NoExceptArg(source_NoExceptArg : NoExceptArg,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoExceptArg:
    return NoExceptArg(
        source_NoExceptArg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoExceptArg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type except_arg
@dataclass(frozen=True, eq=True)
class ExceptArgHandlers(Generic[T]):
    case_SomeExceptArg : Callable[[SomeExceptArg], T]
    case_SomeExceptArgName : Callable[[SomeExceptArgName], T]
    case_NoExceptArg : Callable[[NoExceptArg], T]


# matching for type except_arg
def match_except_arg(o : except_arg, handlers : ExceptArgHandlers[T]) -> T :
    return o.match(handlers)


except_arg_union = Union[SomeExceptArg, SomeExceptArgName, NoExceptArg]

# unguarding for type except_arg
def unguard_except_arg(o : except_arg) -> except_arg_union :
    return match_except_arg(o, ExceptArgHandlers(
        case_SomeExceptArg = lambda x : x, 
        case_SomeExceptArgName = lambda x : x, 
        case_NoExceptArg = lambda x : x

    ))
    

# type param_annotation
@dataclass(frozen=True, eq=True)
class param_annotation(ABC):
    # @abstractmethod
    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        raise Exception()


# constructors for type param_annotation

@dataclass(frozen=True, eq=True)
class SomeParamAnno(param_annotation):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_SomeParamAnno(self)

def make_SomeParamAnno(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> param_annotation:
    return SomeParamAnno(
        content,
        source_start,
        source_end
    )

def update_SomeParamAnno(source_SomeParamAnno : SomeParamAnno,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeParamAnno:
    return SomeParamAnno(
        source_SomeParamAnno.content if isinstance(content, SourceFlag) else content,
        source_SomeParamAnno.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeParamAnno.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoParamAnno(param_annotation):
    source_start : int
    source_end : int

    def match(self, handlers : ParamAnnotationHandlers[T]) -> T:
        return handlers.case_NoParamAnno(self)

def make_NoParamAnno(
    source_start : int = 0, 
    source_end : int = 0
) -> param_annotation:
    return NoParamAnno(
        source_start,
        source_end
    )

def update_NoParamAnno(source_NoParamAnno : NoParamAnno,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoParamAnno:
    return NoParamAnno(
        source_NoParamAnno.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoParamAnno.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type param_annotation
@dataclass(frozen=True, eq=True)
class ParamAnnotationHandlers(Generic[T]):
    case_SomeParamAnno : Callable[[SomeParamAnno], T]
    case_NoParamAnno : Callable[[NoParamAnno], T]


# matching for type param_annotation
def match_param_annotation(o : param_annotation, handlers : ParamAnnotationHandlers[T]) -> T :
    return o.match(handlers)


param_annotation_union = Union[SomeParamAnno, NoParamAnno]

# unguarding for type param_annotation
def unguard_param_annotation(o : param_annotation) -> param_annotation_union :
    return match_param_annotation(o, ParamAnnotationHandlers(
        case_SomeParamAnno = lambda x : x, 
        case_NoParamAnno = lambda x : x

    ))
    

# type param_default
@dataclass(frozen=True, eq=True)
class param_default(ABC):
    # @abstractmethod
    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        raise Exception()


# constructors for type param_default

@dataclass(frozen=True, eq=True)
class SomeParamDefault(param_default):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_SomeParamDefault(self)

def make_SomeParamDefault(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> param_default:
    return SomeParamDefault(
        content,
        source_start,
        source_end
    )

def update_SomeParamDefault(source_SomeParamDefault : SomeParamDefault,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeParamDefault:
    return SomeParamDefault(
        source_SomeParamDefault.content if isinstance(content, SourceFlag) else content,
        source_SomeParamDefault.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeParamDefault.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoParamDefault(param_default):
    source_start : int
    source_end : int

    def match(self, handlers : ParamDefaultHandlers[T]) -> T:
        return handlers.case_NoParamDefault(self)

def make_NoParamDefault(
    source_start : int = 0, 
    source_end : int = 0
) -> param_default:
    return NoParamDefault(
        source_start,
        source_end
    )

def update_NoParamDefault(source_NoParamDefault : NoParamDefault,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoParamDefault:
    return NoParamDefault(
        source_NoParamDefault.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoParamDefault.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type param_default
@dataclass(frozen=True, eq=True)
class ParamDefaultHandlers(Generic[T]):
    case_SomeParamDefault : Callable[[SomeParamDefault], T]
    case_NoParamDefault : Callable[[NoParamDefault], T]


# matching for type param_default
def match_param_default(o : param_default, handlers : ParamDefaultHandlers[T]) -> T :
    return o.match(handlers)


param_default_union = Union[SomeParamDefault, NoParamDefault]

# unguarding for type param_default
def unguard_param_default(o : param_default) -> param_default_union :
    return match_param_default(o, ParamDefaultHandlers(
        case_SomeParamDefault = lambda x : x, 
        case_NoParamDefault = lambda x : x

    ))
    

# type parameters_d
@dataclass(frozen=True, eq=True)
class parameters_d(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersDHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_d

@dataclass(frozen=True, eq=True)
class ConsKwParam(parameters_d):
    head : Param | None
    tail : parameters_d | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_ConsKwParam(self)

def make_ConsKwParam(
    head : Param | None, 
    tail : parameters_d | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_d:
    return ConsKwParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsKwParam(source_ConsKwParam : ConsKwParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_d | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsKwParam:
    return ConsKwParam(
        source_ConsKwParam.head if isinstance(head, SourceFlag) else head,
        source_ConsKwParam.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsKwParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsKwParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleKwParam(parameters_d):
    content : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_SingleKwParam(self)

def make_SingleKwParam(
    content : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_d:
    return SingleKwParam(
        content,
        source_start,
        source_end
    )

def update_SingleKwParam(source_SingleKwParam : SingleKwParam,
    content : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleKwParam:
    return SingleKwParam(
        source_SingleKwParam.content if isinstance(content, SourceFlag) else content,
        source_SingleKwParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleKwParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TransKwParam(parameters_d):
    head : Param | None
    tail : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersDHandlers[T]) -> T:
        return handlers.case_TransKwParam(self)

def make_TransKwParam(
    head : Param | None, 
    tail : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_d:
    return TransKwParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_TransKwParam(source_TransKwParam : TransKwParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TransKwParam:
    return TransKwParam(
        source_TransKwParam.head if isinstance(head, SourceFlag) else head,
        source_TransKwParam.tail if isinstance(tail, SourceFlag) else tail,
        source_TransKwParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TransKwParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type parameters_d
@dataclass(frozen=True, eq=True)
class ParametersDHandlers(Generic[T]):
    case_ConsKwParam : Callable[[ConsKwParam], T]
    case_SingleKwParam : Callable[[SingleKwParam], T]
    case_TransKwParam : Callable[[TransKwParam], T]


# matching for type parameters_d
def match_parameters_d(o : parameters_d, handlers : ParametersDHandlers[T]) -> T :
    return o.match(handlers)


parameters_d_union = Union[ConsKwParam, SingleKwParam, TransKwParam]

# unguarding for type parameters_d
def unguard_parameters_d(o : parameters_d) -> parameters_d_union :
    return match_parameters_d(o, ParametersDHandlers(
        case_ConsKwParam = lambda x : x, 
        case_SingleKwParam = lambda x : x, 
        case_TransKwParam = lambda x : x

    ))
    

# type parameters_c
@dataclass(frozen=True, eq=True)
class parameters_c(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersCHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_c

@dataclass(frozen=True, eq=True)
class SingleTupleBundleParam(parameters_c):
    content : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_SingleTupleBundleParam(self)

def make_SingleTupleBundleParam(
    content : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_c:
    return SingleTupleBundleParam(
        content,
        source_start,
        source_end
    )

def update_SingleTupleBundleParam(source_SingleTupleBundleParam : SingleTupleBundleParam,
    content : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleTupleBundleParam:
    return SingleTupleBundleParam(
        source_SingleTupleBundleParam.content if isinstance(content, SourceFlag) else content,
        source_SingleTupleBundleParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleTupleBundleParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TransTupleBundleParam(parameters_c):
    head : Param | None
    tail : parameters_d | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_TransTupleBundleParam(self)

def make_TransTupleBundleParam(
    head : Param | None, 
    tail : parameters_d | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_c:
    return TransTupleBundleParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_TransTupleBundleParam(source_TransTupleBundleParam : TransTupleBundleParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_d | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TransTupleBundleParam:
    return TransTupleBundleParam(
        source_TransTupleBundleParam.head if isinstance(head, SourceFlag) else head,
        source_TransTupleBundleParam.tail if isinstance(tail, SourceFlag) else tail,
        source_TransTupleBundleParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TransTupleBundleParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ParamsD(parameters_c):
    content : parameters_d | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_ParamsD(self)

def make_ParamsD(
    content : parameters_d | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_c:
    return ParamsD(
        content,
        source_start,
        source_end
    )

def update_ParamsD(source_ParamsD : ParamsD,
    content : Union[parameters_d | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ParamsD:
    return ParamsD(
        source_ParamsD.content if isinstance(content, SourceFlag) else content,
        source_ParamsD.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ParamsD.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DoubleBundleParam(parameters_c):
    tuple_param : Param | None
    dict_param : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_DoubleBundleParam(self)

def make_DoubleBundleParam(
    tuple_param : Param | None, 
    dict_param : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_c:
    return DoubleBundleParam(
        tuple_param,
        dict_param,
        source_start,
        source_end
    )

def update_DoubleBundleParam(source_DoubleBundleParam : DoubleBundleParam,
    tuple_param : Union[Param | None, SourceFlag] = SourceFlag(),
    dict_param : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DoubleBundleParam:
    return DoubleBundleParam(
        source_DoubleBundleParam.tuple_param if isinstance(tuple_param, SourceFlag) else tuple_param,
        source_DoubleBundleParam.dict_param if isinstance(dict_param, SourceFlag) else dict_param,
        source_DoubleBundleParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DoubleBundleParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DictionaryBundleParam(parameters_c):
    content : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersCHandlers[T]) -> T:
        return handlers.case_DictionaryBundleParam(self)

def make_DictionaryBundleParam(
    content : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_c:
    return DictionaryBundleParam(
        content,
        source_start,
        source_end
    )

def update_DictionaryBundleParam(source_DictionaryBundleParam : DictionaryBundleParam,
    content : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DictionaryBundleParam:
    return DictionaryBundleParam(
        source_DictionaryBundleParam.content if isinstance(content, SourceFlag) else content,
        source_DictionaryBundleParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DictionaryBundleParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type parameters_c
@dataclass(frozen=True, eq=True)
class ParametersCHandlers(Generic[T]):
    case_SingleTupleBundleParam : Callable[[SingleTupleBundleParam], T]
    case_TransTupleBundleParam : Callable[[TransTupleBundleParam], T]
    case_ParamsD : Callable[[ParamsD], T]
    case_DoubleBundleParam : Callable[[DoubleBundleParam], T]
    case_DictionaryBundleParam : Callable[[DictionaryBundleParam], T]


# matching for type parameters_c
def match_parameters_c(o : parameters_c, handlers : ParametersCHandlers[T]) -> T :
    return o.match(handlers)


parameters_c_union = Union[SingleTupleBundleParam, TransTupleBundleParam, ParamsD, DoubleBundleParam, DictionaryBundleParam]

# unguarding for type parameters_c
def unguard_parameters_c(o : parameters_c) -> parameters_c_union :
    return match_parameters_c(o, ParametersCHandlers(
        case_SingleTupleBundleParam = lambda x : x, 
        case_TransTupleBundleParam = lambda x : x, 
        case_ParamsD = lambda x : x, 
        case_DoubleBundleParam = lambda x : x, 
        case_DictionaryBundleParam = lambda x : x

    ))
    

# type parameters_b
@dataclass(frozen=True, eq=True)
class parameters_b(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersBHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_b

@dataclass(frozen=True, eq=True)
class ConsPosKeyParam(parameters_b):
    head : Param | None
    tail : parameters_b | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ConsPosKeyParam(self)

def make_ConsPosKeyParam(
    head : Param | None, 
    tail : parameters_b | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_b:
    return ConsPosKeyParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsPosKeyParam(source_ConsPosKeyParam : ConsPosKeyParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_b | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsPosKeyParam:
    return ConsPosKeyParam(
        source_ConsPosKeyParam.head if isinstance(head, SourceFlag) else head,
        source_ConsPosKeyParam.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsPosKeyParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsPosKeyParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SinglePosKeyParam(parameters_b):
    content : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_SinglePosKeyParam(self)

def make_SinglePosKeyParam(
    content : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_b:
    return SinglePosKeyParam(
        content,
        source_start,
        source_end
    )

def update_SinglePosKeyParam(source_SinglePosKeyParam : SinglePosKeyParam,
    content : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SinglePosKeyParam:
    return SinglePosKeyParam(
        source_SinglePosKeyParam.content if isinstance(content, SourceFlag) else content,
        source_SinglePosKeyParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SinglePosKeyParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ParamsC(parameters_b):
    content : parameters_c | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersBHandlers[T]) -> T:
        return handlers.case_ParamsC(self)

def make_ParamsC(
    content : parameters_c | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_b:
    return ParamsC(
        content,
        source_start,
        source_end
    )

def update_ParamsC(source_ParamsC : ParamsC,
    content : Union[parameters_c | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ParamsC:
    return ParamsC(
        source_ParamsC.content if isinstance(content, SourceFlag) else content,
        source_ParamsC.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ParamsC.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type parameters_b
@dataclass(frozen=True, eq=True)
class ParametersBHandlers(Generic[T]):
    case_ConsPosKeyParam : Callable[[ConsPosKeyParam], T]
    case_SinglePosKeyParam : Callable[[SinglePosKeyParam], T]
    case_ParamsC : Callable[[ParamsC], T]


# matching for type parameters_b
def match_parameters_b(o : parameters_b, handlers : ParametersBHandlers[T]) -> T :
    return o.match(handlers)


parameters_b_union = Union[ConsPosKeyParam, SinglePosKeyParam, ParamsC]

# unguarding for type parameters_b
def unguard_parameters_b(o : parameters_b) -> parameters_b_union :
    return match_parameters_b(o, ParametersBHandlers(
        case_ConsPosKeyParam = lambda x : x, 
        case_SinglePosKeyParam = lambda x : x, 
        case_ParamsC = lambda x : x

    ))
    

# type parameters_a
@dataclass(frozen=True, eq=True)
class parameters_a(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersAHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters_a

@dataclass(frozen=True, eq=True)
class ConsPosParam(parameters_a):
    head : Param | None
    tail : parameters_a | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_ConsPosParam(self)

def make_ConsPosParam(
    head : Param | None, 
    tail : parameters_a | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_a:
    return ConsPosParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsPosParam(source_ConsPosParam : ConsPosParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_a | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsPosParam:
    return ConsPosParam(
        source_ConsPosParam.head if isinstance(head, SourceFlag) else head,
        source_ConsPosParam.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsPosParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsPosParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SinglePosParam(parameters_a):
    content : Param | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_SinglePosParam(self)

def make_SinglePosParam(
    content : Param | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_a:
    return SinglePosParam(
        content,
        source_start,
        source_end
    )

def update_SinglePosParam(source_SinglePosParam : SinglePosParam,
    content : Union[Param | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SinglePosParam:
    return SinglePosParam(
        source_SinglePosParam.content if isinstance(content, SourceFlag) else content,
        source_SinglePosParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SinglePosParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TransPosParam(parameters_a):
    head : Param | None
    tail : parameters_b | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersAHandlers[T]) -> T:
        return handlers.case_TransPosParam(self)

def make_TransPosParam(
    head : Param | None, 
    tail : parameters_b | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters_a:
    return TransPosParam(
        head,
        tail,
        source_start,
        source_end
    )

def update_TransPosParam(source_TransPosParam : TransPosParam,
    head : Union[Param | None, SourceFlag] = SourceFlag(),
    tail : Union[parameters_b | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TransPosParam:
    return TransPosParam(
        source_TransPosParam.head if isinstance(head, SourceFlag) else head,
        source_TransPosParam.tail if isinstance(tail, SourceFlag) else tail,
        source_TransPosParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TransPosParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type parameters_a
@dataclass(frozen=True, eq=True)
class ParametersAHandlers(Generic[T]):
    case_ConsPosParam : Callable[[ConsPosParam], T]
    case_SinglePosParam : Callable[[SinglePosParam], T]
    case_TransPosParam : Callable[[TransPosParam], T]


# matching for type parameters_a
def match_parameters_a(o : parameters_a, handlers : ParametersAHandlers[T]) -> T :
    return o.match(handlers)


parameters_a_union = Union[ConsPosParam, SinglePosParam, TransPosParam]

# unguarding for type parameters_a
def unguard_parameters_a(o : parameters_a) -> parameters_a_union :
    return match_parameters_a(o, ParametersAHandlers(
        case_ConsPosParam = lambda x : x, 
        case_SinglePosParam = lambda x : x, 
        case_TransPosParam = lambda x : x

    ))
    

# type parameters
@dataclass(frozen=True, eq=True)
class parameters(ABC):
    # @abstractmethod
    def match(self, handlers : ParametersHandlers[T]) -> T:
        raise Exception()


# constructors for type parameters

@dataclass(frozen=True, eq=True)
class ParamsA(parameters):
    content : parameters_a | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsA(self)

def make_ParamsA(
    content : parameters_a | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters:
    return ParamsA(
        content,
        source_start,
        source_end
    )

def update_ParamsA(source_ParamsA : ParamsA,
    content : Union[parameters_a | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ParamsA:
    return ParamsA(
        source_ParamsA.content if isinstance(content, SourceFlag) else content,
        source_ParamsA.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ParamsA.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ParamsB(parameters):
    content : parameters_b | None
    source_start : int
    source_end : int

    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_ParamsB(self)

def make_ParamsB(
    content : parameters_b | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> parameters:
    return ParamsB(
        content,
        source_start,
        source_end
    )

def update_ParamsB(source_ParamsB : ParamsB,
    content : Union[parameters_b | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ParamsB:
    return ParamsB(
        source_ParamsB.content if isinstance(content, SourceFlag) else content,
        source_ParamsB.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ParamsB.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoParam(parameters):
    source_start : int
    source_end : int

    def match(self, handlers : ParametersHandlers[T]) -> T:
        return handlers.case_NoParam(self)

def make_NoParam(
    source_start : int = 0, 
    source_end : int = 0
) -> parameters:
    return NoParam(
        source_start,
        source_end
    )

def update_NoParam(source_NoParam : NoParam,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoParam:
    return NoParam(
        source_NoParam.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoParam.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type parameters
@dataclass(frozen=True, eq=True)
class ParametersHandlers(Generic[T]):
    case_ParamsA : Callable[[ParamsA], T]
    case_ParamsB : Callable[[ParamsB], T]
    case_NoParam : Callable[[NoParam], T]


# matching for type parameters
def match_parameters(o : parameters, handlers : ParametersHandlers[T]) -> T :
    return o.match(handlers)


parameters_union = Union[ParamsA, ParamsB, NoParam]

# unguarding for type parameters
def unguard_parameters(o : parameters) -> parameters_union :
    return match_parameters(o, ParametersHandlers(
        case_ParamsA = lambda x : x, 
        case_ParamsB = lambda x : x, 
        case_NoParam = lambda x : x

    ))
    

# type keyword
@dataclass(frozen=True, eq=True)
class keyword(ABC):
    # @abstractmethod
    def match(self, handlers : KeywordHandlers[T]) -> T:
        raise Exception()


# constructors for type keyword

@dataclass(frozen=True, eq=True)
class NamedKeyword(keyword):
    name : str
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_NamedKeyword(self)

def make_NamedKeyword(
    name : str, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> keyword:
    return NamedKeyword(
        name,
        content,
        source_start,
        source_end
    )

def update_NamedKeyword(source_NamedKeyword : NamedKeyword,
    name : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NamedKeyword:
    return NamedKeyword(
        source_NamedKeyword.name if isinstance(name, SourceFlag) else name,
        source_NamedKeyword.content if isinstance(content, SourceFlag) else content,
        source_NamedKeyword.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NamedKeyword.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SplatKeyword(keyword):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : KeywordHandlers[T]) -> T:
        return handlers.case_SplatKeyword(self)

def make_SplatKeyword(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> keyword:
    return SplatKeyword(
        content,
        source_start,
        source_end
    )

def update_SplatKeyword(source_SplatKeyword : SplatKeyword,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SplatKeyword:
    return SplatKeyword(
        source_SplatKeyword.content if isinstance(content, SourceFlag) else content,
        source_SplatKeyword.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SplatKeyword.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type keyword
@dataclass(frozen=True, eq=True)
class KeywordHandlers(Generic[T]):
    case_NamedKeyword : Callable[[NamedKeyword], T]
    case_SplatKeyword : Callable[[SplatKeyword], T]


# matching for type keyword
def match_keyword(o : keyword, handlers : KeywordHandlers[T]) -> T :
    return o.match(handlers)


keyword_union = Union[NamedKeyword, SplatKeyword]

# unguarding for type keyword
def unguard_keyword(o : keyword) -> keyword_union :
    return match_keyword(o, KeywordHandlers(
        case_NamedKeyword = lambda x : x, 
        case_SplatKeyword = lambda x : x

    ))
    

# type import_name
@dataclass(frozen=True, eq=True)
class import_name(ABC):
    # @abstractmethod
    def match(self, handlers : ImportNameHandlers[T]) -> T:
        raise Exception()


# constructors for type import_name

@dataclass(frozen=True, eq=True)
class ImportNameAlias(import_name):
    name : str
    alias : str
    source_start : int
    source_end : int

    def match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameAlias(self)

def make_ImportNameAlias(
    name : str, 
    alias : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> import_name:
    return ImportNameAlias(
        name,
        alias,
        source_start,
        source_end
    )

def update_ImportNameAlias(source_ImportNameAlias : ImportNameAlias,
    name : Union[str, SourceFlag] = SourceFlag(),
    alias : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ImportNameAlias:
    return ImportNameAlias(
        source_ImportNameAlias.name if isinstance(name, SourceFlag) else name,
        source_ImportNameAlias.alias if isinstance(alias, SourceFlag) else alias,
        source_ImportNameAlias.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ImportNameAlias.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ImportNameOnly(import_name):
    name : str
    source_start : int
    source_end : int

    def match(self, handlers : ImportNameHandlers[T]) -> T:
        return handlers.case_ImportNameOnly(self)

def make_ImportNameOnly(
    name : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> import_name:
    return ImportNameOnly(
        name,
        source_start,
        source_end
    )

def update_ImportNameOnly(source_ImportNameOnly : ImportNameOnly,
    name : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ImportNameOnly:
    return ImportNameOnly(
        source_ImportNameOnly.name if isinstance(name, SourceFlag) else name,
        source_ImportNameOnly.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ImportNameOnly.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type import_name
@dataclass(frozen=True, eq=True)
class ImportNameHandlers(Generic[T]):
    case_ImportNameAlias : Callable[[ImportNameAlias], T]
    case_ImportNameOnly : Callable[[ImportNameOnly], T]


# matching for type import_name
def match_import_name(o : import_name, handlers : ImportNameHandlers[T]) -> T :
    return o.match(handlers)


import_name_union = Union[ImportNameAlias, ImportNameOnly]

# unguarding for type import_name
def unguard_import_name(o : import_name) -> import_name_union :
    return match_import_name(o, ImportNameHandlers(
        case_ImportNameAlias = lambda x : x, 
        case_ImportNameOnly = lambda x : x

    ))
    

# type with_item
@dataclass(frozen=True, eq=True)
class with_item(ABC):
    # @abstractmethod
    def match(self, handlers : WithItemHandlers[T]) -> T:
        raise Exception()


# constructors for type with_item

@dataclass(frozen=True, eq=True)
class WithItemAlias(with_item):
    content : expr | None
    alias : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemAlias(self)

def make_WithItemAlias(
    content : expr | None, 
    alias : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> with_item:
    return WithItemAlias(
        content,
        alias,
        source_start,
        source_end
    )

def update_WithItemAlias(source_WithItemAlias : WithItemAlias,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    alias : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> WithItemAlias:
    return WithItemAlias(
        source_WithItemAlias.content if isinstance(content, SourceFlag) else content,
        source_WithItemAlias.alias if isinstance(alias, SourceFlag) else alias,
        source_WithItemAlias.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_WithItemAlias.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class WithItemOnly(with_item):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : WithItemHandlers[T]) -> T:
        return handlers.case_WithItemOnly(self)

def make_WithItemOnly(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> with_item:
    return WithItemOnly(
        content,
        source_start,
        source_end
    )

def update_WithItemOnly(source_WithItemOnly : WithItemOnly,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> WithItemOnly:
    return WithItemOnly(
        source_WithItemOnly.content if isinstance(content, SourceFlag) else content,
        source_WithItemOnly.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_WithItemOnly.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type with_item
@dataclass(frozen=True, eq=True)
class WithItemHandlers(Generic[T]):
    case_WithItemAlias : Callable[[WithItemAlias], T]
    case_WithItemOnly : Callable[[WithItemOnly], T]


# matching for type with_item
def match_with_item(o : with_item, handlers : WithItemHandlers[T]) -> T :
    return o.match(handlers)


with_item_union = Union[WithItemAlias, WithItemOnly]

# unguarding for type with_item
def unguard_with_item(o : with_item) -> with_item_union :
    return match_with_item(o, WithItemHandlers(
        case_WithItemAlias = lambda x : x, 
        case_WithItemOnly = lambda x : x

    ))
    

# type bases
@dataclass(frozen=True, eq=True)
class bases(ABC):
    # @abstractmethod
    def match(self, handlers : BasesHandlers[T]) -> T:
        raise Exception()


# constructors for type bases

@dataclass(frozen=True, eq=True)
class SomeBases(bases):
    bases : bases_a | None
    source_start : int
    source_end : int

    def match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_SomeBases(self)

def make_SomeBases(
    bases : bases_a | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> bases:
    return SomeBases(
        bases,
        source_start,
        source_end
    )

def update_SomeBases(source_SomeBases : SomeBases,
    bases : Union[bases_a | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeBases:
    return SomeBases(
        source_SomeBases.bases if isinstance(bases, SourceFlag) else bases,
        source_SomeBases.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeBases.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoBases(bases):
    source_start : int
    source_end : int

    def match(self, handlers : BasesHandlers[T]) -> T:
        return handlers.case_NoBases(self)

def make_NoBases(
    source_start : int = 0, 
    source_end : int = 0
) -> bases:
    return NoBases(
        source_start,
        source_end
    )

def update_NoBases(source_NoBases : NoBases,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoBases:
    return NoBases(
        source_NoBases.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoBases.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type bases
@dataclass(frozen=True, eq=True)
class BasesHandlers(Generic[T]):
    case_SomeBases : Callable[[SomeBases], T]
    case_NoBases : Callable[[NoBases], T]


# matching for type bases
def match_bases(o : bases, handlers : BasesHandlers[T]) -> T :
    return o.match(handlers)


bases_union = Union[SomeBases, NoBases]

# unguarding for type bases
def unguard_bases(o : bases) -> bases_union :
    return match_bases(o, BasesHandlers(
        case_SomeBases = lambda x : x, 
        case_NoBases = lambda x : x

    ))
    

# type bases_a
@dataclass(frozen=True, eq=True)
class bases_a(ABC):
    # @abstractmethod
    def match(self, handlers : BasesAHandlers[T]) -> T:
        raise Exception()


# constructors for type bases_a

@dataclass(frozen=True, eq=True)
class ConsBase(bases_a):
    head : expr | None
    tail : bases_a | None
    source_start : int
    source_end : int

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_ConsBase(self)

def make_ConsBase(
    head : expr | None, 
    tail : bases_a | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> bases_a:
    return ConsBase(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsBase(source_ConsBase : ConsBase,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[bases_a | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsBase:
    return ConsBase(
        source_ConsBase.head if isinstance(head, SourceFlag) else head,
        source_ConsBase.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsBase.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsBase.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleBase(bases_a):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_SingleBase(self)

def make_SingleBase(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> bases_a:
    return SingleBase(
        content,
        source_start,
        source_end
    )

def update_SingleBase(source_SingleBase : SingleBase,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleBase:
    return SingleBase(
        source_SingleBase.content if isinstance(content, SourceFlag) else content,
        source_SingleBase.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleBase.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class KeywordBases(bases_a):
    kws : keywords | None
    source_start : int
    source_end : int

    def match(self, handlers : BasesAHandlers[T]) -> T:
        return handlers.case_KeywordBases(self)

def make_KeywordBases(
    kws : keywords | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> bases_a:
    return KeywordBases(
        kws,
        source_start,
        source_end
    )

def update_KeywordBases(source_KeywordBases : KeywordBases,
    kws : Union[keywords | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> KeywordBases:
    return KeywordBases(
        source_KeywordBases.kws if isinstance(kws, SourceFlag) else kws,
        source_KeywordBases.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_KeywordBases.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type bases_a
@dataclass(frozen=True, eq=True)
class BasesAHandlers(Generic[T]):
    case_ConsBase : Callable[[ConsBase], T]
    case_SingleBase : Callable[[SingleBase], T]
    case_KeywordBases : Callable[[KeywordBases], T]


# matching for type bases_a
def match_bases_a(o : bases_a, handlers : BasesAHandlers[T]) -> T :
    return o.match(handlers)


bases_a_union = Union[ConsBase, SingleBase, KeywordBases]

# unguarding for type bases_a
def unguard_bases_a(o : bases_a) -> bases_a_union :
    return match_bases_a(o, BasesAHandlers(
        case_ConsBase = lambda x : x, 
        case_SingleBase = lambda x : x, 
        case_KeywordBases = lambda x : x

    ))
    

# type keywords
@dataclass(frozen=True, eq=True)
class keywords(ABC):
    # @abstractmethod
    def match(self, handlers : KeywordsHandlers[T]) -> T:
        raise Exception()


# constructors for type keywords

@dataclass(frozen=True, eq=True)
class ConsKeyword(keywords):
    pre_comment : str
    head : keyword | None
    post_comment : str
    tail : keywords | None
    source_start : int
    source_end : int

    def match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_ConsKeyword(self)

def make_ConsKeyword(
    pre_comment : str, 
    head : keyword | None, 
    post_comment : str, 
    tail : keywords | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> keywords:
    return ConsKeyword(
        pre_comment,
        head,
        post_comment,
        tail,
        source_start,
        source_end
    )

def update_ConsKeyword(source_ConsKeyword : ConsKeyword,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    head : Union[keyword | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[keywords | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsKeyword:
    return ConsKeyword(
        source_ConsKeyword.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ConsKeyword.head if isinstance(head, SourceFlag) else head,
        source_ConsKeyword.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ConsKeyword.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsKeyword.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsKeyword.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleKeyword(keywords):
    pre_comment : str
    content : keyword | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : KeywordsHandlers[T]) -> T:
        return handlers.case_SingleKeyword(self)

def make_SingleKeyword(
    pre_comment : str, 
    content : keyword | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> keywords:
    return SingleKeyword(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_SingleKeyword(source_SingleKeyword : SingleKeyword,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[keyword | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleKeyword:
    return SingleKeyword(
        source_SingleKeyword.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SingleKeyword.content if isinstance(content, SourceFlag) else content,
        source_SingleKeyword.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SingleKeyword.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleKeyword.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type keywords
@dataclass(frozen=True, eq=True)
class KeywordsHandlers(Generic[T]):
    case_ConsKeyword : Callable[[ConsKeyword], T]
    case_SingleKeyword : Callable[[SingleKeyword], T]


# matching for type keywords
def match_keywords(o : keywords, handlers : KeywordsHandlers[T]) -> T :
    return o.match(handlers)


keywords_union = Union[ConsKeyword, SingleKeyword]

# unguarding for type keywords
def unguard_keywords(o : keywords) -> keywords_union :
    return match_keywords(o, KeywordsHandlers(
        case_ConsKeyword = lambda x : x, 
        case_SingleKeyword = lambda x : x

    ))
    

# type comparisons
@dataclass(frozen=True, eq=True)
class comparisons(ABC):
    # @abstractmethod
    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        raise Exception()


# constructors for type comparisons

@dataclass(frozen=True, eq=True)
class ConsCompareRight(comparisons):
    head : CompareRight | None
    tail : comparisons | None
    source_start : int
    source_end : int

    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_ConsCompareRight(self)

def make_ConsCompareRight(
    head : CompareRight | None, 
    tail : comparisons | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> comparisons:
    return ConsCompareRight(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsCompareRight(source_ConsCompareRight : ConsCompareRight,
    head : Union[CompareRight | None, SourceFlag] = SourceFlag(),
    tail : Union[comparisons | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsCompareRight:
    return ConsCompareRight(
        source_ConsCompareRight.head if isinstance(head, SourceFlag) else head,
        source_ConsCompareRight.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsCompareRight.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsCompareRight.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleCompareRight(comparisons):
    content : CompareRight | None
    source_start : int
    source_end : int

    def match(self, handlers : ComparisonsHandlers[T]) -> T:
        return handlers.case_SingleCompareRight(self)

def make_SingleCompareRight(
    content : CompareRight | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> comparisons:
    return SingleCompareRight(
        content,
        source_start,
        source_end
    )

def update_SingleCompareRight(source_SingleCompareRight : SingleCompareRight,
    content : Union[CompareRight | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleCompareRight:
    return SingleCompareRight(
        source_SingleCompareRight.content if isinstance(content, SourceFlag) else content,
        source_SingleCompareRight.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleCompareRight.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type comparisons
@dataclass(frozen=True, eq=True)
class ComparisonsHandlers(Generic[T]):
    case_ConsCompareRight : Callable[[ConsCompareRight], T]
    case_SingleCompareRight : Callable[[SingleCompareRight], T]


# matching for type comparisons
def match_comparisons(o : comparisons, handlers : ComparisonsHandlers[T]) -> T :
    return o.match(handlers)


comparisons_union = Union[ConsCompareRight, SingleCompareRight]

# unguarding for type comparisons
def unguard_comparisons(o : comparisons) -> comparisons_union :
    return match_comparisons(o, ComparisonsHandlers(
        case_ConsCompareRight = lambda x : x, 
        case_SingleCompareRight = lambda x : x

    ))
    

# type option_expr
@dataclass(frozen=True, eq=True)
class option_expr(ABC):
    # @abstractmethod
    def match(self, handlers : OptionExprHandlers[T]) -> T:
        raise Exception()


# constructors for type option_expr

@dataclass(frozen=True, eq=True)
class SomeExpr(option_expr):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_SomeExpr(self)

def make_SomeExpr(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> option_expr:
    return SomeExpr(
        content,
        source_start,
        source_end
    )

def update_SomeExpr(source_SomeExpr : SomeExpr,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SomeExpr:
    return SomeExpr(
        source_SomeExpr.content if isinstance(content, SourceFlag) else content,
        source_SomeExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SomeExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoExpr(option_expr):
    source_start : int
    source_end : int

    def match(self, handlers : OptionExprHandlers[T]) -> T:
        return handlers.case_NoExpr(self)

def make_NoExpr(
    source_start : int = 0, 
    source_end : int = 0
) -> option_expr:
    return NoExpr(
        source_start,
        source_end
    )

def update_NoExpr(source_NoExpr : NoExpr,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoExpr:
    return NoExpr(
        source_NoExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type option_expr
@dataclass(frozen=True, eq=True)
class OptionExprHandlers(Generic[T]):
    case_SomeExpr : Callable[[SomeExpr], T]
    case_NoExpr : Callable[[NoExpr], T]


# matching for type option_expr
def match_option_expr(o : option_expr, handlers : OptionExprHandlers[T]) -> T :
    return o.match(handlers)


option_expr_union = Union[SomeExpr, NoExpr]

# unguarding for type option_expr
def unguard_option_expr(o : option_expr) -> option_expr_union :
    return match_option_expr(o, OptionExprHandlers(
        case_SomeExpr = lambda x : x, 
        case_NoExpr = lambda x : x

    ))
    

# type comma_exprs
@dataclass(frozen=True, eq=True)
class comma_exprs(ABC):
    # @abstractmethod
    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        raise Exception()


# constructors for type comma_exprs

@dataclass(frozen=True, eq=True)
class ConsExpr(comma_exprs):
    pre_comment : str
    head : expr | None
    post_comment : str
    tail : comma_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_ConsExpr(self)

def make_ConsExpr(
    pre_comment : str, 
    head : expr | None, 
    post_comment : str, 
    tail : comma_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> comma_exprs:
    return ConsExpr(
        pre_comment,
        head,
        post_comment,
        tail,
        source_start,
        source_end
    )

def update_ConsExpr(source_ConsExpr : ConsExpr,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[comma_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsExpr:
    return ConsExpr(
        source_ConsExpr.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ConsExpr.head if isinstance(head, SourceFlag) else head,
        source_ConsExpr.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ConsExpr.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleExpr(comma_exprs):
    pre_comment : str
    content : expr | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : CommaExprsHandlers[T]) -> T:
        return handlers.case_SingleExpr(self)

def make_SingleExpr(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> comma_exprs:
    return SingleExpr(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_SingleExpr(source_SingleExpr : SingleExpr,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleExpr:
    return SingleExpr(
        source_SingleExpr.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SingleExpr.content if isinstance(content, SourceFlag) else content,
        source_SingleExpr.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SingleExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type comma_exprs
@dataclass(frozen=True, eq=True)
class CommaExprsHandlers(Generic[T]):
    case_ConsExpr : Callable[[ConsExpr], T]
    case_SingleExpr : Callable[[SingleExpr], T]


# matching for type comma_exprs
def match_comma_exprs(o : comma_exprs, handlers : CommaExprsHandlers[T]) -> T :
    return o.match(handlers)


comma_exprs_union = Union[ConsExpr, SingleExpr]

# unguarding for type comma_exprs
def unguard_comma_exprs(o : comma_exprs) -> comma_exprs_union :
    return match_comma_exprs(o, CommaExprsHandlers(
        case_ConsExpr = lambda x : x, 
        case_SingleExpr = lambda x : x

    ))
    

# type target_exprs
@dataclass(frozen=True, eq=True)
class target_exprs(ABC):
    # @abstractmethod
    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        raise Exception()


# constructors for type target_exprs

@dataclass(frozen=True, eq=True)
class ConsTargetExpr(target_exprs):
    head : expr | None
    tail : target_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_ConsTargetExpr(self)

def make_ConsTargetExpr(
    head : expr | None, 
    tail : target_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> target_exprs:
    return ConsTargetExpr(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsTargetExpr(source_ConsTargetExpr : ConsTargetExpr,
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    tail : Union[target_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsTargetExpr:
    return ConsTargetExpr(
        source_ConsTargetExpr.head if isinstance(head, SourceFlag) else head,
        source_ConsTargetExpr.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsTargetExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsTargetExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleTargetExpr(target_exprs):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : TargetExprsHandlers[T]) -> T:
        return handlers.case_SingleTargetExpr(self)

def make_SingleTargetExpr(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> target_exprs:
    return SingleTargetExpr(
        content,
        source_start,
        source_end
    )

def update_SingleTargetExpr(source_SingleTargetExpr : SingleTargetExpr,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleTargetExpr:
    return SingleTargetExpr(
        source_SingleTargetExpr.content if isinstance(content, SourceFlag) else content,
        source_SingleTargetExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleTargetExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type target_exprs
@dataclass(frozen=True, eq=True)
class TargetExprsHandlers(Generic[T]):
    case_ConsTargetExpr : Callable[[ConsTargetExpr], T]
    case_SingleTargetExpr : Callable[[SingleTargetExpr], T]


# matching for type target_exprs
def match_target_exprs(o : target_exprs, handlers : TargetExprsHandlers[T]) -> T :
    return o.match(handlers)


target_exprs_union = Union[ConsTargetExpr, SingleTargetExpr]

# unguarding for type target_exprs
def unguard_target_exprs(o : target_exprs) -> target_exprs_union :
    return match_target_exprs(o, TargetExprsHandlers(
        case_ConsTargetExpr = lambda x : x, 
        case_SingleTargetExpr = lambda x : x

    ))
    

# type decorator
@dataclass(frozen=True, eq=True)
class decorator(ABC):
    # @abstractmethod
    def match(self, handlers : DecoratorHandlers[T]) -> T:
        raise Exception()


# constructors for type decorator

@dataclass(frozen=True, eq=True)
class ExprDec(decorator):
    content : expr | None
    comment : str
    source_start : int
    source_end : int

    def match(self, handlers : DecoratorHandlers[T]) -> T:
        return handlers.case_ExprDec(self)

def make_ExprDec(
    content : expr | None, 
    comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> decorator:
    return ExprDec(
        content,
        comment,
        source_start,
        source_end
    )

def update_ExprDec(source_ExprDec : ExprDec,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ExprDec:
    return ExprDec(
        source_ExprDec.content if isinstance(content, SourceFlag) else content,
        source_ExprDec.comment if isinstance(comment, SourceFlag) else comment,
        source_ExprDec.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ExprDec.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class CmntDec(decorator):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : DecoratorHandlers[T]) -> T:
        return handlers.case_CmntDec(self)

def make_CmntDec(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> decorator:
    return CmntDec(
        content,
        source_start,
        source_end
    )

def update_CmntDec(source_CmntDec : CmntDec,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> CmntDec:
    return CmntDec(
        source_CmntDec.content if isinstance(content, SourceFlag) else content,
        source_CmntDec.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_CmntDec.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type decorator
@dataclass(frozen=True, eq=True)
class DecoratorHandlers(Generic[T]):
    case_ExprDec : Callable[[ExprDec], T]
    case_CmntDec : Callable[[CmntDec], T]


# matching for type decorator
def match_decorator(o : decorator, handlers : DecoratorHandlers[T]) -> T :
    return o.match(handlers)


decorator_union = Union[ExprDec, CmntDec]

# unguarding for type decorator
def unguard_decorator(o : decorator) -> decorator_union :
    return match_decorator(o, DecoratorHandlers(
        case_ExprDec = lambda x : x, 
        case_CmntDec = lambda x : x

    ))
    

# type decorators
@dataclass(frozen=True, eq=True)
class decorators(ABC):
    # @abstractmethod
    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        raise Exception()


# constructors for type decorators

@dataclass(frozen=True, eq=True)
class ConsDec(decorators):
    head : decorator | None
    tail : decorators | None
    source_start : int
    source_end : int

    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_ConsDec(self)

def make_ConsDec(
    head : decorator | None, 
    tail : decorators | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> decorators:
    return ConsDec(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsDec(source_ConsDec : ConsDec,
    head : Union[decorator | None, SourceFlag] = SourceFlag(),
    tail : Union[decorators | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsDec:
    return ConsDec(
        source_ConsDec.head if isinstance(head, SourceFlag) else head,
        source_ConsDec.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsDec.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsDec.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoDec(decorators):
    source_start : int
    source_end : int

    def match(self, handlers : DecoratorsHandlers[T]) -> T:
        return handlers.case_NoDec(self)

def make_NoDec(
    source_start : int = 0, 
    source_end : int = 0
) -> decorators:
    return NoDec(
        source_start,
        source_end
    )

def update_NoDec(source_NoDec : NoDec,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoDec:
    return NoDec(
        source_NoDec.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoDec.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type decorators
@dataclass(frozen=True, eq=True)
class DecoratorsHandlers(Generic[T]):
    case_ConsDec : Callable[[ConsDec], T]
    case_NoDec : Callable[[NoDec], T]


# matching for type decorators
def match_decorators(o : decorators, handlers : DecoratorsHandlers[T]) -> T :
    return o.match(handlers)


decorators_union = Union[ConsDec, NoDec]

# unguarding for type decorators
def unguard_decorators(o : decorators) -> decorators_union :
    return match_decorators(o, DecoratorsHandlers(
        case_ConsDec = lambda x : x, 
        case_NoDec = lambda x : x

    ))
    

# type constraint_filters
@dataclass(frozen=True, eq=True)
class constraint_filters(ABC):
    # @abstractmethod
    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        raise Exception()


# constructors for type constraint_filters

@dataclass(frozen=True, eq=True)
class ConsFilter(constraint_filters):
    pre_comment : str
    head : expr | None
    post_comment : str
    tail : constraint_filters | None
    source_start : int
    source_end : int

    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_ConsFilter(self)

def make_ConsFilter(
    pre_comment : str, 
    head : expr | None, 
    post_comment : str, 
    tail : constraint_filters | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> constraint_filters:
    return ConsFilter(
        pre_comment,
        head,
        post_comment,
        tail,
        source_start,
        source_end
    )

def update_ConsFilter(source_ConsFilter : ConsFilter,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[constraint_filters | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsFilter:
    return ConsFilter(
        source_ConsFilter.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ConsFilter.head if isinstance(head, SourceFlag) else head,
        source_ConsFilter.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ConsFilter.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsFilter.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsFilter.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleFilter(constraint_filters):
    pre_comment : str
    content : expr | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_SingleFilter(self)

def make_SingleFilter(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> constraint_filters:
    return SingleFilter(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_SingleFilter(source_SingleFilter : SingleFilter,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleFilter:
    return SingleFilter(
        source_SingleFilter.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SingleFilter.content if isinstance(content, SourceFlag) else content,
        source_SingleFilter.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SingleFilter.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleFilter.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoFilter(constraint_filters):
    source_start : int
    source_end : int

    def match(self, handlers : ConstraintFiltersHandlers[T]) -> T:
        return handlers.case_NoFilter(self)

def make_NoFilter(
    source_start : int = 0, 
    source_end : int = 0
) -> constraint_filters:
    return NoFilter(
        source_start,
        source_end
    )

def update_NoFilter(source_NoFilter : NoFilter,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoFilter:
    return NoFilter(
        source_NoFilter.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoFilter.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type constraint_filters
@dataclass(frozen=True, eq=True)
class ConstraintFiltersHandlers(Generic[T]):
    case_ConsFilter : Callable[[ConsFilter], T]
    case_SingleFilter : Callable[[SingleFilter], T]
    case_NoFilter : Callable[[NoFilter], T]


# matching for type constraint_filters
def match_constraint_filters(o : constraint_filters, handlers : ConstraintFiltersHandlers[T]) -> T :
    return o.match(handlers)


constraint_filters_union = Union[ConsFilter, SingleFilter, NoFilter]

# unguarding for type constraint_filters
def unguard_constraint_filters(o : constraint_filters) -> constraint_filters_union :
    return match_constraint_filters(o, ConstraintFiltersHandlers(
        case_ConsFilter = lambda x : x, 
        case_SingleFilter = lambda x : x, 
        case_NoFilter = lambda x : x

    ))
    

# type sequence_string
@dataclass(frozen=True, eq=True)
class sequence_string(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_string

@dataclass(frozen=True, eq=True)
class ConsStr(sequence_string):
    head : str
    tail : sequence_string | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_ConsStr(self)

def make_ConsStr(
    head : str, 
    tail : sequence_string | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_string:
    return ConsStr(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsStr(source_ConsStr : ConsStr,
    head : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[sequence_string | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsStr:
    return ConsStr(
        source_ConsStr.head if isinstance(head, SourceFlag) else head,
        source_ConsStr.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsStr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsStr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleStr(sequence_string):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : SequenceStringHandlers[T]) -> T:
        return handlers.case_SingleStr(self)

def make_SingleStr(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_string:
    return SingleStr(
        content,
        source_start,
        source_end
    )

def update_SingleStr(source_SingleStr : SingleStr,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleStr:
    return SingleStr(
        source_SingleStr.content if isinstance(content, SourceFlag) else content,
        source_SingleStr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleStr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type sequence_string
@dataclass(frozen=True, eq=True)
class SequenceStringHandlers(Generic[T]):
    case_ConsStr : Callable[[ConsStr], T]
    case_SingleStr : Callable[[SingleStr], T]


# matching for type sequence_string
def match_sequence_string(o : sequence_string, handlers : SequenceStringHandlers[T]) -> T :
    return o.match(handlers)


sequence_string_union = Union[ConsStr, SingleStr]

# unguarding for type sequence_string
def unguard_sequence_string(o : sequence_string) -> sequence_string_union :
    return match_sequence_string(o, SequenceStringHandlers(
        case_ConsStr = lambda x : x, 
        case_SingleStr = lambda x : x

    ))
    

# type arguments
@dataclass(frozen=True, eq=True)
class arguments(ABC):
    # @abstractmethod
    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        raise Exception()


# constructors for type arguments

@dataclass(frozen=True, eq=True)
class ConsArg(arguments):
    pre_comment : str
    head : expr | None
    post_comment : str
    tail : arguments | None
    source_start : int
    source_end : int

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_ConsArg(self)

def make_ConsArg(
    pre_comment : str, 
    head : expr | None, 
    post_comment : str, 
    tail : arguments | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> arguments:
    return ConsArg(
        pre_comment,
        head,
        post_comment,
        tail,
        source_start,
        source_end
    )

def update_ConsArg(source_ConsArg : ConsArg,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    head : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[arguments | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsArg:
    return ConsArg(
        source_ConsArg.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ConsArg.head if isinstance(head, SourceFlag) else head,
        source_ConsArg.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ConsArg.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsArg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsArg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleArg(arguments):
    pre_comment : str
    content : expr | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_SingleArg(self)

def make_SingleArg(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> arguments:
    return SingleArg(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_SingleArg(source_SingleArg : SingleArg,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleArg:
    return SingleArg(
        source_SingleArg.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SingleArg.content if isinstance(content, SourceFlag) else content,
        source_SingleArg.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SingleArg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleArg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class KeywordsArg(arguments):
    kws : keywords | None
    source_start : int
    source_end : int

    def match(self, handlers : ArgumentsHandlers[T]) -> T:
        return handlers.case_KeywordsArg(self)

def make_KeywordsArg(
    kws : keywords | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> arguments:
    return KeywordsArg(
        kws,
        source_start,
        source_end
    )

def update_KeywordsArg(source_KeywordsArg : KeywordsArg,
    kws : Union[keywords | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> KeywordsArg:
    return KeywordsArg(
        source_KeywordsArg.kws if isinstance(kws, SourceFlag) else kws,
        source_KeywordsArg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_KeywordsArg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type arguments
@dataclass(frozen=True, eq=True)
class ArgumentsHandlers(Generic[T]):
    case_ConsArg : Callable[[ConsArg], T]
    case_SingleArg : Callable[[SingleArg], T]
    case_KeywordsArg : Callable[[KeywordsArg], T]


# matching for type arguments
def match_arguments(o : arguments, handlers : ArgumentsHandlers[T]) -> T :
    return o.match(handlers)


arguments_union = Union[ConsArg, SingleArg, KeywordsArg]

# unguarding for type arguments
def unguard_arguments(o : arguments) -> arguments_union :
    return match_arguments(o, ArgumentsHandlers(
        case_ConsArg = lambda x : x, 
        case_SingleArg = lambda x : x, 
        case_KeywordsArg = lambda x : x

    ))
    

# type dictionary_item
@dataclass(frozen=True, eq=True)
class dictionary_item(ABC):
    # @abstractmethod
    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        raise Exception()


# constructors for type dictionary_item

@dataclass(frozen=True, eq=True)
class Field(dictionary_item):
    key : expr | None
    pre_comment : str
    post_comment : str
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_Field(self)

def make_Field(
    key : expr | None, 
    pre_comment : str, 
    post_comment : str, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> dictionary_item:
    return Field(
        key,
        pre_comment,
        post_comment,
        content,
        source_start,
        source_end
    )

def update_Field(source_Field : Field,
    key : Union[expr | None, SourceFlag] = SourceFlag(),
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Field:
    return Field(
        source_Field.key if isinstance(key, SourceFlag) else key,
        source_Field.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_Field.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_Field.content if isinstance(content, SourceFlag) else content,
        source_Field.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Field.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DictionarySplatFields(dictionary_item):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : DictionaryItemHandlers[T]) -> T:
        return handlers.case_DictionarySplatFields(self)

def make_DictionarySplatFields(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> dictionary_item:
    return DictionarySplatFields(
        content,
        source_start,
        source_end
    )

def update_DictionarySplatFields(source_DictionarySplatFields : DictionarySplatFields,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DictionarySplatFields:
    return DictionarySplatFields(
        source_DictionarySplatFields.content if isinstance(content, SourceFlag) else content,
        source_DictionarySplatFields.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DictionarySplatFields.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type dictionary_item
@dataclass(frozen=True, eq=True)
class DictionaryItemHandlers(Generic[T]):
    case_Field : Callable[[Field], T]
    case_DictionarySplatFields : Callable[[DictionarySplatFields], T]


# matching for type dictionary_item
def match_dictionary_item(o : dictionary_item, handlers : DictionaryItemHandlers[T]) -> T :
    return o.match(handlers)


dictionary_item_union = Union[Field, DictionarySplatFields]

# unguarding for type dictionary_item
def unguard_dictionary_item(o : dictionary_item) -> dictionary_item_union :
    return match_dictionary_item(o, DictionaryItemHandlers(
        case_Field = lambda x : x, 
        case_DictionarySplatFields = lambda x : x

    ))
    

# type dictionary_content
@dataclass(frozen=True, eq=True)
class dictionary_content(ABC):
    # @abstractmethod
    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        raise Exception()


# constructors for type dictionary_content

@dataclass(frozen=True, eq=True)
class ConsDictionaryItem(dictionary_content):
    pre_comment : str
    head : dictionary_item | None
    post_comment : str
    tail : dictionary_content | None
    source_start : int
    source_end : int

    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_ConsDictionaryItem(self)

def make_ConsDictionaryItem(
    pre_comment : str, 
    head : dictionary_item | None, 
    post_comment : str, 
    tail : dictionary_content | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> dictionary_content:
    return ConsDictionaryItem(
        pre_comment,
        head,
        post_comment,
        tail,
        source_start,
        source_end
    )

def update_ConsDictionaryItem(source_ConsDictionaryItem : ConsDictionaryItem,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    head : Union[dictionary_item | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[dictionary_content | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsDictionaryItem:
    return ConsDictionaryItem(
        source_ConsDictionaryItem.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ConsDictionaryItem.head if isinstance(head, SourceFlag) else head,
        source_ConsDictionaryItem.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ConsDictionaryItem.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsDictionaryItem.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsDictionaryItem.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleDictionaryItem(dictionary_content):
    pre_comment : str
    content : dictionary_item | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : DictionaryContentHandlers[T]) -> T:
        return handlers.case_SingleDictionaryItem(self)

def make_SingleDictionaryItem(
    pre_comment : str, 
    content : dictionary_item | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> dictionary_content:
    return SingleDictionaryItem(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_SingleDictionaryItem(source_SingleDictionaryItem : SingleDictionaryItem,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[dictionary_item | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleDictionaryItem:
    return SingleDictionaryItem(
        source_SingleDictionaryItem.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SingleDictionaryItem.content if isinstance(content, SourceFlag) else content,
        source_SingleDictionaryItem.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SingleDictionaryItem.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleDictionaryItem.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type dictionary_content
@dataclass(frozen=True, eq=True)
class DictionaryContentHandlers(Generic[T]):
    case_ConsDictionaryItem : Callable[[ConsDictionaryItem], T]
    case_SingleDictionaryItem : Callable[[SingleDictionaryItem], T]


# matching for type dictionary_content
def match_dictionary_content(o : dictionary_content, handlers : DictionaryContentHandlers[T]) -> T :
    return o.match(handlers)


dictionary_content_union = Union[ConsDictionaryItem, SingleDictionaryItem]

# unguarding for type dictionary_content
def unguard_dictionary_content(o : dictionary_content) -> dictionary_content_union :
    return match_dictionary_content(o, DictionaryContentHandlers(
        case_ConsDictionaryItem = lambda x : x, 
        case_SingleDictionaryItem = lambda x : x

    ))
    

# type sequence_name
@dataclass(frozen=True, eq=True)
class sequence_name(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_name

@dataclass(frozen=True, eq=True)
class ConsId(sequence_name):
    head : str
    tail : sequence_name | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_ConsId(self)

def make_ConsId(
    head : str, 
    tail : sequence_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_name:
    return ConsId(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsId(source_ConsId : ConsId,
    head : Union[str, SourceFlag] = SourceFlag(),
    tail : Union[sequence_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsId:
    return ConsId(
        source_ConsId.head if isinstance(head, SourceFlag) else head,
        source_ConsId.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsId.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsId.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleId(sequence_name):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : SequenceNameHandlers[T]) -> T:
        return handlers.case_SingleId(self)

def make_SingleId(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_name:
    return SingleId(
        content,
        source_start,
        source_end
    )

def update_SingleId(source_SingleId : SingleId,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleId:
    return SingleId(
        source_SingleId.content if isinstance(content, SourceFlag) else content,
        source_SingleId.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleId.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type sequence_name
@dataclass(frozen=True, eq=True)
class SequenceNameHandlers(Generic[T]):
    case_ConsId : Callable[[ConsId], T]
    case_SingleId : Callable[[SingleId], T]


# matching for type sequence_name
def match_sequence_name(o : sequence_name, handlers : SequenceNameHandlers[T]) -> T :
    return o.match(handlers)


sequence_name_union = Union[ConsId, SingleId]

# unguarding for type sequence_name
def unguard_sequence_name(o : sequence_name) -> sequence_name_union :
    return match_sequence_name(o, SequenceNameHandlers(
        case_ConsId = lambda x : x, 
        case_SingleId = lambda x : x

    ))
    

# type sequence_import_name
@dataclass(frozen=True, eq=True)
class sequence_import_name(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_import_name

@dataclass(frozen=True, eq=True)
class ConsImportName(sequence_import_name):
    head : import_name | None
    tail : sequence_import_name | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_ConsImportName(self)

def make_ConsImportName(
    head : import_name | None, 
    tail : sequence_import_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_import_name:
    return ConsImportName(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsImportName(source_ConsImportName : ConsImportName,
    head : Union[import_name | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_import_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsImportName:
    return ConsImportName(
        source_ConsImportName.head if isinstance(head, SourceFlag) else head,
        source_ConsImportName.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsImportName.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsImportName.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleImportName(sequence_import_name):
    content : import_name | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceImportNameHandlers[T]) -> T:
        return handlers.case_SingleImportName(self)

def make_SingleImportName(
    content : import_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_import_name:
    return SingleImportName(
        content,
        source_start,
        source_end
    )

def update_SingleImportName(source_SingleImportName : SingleImportName,
    content : Union[import_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleImportName:
    return SingleImportName(
        source_SingleImportName.content if isinstance(content, SourceFlag) else content,
        source_SingleImportName.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleImportName.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type sequence_import_name
@dataclass(frozen=True, eq=True)
class SequenceImportNameHandlers(Generic[T]):
    case_ConsImportName : Callable[[ConsImportName], T]
    case_SingleImportName : Callable[[SingleImportName], T]


# matching for type sequence_import_name
def match_sequence_import_name(o : sequence_import_name, handlers : SequenceImportNameHandlers[T]) -> T :
    return o.match(handlers)


sequence_import_name_union = Union[ConsImportName, SingleImportName]

# unguarding for type sequence_import_name
def unguard_sequence_import_name(o : sequence_import_name) -> sequence_import_name_union :
    return match_sequence_import_name(o, SequenceImportNameHandlers(
        case_ConsImportName = lambda x : x, 
        case_SingleImportName = lambda x : x

    ))
    

# type sequence_with_item
@dataclass(frozen=True, eq=True)
class sequence_with_item(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_with_item

@dataclass(frozen=True, eq=True)
class ConsWithItem(sequence_with_item):
    head : with_item | None
    tail : sequence_with_item | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_ConsWithItem(self)

def make_ConsWithItem(
    head : with_item | None, 
    tail : sequence_with_item | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_with_item:
    return ConsWithItem(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsWithItem(source_ConsWithItem : ConsWithItem,
    head : Union[with_item | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_with_item | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsWithItem:
    return ConsWithItem(
        source_ConsWithItem.head if isinstance(head, SourceFlag) else head,
        source_ConsWithItem.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsWithItem.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsWithItem.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleWithItem(sequence_with_item):
    content : with_item | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceWithItemHandlers[T]) -> T:
        return handlers.case_SingleWithItem(self)

def make_SingleWithItem(
    content : with_item | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_with_item:
    return SingleWithItem(
        content,
        source_start,
        source_end
    )

def update_SingleWithItem(source_SingleWithItem : SingleWithItem,
    content : Union[with_item | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleWithItem:
    return SingleWithItem(
        source_SingleWithItem.content if isinstance(content, SourceFlag) else content,
        source_SingleWithItem.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleWithItem.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type sequence_with_item
@dataclass(frozen=True, eq=True)
class SequenceWithItemHandlers(Generic[T]):
    case_ConsWithItem : Callable[[ConsWithItem], T]
    case_SingleWithItem : Callable[[SingleWithItem], T]


# matching for type sequence_with_item
def match_sequence_with_item(o : sequence_with_item, handlers : SequenceWithItemHandlers[T]) -> T :
    return o.match(handlers)


sequence_with_item_union = Union[ConsWithItem, SingleWithItem]

# unguarding for type sequence_with_item
def unguard_sequence_with_item(o : sequence_with_item) -> sequence_with_item_union :
    return match_sequence_with_item(o, SequenceWithItemHandlers(
        case_ConsWithItem = lambda x : x, 
        case_SingleWithItem = lambda x : x

    ))
    

# type module
@dataclass(frozen=True, eq=True)
class module(ABC):
    # @abstractmethod
    def match(self, handlers : ModuleHandlers[T]) -> T:
        raise Exception()


# constructors for type module

@dataclass(frozen=True, eq=True)
class FutureMod(module):
    names : sequence_import_name | None
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_FutureMod(self)

def make_FutureMod(
    names : sequence_import_name | None, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> module:
    return FutureMod(
        names,
        body,
        source_start,
        source_end
    )

def update_FutureMod(source_FutureMod : FutureMod,
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> FutureMod:
    return FutureMod(
        source_FutureMod.names if isinstance(names, SourceFlag) else names,
        source_FutureMod.body if isinstance(body, SourceFlag) else body,
        source_FutureMod.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_FutureMod.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SimpleMod(module):
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : ModuleHandlers[T]) -> T:
        return handlers.case_SimpleMod(self)

def make_SimpleMod(
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> module:
    return SimpleMod(
        body,
        source_start,
        source_end
    )

def update_SimpleMod(source_SimpleMod : SimpleMod,
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SimpleMod:
    return SimpleMod(
        source_SimpleMod.body if isinstance(body, SourceFlag) else body,
        source_SimpleMod.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SimpleMod.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type module
@dataclass(frozen=True, eq=True)
class ModuleHandlers(Generic[T]):
    case_FutureMod : Callable[[FutureMod], T]
    case_SimpleMod : Callable[[SimpleMod], T]


# matching for type module
def match_module(o : module, handlers : ModuleHandlers[T]) -> T :
    return o.match(handlers)


module_union = Union[FutureMod, SimpleMod]

# unguarding for type module
def unguard_module(o : module) -> module_union :
    return match_module(o, ModuleHandlers(
        case_FutureMod = lambda x : x, 
        case_SimpleMod = lambda x : x

    ))
    

# type statements
@dataclass(frozen=True, eq=True)
class statements(ABC):
    # @abstractmethod
    def match(self, handlers : StatementsHandlers[T]) -> T:
        raise Exception()


# constructors for type statements

@dataclass(frozen=True, eq=True)
class ConsStmt(statements):
    head : stmt | None
    tail : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_ConsStmt(self)

def make_ConsStmt(
    head : stmt | None, 
    tail : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> statements:
    return ConsStmt(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsStmt(source_ConsStmt : ConsStmt,
    head : Union[stmt | None, SourceFlag] = SourceFlag(),
    tail : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsStmt:
    return ConsStmt(
        source_ConsStmt.head if isinstance(head, SourceFlag) else head,
        source_ConsStmt.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsStmt.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsStmt.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleStmt(statements):
    content : stmt | None
    source_start : int
    source_end : int

    def match(self, handlers : StatementsHandlers[T]) -> T:
        return handlers.case_SingleStmt(self)

def make_SingleStmt(
    content : stmt | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> statements:
    return SingleStmt(
        content,
        source_start,
        source_end
    )

def update_SingleStmt(source_SingleStmt : SingleStmt,
    content : Union[stmt | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleStmt:
    return SingleStmt(
        source_SingleStmt.content if isinstance(content, SourceFlag) else content,
        source_SingleStmt.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleStmt.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type statements
@dataclass(frozen=True, eq=True)
class StatementsHandlers(Generic[T]):
    case_ConsStmt : Callable[[ConsStmt], T]
    case_SingleStmt : Callable[[SingleStmt], T]


# matching for type statements
def match_statements(o : statements, handlers : StatementsHandlers[T]) -> T :
    return o.match(handlers)


statements_union = Union[ConsStmt, SingleStmt]

# unguarding for type statements
def unguard_statements(o : statements) -> statements_union :
    return match_statements(o, StatementsHandlers(
        case_ConsStmt = lambda x : x, 
        case_SingleStmt = lambda x : x

    ))
    

# type comprehension_constraints
@dataclass(frozen=True, eq=True)
class comprehension_constraints(ABC):
    # @abstractmethod
    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        raise Exception()


# constructors for type comprehension_constraints

@dataclass(frozen=True, eq=True)
class ConsConstraint(comprehension_constraints):
    head : constraint | None
    tail : comprehension_constraints | None
    source_start : int
    source_end : int

    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_ConsConstraint(self)

def make_ConsConstraint(
    head : constraint | None, 
    tail : comprehension_constraints | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> comprehension_constraints:
    return ConsConstraint(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsConstraint(source_ConsConstraint : ConsConstraint,
    head : Union[constraint | None, SourceFlag] = SourceFlag(),
    tail : Union[comprehension_constraints | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsConstraint:
    return ConsConstraint(
        source_ConsConstraint.head if isinstance(head, SourceFlag) else head,
        source_ConsConstraint.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsConstraint.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsConstraint.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleConstraint(comprehension_constraints):
    content : constraint | None
    source_start : int
    source_end : int

    def match(self, handlers : ComprehensionConstraintsHandlers[T]) -> T:
        return handlers.case_SingleConstraint(self)

def make_SingleConstraint(
    content : constraint | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> comprehension_constraints:
    return SingleConstraint(
        content,
        source_start,
        source_end
    )

def update_SingleConstraint(source_SingleConstraint : SingleConstraint,
    content : Union[constraint | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleConstraint:
    return SingleConstraint(
        source_SingleConstraint.content if isinstance(content, SourceFlag) else content,
        source_SingleConstraint.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleConstraint.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type comprehension_constraints
@dataclass(frozen=True, eq=True)
class ComprehensionConstraintsHandlers(Generic[T]):
    case_ConsConstraint : Callable[[ConsConstraint], T]
    case_SingleConstraint : Callable[[SingleConstraint], T]


# matching for type comprehension_constraints
def match_comprehension_constraints(o : comprehension_constraints, handlers : ComprehensionConstraintsHandlers[T]) -> T :
    return o.match(handlers)


comprehension_constraints_union = Union[ConsConstraint, SingleConstraint]

# unguarding for type comprehension_constraints
def unguard_comprehension_constraints(o : comprehension_constraints) -> comprehension_constraints_union :
    return match_comprehension_constraints(o, ComprehensionConstraintsHandlers(
        case_ConsConstraint = lambda x : x, 
        case_SingleConstraint = lambda x : x

    ))
    

# type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class sequence_ExceptHandler(ABC):
    # @abstractmethod
    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        raise Exception()


# constructors for type sequence_ExceptHandler

@dataclass(frozen=True, eq=True)
class ConsExceptHandler(sequence_ExceptHandler):
    head : ExceptHandler | None
    tail : sequence_ExceptHandler | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_ConsExceptHandler(self)

def make_ConsExceptHandler(
    head : ExceptHandler | None, 
    tail : sequence_ExceptHandler | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_ExceptHandler:
    return ConsExceptHandler(
        head,
        tail,
        source_start,
        source_end
    )

def update_ConsExceptHandler(source_ConsExceptHandler : ConsExceptHandler,
    head : Union[ExceptHandler | None, SourceFlag] = SourceFlag(),
    tail : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConsExceptHandler:
    return ConsExceptHandler(
        source_ConsExceptHandler.head if isinstance(head, SourceFlag) else head,
        source_ConsExceptHandler.tail if isinstance(tail, SourceFlag) else tail,
        source_ConsExceptHandler.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConsExceptHandler.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SingleExceptHandler(sequence_ExceptHandler):
    content : ExceptHandler | None
    source_start : int
    source_end : int

    def match(self, handlers : SequenceExceptHandlerHandlers[T]) -> T:
        return handlers.case_SingleExceptHandler(self)

def make_SingleExceptHandler(
    content : ExceptHandler | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> sequence_ExceptHandler:
    return SingleExceptHandler(
        content,
        source_start,
        source_end
    )

def update_SingleExceptHandler(source_SingleExceptHandler : SingleExceptHandler,
    content : Union[ExceptHandler | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SingleExceptHandler:
    return SingleExceptHandler(
        source_SingleExceptHandler.content if isinstance(content, SourceFlag) else content,
        source_SingleExceptHandler.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SingleExceptHandler.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type sequence_ExceptHandler
@dataclass(frozen=True, eq=True)
class SequenceExceptHandlerHandlers(Generic[T]):
    case_ConsExceptHandler : Callable[[ConsExceptHandler], T]
    case_SingleExceptHandler : Callable[[SingleExceptHandler], T]


# matching for type sequence_ExceptHandler
def match_sequence_ExceptHandler(o : sequence_ExceptHandler, handlers : SequenceExceptHandlerHandlers[T]) -> T :
    return o.match(handlers)


sequence_ExceptHandler_union = Union[ConsExceptHandler, SingleExceptHandler]

# unguarding for type sequence_ExceptHandler
def unguard_sequence_ExceptHandler(o : sequence_ExceptHandler) -> sequence_ExceptHandler_union :
    return match_sequence_ExceptHandler(o, SequenceExceptHandlerHandlers(
        case_ConsExceptHandler = lambda x : x, 
        case_SingleExceptHandler = lambda x : x

    ))
    

# type conditions
@dataclass(frozen=True, eq=True)
class conditions(ABC):
    # @abstractmethod
    def match(self, handlers : ConditionsHandlers[T]) -> T:
        raise Exception()


# constructors for type conditions

@dataclass(frozen=True, eq=True)
class ElifCond(conditions):
    content : ElifBlock | None
    tail : conditions | None
    source_start : int
    source_end : int

    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElifCond(self)

def make_ElifCond(
    content : ElifBlock | None, 
    tail : conditions | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> conditions:
    return ElifCond(
        content,
        tail,
        source_start,
        source_end
    )

def update_ElifCond(source_ElifCond : ElifCond,
    content : Union[ElifBlock | None, SourceFlag] = SourceFlag(),
    tail : Union[conditions | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ElifCond:
    return ElifCond(
        source_ElifCond.content if isinstance(content, SourceFlag) else content,
        source_ElifCond.tail if isinstance(tail, SourceFlag) else tail,
        source_ElifCond.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ElifCond.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ElseCond(conditions):
    content : ElseBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_ElseCond(self)

def make_ElseCond(
    content : ElseBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> conditions:
    return ElseCond(
        content,
        source_start,
        source_end
    )

def update_ElseCond(source_ElseCond : ElseCond,
    content : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ElseCond:
    return ElseCond(
        source_ElseCond.content if isinstance(content, SourceFlag) else content,
        source_ElseCond.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ElseCond.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NoCond(conditions):
    source_start : int
    source_end : int

    def match(self, handlers : ConditionsHandlers[T]) -> T:
        return handlers.case_NoCond(self)

def make_NoCond(
    source_start : int = 0, 
    source_end : int = 0
) -> conditions:
    return NoCond(
        source_start,
        source_end
    )

def update_NoCond(source_NoCond : NoCond,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NoCond:
    return NoCond(
        source_NoCond.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NoCond.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type conditions
@dataclass(frozen=True, eq=True)
class ConditionsHandlers(Generic[T]):
    case_ElifCond : Callable[[ElifCond], T]
    case_ElseCond : Callable[[ElseCond], T]
    case_NoCond : Callable[[NoCond], T]


# matching for type conditions
def match_conditions(o : conditions, handlers : ConditionsHandlers[T]) -> T :
    return o.match(handlers)


conditions_union = Union[ElifCond, ElseCond, NoCond]

# unguarding for type conditions
def unguard_conditions(o : conditions) -> conditions_union :
    return match_conditions(o, ConditionsHandlers(
        case_ElifCond = lambda x : x, 
        case_ElseCond = lambda x : x, 
        case_NoCond = lambda x : x

    ))
    

# type function_def
@dataclass(frozen=True, eq=True)
class function_def(ABC):
    # @abstractmethod
    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        raise Exception()


# constructors for type function_def

@dataclass(frozen=True, eq=True)
class FunctionDef(function_def):
    name : str
    params : parameters | None
    ret_anno : return_annotation | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_FunctionDef(self)

def make_FunctionDef(
    name : str, 
    params : parameters | None, 
    ret_anno : return_annotation | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> function_def:
    return FunctionDef(
        name,
        params,
        ret_anno,
        comment,
        body,
        source_start,
        source_end
    )

def update_FunctionDef(source_FunctionDef : FunctionDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    ret_anno : Union[return_annotation | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> FunctionDef:
    return FunctionDef(
        source_FunctionDef.name if isinstance(name, SourceFlag) else name,
        source_FunctionDef.params if isinstance(params, SourceFlag) else params,
        source_FunctionDef.ret_anno if isinstance(ret_anno, SourceFlag) else ret_anno,
        source_FunctionDef.comment if isinstance(comment, SourceFlag) else comment,
        source_FunctionDef.body if isinstance(body, SourceFlag) else body,
        source_FunctionDef.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_FunctionDef.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AsyncFunctionDef(function_def):
    name : str
    params : parameters | None
    ret_anno : return_annotation | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : FunctionDefHandlers[T]) -> T:
        return handlers.case_AsyncFunctionDef(self)

def make_AsyncFunctionDef(
    name : str, 
    params : parameters | None, 
    ret_anno : return_annotation | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> function_def:
    return AsyncFunctionDef(
        name,
        params,
        ret_anno,
        comment,
        body,
        source_start,
        source_end
    )

def update_AsyncFunctionDef(source_AsyncFunctionDef : AsyncFunctionDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    ret_anno : Union[return_annotation | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AsyncFunctionDef:
    return AsyncFunctionDef(
        source_AsyncFunctionDef.name if isinstance(name, SourceFlag) else name,
        source_AsyncFunctionDef.params if isinstance(params, SourceFlag) else params,
        source_AsyncFunctionDef.ret_anno if isinstance(ret_anno, SourceFlag) else ret_anno,
        source_AsyncFunctionDef.comment if isinstance(comment, SourceFlag) else comment,
        source_AsyncFunctionDef.body if isinstance(body, SourceFlag) else body,
        source_AsyncFunctionDef.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AsyncFunctionDef.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type function_def
@dataclass(frozen=True, eq=True)
class FunctionDefHandlers(Generic[T]):
    case_FunctionDef : Callable[[FunctionDef], T]
    case_AsyncFunctionDef : Callable[[AsyncFunctionDef], T]


# matching for type function_def
def match_function_def(o : function_def, handlers : FunctionDefHandlers[T]) -> T :
    return o.match(handlers)


function_def_union = Union[FunctionDef, AsyncFunctionDef]

# unguarding for type function_def
def unguard_function_def(o : function_def) -> function_def_union :
    return match_function_def(o, FunctionDefHandlers(
        case_FunctionDef = lambda x : x, 
        case_AsyncFunctionDef = lambda x : x

    ))
    

# type stmt
@dataclass(frozen=True, eq=True)
class stmt(ABC):
    # @abstractmethod
    def match(self, handlers : StmtHandlers[T]) -> T:
        raise Exception()


# constructors for type stmt

@dataclass(frozen=True, eq=True)
class Comment(stmt):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Comment(self)

def make_Comment(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Comment(
        content,
        source_start,
        source_end
    )

def update_Comment(source_Comment : Comment,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Comment:
    return Comment(
        source_Comment.content if isinstance(content, SourceFlag) else content,
        source_Comment.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Comment.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DecFunctionDef(stmt):
    decs : decorators | None
    fun_def : function_def | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecFunctionDef(self)

def make_DecFunctionDef(
    decs : decorators | None, 
    fun_def : function_def | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return DecFunctionDef(
        decs,
        fun_def,
        source_start,
        source_end
    )

def update_DecFunctionDef(source_DecFunctionDef : DecFunctionDef,
    decs : Union[decorators | None, SourceFlag] = SourceFlag(),
    fun_def : Union[function_def | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DecFunctionDef:
    return DecFunctionDef(
        source_DecFunctionDef.decs if isinstance(decs, SourceFlag) else decs,
        source_DecFunctionDef.fun_def if isinstance(fun_def, SourceFlag) else fun_def,
        source_DecFunctionDef.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DecFunctionDef.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DecClassDef(stmt):
    decs : decorators | None
    class_def : ClassDef | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_DecClassDef(self)

def make_DecClassDef(
    decs : decorators | None, 
    class_def : ClassDef | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return DecClassDef(
        decs,
        class_def,
        source_start,
        source_end
    )

def update_DecClassDef(source_DecClassDef : DecClassDef,
    decs : Union[decorators | None, SourceFlag] = SourceFlag(),
    class_def : Union[ClassDef | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DecClassDef:
    return DecClassDef(
        source_DecClassDef.decs if isinstance(decs, SourceFlag) else decs,
        source_DecClassDef.class_def if isinstance(class_def, SourceFlag) else class_def,
        source_DecClassDef.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DecClassDef.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ReturnSomething(stmt):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ReturnSomething(self)

def make_ReturnSomething(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return ReturnSomething(
        content,
        source_start,
        source_end
    )

def update_ReturnSomething(source_ReturnSomething : ReturnSomething,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ReturnSomething:
    return ReturnSomething(
        source_ReturnSomething.content if isinstance(content, SourceFlag) else content,
        source_ReturnSomething.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ReturnSomething.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Return(stmt):
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Return(self)

def make_Return(
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Return(
        source_start,
        source_end
    )

def update_Return(source_Return : Return,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Return:
    return Return(
        source_Return.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Return.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Delete(stmt):
    targets : comma_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Delete(self)

def make_Delete(
    targets : comma_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Delete(
        targets,
        source_start,
        source_end
    )

def update_Delete(source_Delete : Delete,
    targets : Union[comma_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Delete:
    return Delete(
        source_Delete.targets if isinstance(targets, SourceFlag) else targets,
        source_Delete.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Delete.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Assign(stmt):
    targets : target_exprs | None
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assign(self)

def make_Assign(
    targets : target_exprs | None, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Assign(
        targets,
        content,
        source_start,
        source_end
    )

def update_Assign(source_Assign : Assign,
    targets : Union[target_exprs | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Assign:
    return Assign(
        source_Assign.targets if isinstance(targets, SourceFlag) else targets,
        source_Assign.content if isinstance(content, SourceFlag) else content,
        source_Assign.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Assign.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AugAssign(stmt):
    target : expr | None
    op : bin_rator | None
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AugAssign(self)

def make_AugAssign(
    target : expr | None, 
    op : bin_rator | None, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AugAssign(
        target,
        op,
        content,
        source_start,
        source_end
    )

def update_AugAssign(source_AugAssign : AugAssign,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    op : Union[bin_rator | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AugAssign:
    return AugAssign(
        source_AugAssign.target if isinstance(target, SourceFlag) else target,
        source_AugAssign.op if isinstance(op, SourceFlag) else op,
        source_AugAssign.content if isinstance(content, SourceFlag) else content,
        source_AugAssign.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AugAssign.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AnnoAssign(stmt):
    target : expr | None
    anno : expr | None
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoAssign(self)

def make_AnnoAssign(
    target : expr | None, 
    anno : expr | None, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AnnoAssign(
        target,
        anno,
        content,
        source_start,
        source_end
    )

def update_AnnoAssign(source_AnnoAssign : AnnoAssign,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    anno : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AnnoAssign:
    return AnnoAssign(
        source_AnnoAssign.target if isinstance(target, SourceFlag) else target,
        source_AnnoAssign.anno if isinstance(anno, SourceFlag) else anno,
        source_AnnoAssign.content if isinstance(content, SourceFlag) else content,
        source_AnnoAssign.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AnnoAssign.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AnnoDeclar(stmt):
    target : expr | None
    anno : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AnnoDeclar(self)

def make_AnnoDeclar(
    target : expr | None, 
    anno : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AnnoDeclar(
        target,
        anno,
        source_start,
        source_end
    )

def update_AnnoDeclar(source_AnnoDeclar : AnnoDeclar,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    anno : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AnnoDeclar:
    return AnnoDeclar(
        source_AnnoDeclar.target if isinstance(target, SourceFlag) else target,
        source_AnnoDeclar.anno if isinstance(anno, SourceFlag) else anno,
        source_AnnoDeclar.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AnnoDeclar.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class For(stmt):
    target : expr | None
    iter : expr | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_For(self)

def make_For(
    target : expr | None, 
    iter : expr | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return For(
        target,
        iter,
        comment,
        body,
        source_start,
        source_end
    )

def update_For(source_For : For,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> For:
    return For(
        source_For.target if isinstance(target, SourceFlag) else target,
        source_For.iter if isinstance(iter, SourceFlag) else iter,
        source_For.comment if isinstance(comment, SourceFlag) else comment,
        source_For.body if isinstance(body, SourceFlag) else body,
        source_For.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_For.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ForElse(stmt):
    target : expr | None
    iter : expr | None
    comment : str
    body : statements | None
    orelse : ElseBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ForElse(self)

def make_ForElse(
    target : expr | None, 
    iter : expr | None, 
    comment : str, 
    body : statements | None, 
    orelse : ElseBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return ForElse(
        target,
        iter,
        comment,
        body,
        orelse,
        source_start,
        source_end
    )

def update_ForElse(source_ForElse : ForElse,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ForElse:
    return ForElse(
        source_ForElse.target if isinstance(target, SourceFlag) else target,
        source_ForElse.iter if isinstance(iter, SourceFlag) else iter,
        source_ForElse.comment if isinstance(comment, SourceFlag) else comment,
        source_ForElse.body if isinstance(body, SourceFlag) else body,
        source_ForElse.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_ForElse.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ForElse.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AsyncFor(stmt):
    target : expr | None
    iter : expr | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncFor(self)

def make_AsyncFor(
    target : expr | None, 
    iter : expr | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AsyncFor(
        target,
        iter,
        comment,
        body,
        source_start,
        source_end
    )

def update_AsyncFor(source_AsyncFor : AsyncFor,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AsyncFor:
    return AsyncFor(
        source_AsyncFor.target if isinstance(target, SourceFlag) else target,
        source_AsyncFor.iter if isinstance(iter, SourceFlag) else iter,
        source_AsyncFor.comment if isinstance(comment, SourceFlag) else comment,
        source_AsyncFor.body if isinstance(body, SourceFlag) else body,
        source_AsyncFor.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AsyncFor.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AsyncForElse(stmt):
    target : expr | None
    iter : expr | None
    comment : str
    body : statements | None
    orelse : ElseBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncForElse(self)

def make_AsyncForElse(
    target : expr | None, 
    iter : expr | None, 
    comment : str, 
    body : statements | None, 
    orelse : ElseBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AsyncForElse(
        target,
        iter,
        comment,
        body,
        orelse,
        source_start,
        source_end
    )

def update_AsyncForElse(source_AsyncForElse : AsyncForElse,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    iter : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AsyncForElse:
    return AsyncForElse(
        source_AsyncForElse.target if isinstance(target, SourceFlag) else target,
        source_AsyncForElse.iter if isinstance(iter, SourceFlag) else iter,
        source_AsyncForElse.comment if isinstance(comment, SourceFlag) else comment,
        source_AsyncForElse.body if isinstance(body, SourceFlag) else body,
        source_AsyncForElse.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_AsyncForElse.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AsyncForElse.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class While(stmt):
    test : expr | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_While(self)

def make_While(
    test : expr | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return While(
        test,
        comment,
        body,
        source_start,
        source_end
    )

def update_While(source_While : While,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> While:
    return While(
        source_While.test if isinstance(test, SourceFlag) else test,
        source_While.comment if isinstance(comment, SourceFlag) else comment,
        source_While.body if isinstance(body, SourceFlag) else body,
        source_While.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_While.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class WhileElse(stmt):
    test : expr | None
    comment : str
    body : statements | None
    orelse : ElseBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_WhileElse(self)

def make_WhileElse(
    test : expr | None, 
    comment : str, 
    body : statements | None, 
    orelse : ElseBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return WhileElse(
        test,
        comment,
        body,
        orelse,
        source_start,
        source_end
    )

def update_WhileElse(source_WhileElse : WhileElse,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> WhileElse:
    return WhileElse(
        source_WhileElse.test if isinstance(test, SourceFlag) else test,
        source_WhileElse.comment if isinstance(comment, SourceFlag) else comment,
        source_WhileElse.body if isinstance(body, SourceFlag) else body,
        source_WhileElse.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_WhileElse.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_WhileElse.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class If(stmt):
    test : expr | None
    comment : str
    body : statements | None
    orelse : conditions | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_If(self)

def make_If(
    test : expr | None, 
    comment : str, 
    body : statements | None, 
    orelse : conditions | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return If(
        test,
        comment,
        body,
        orelse,
        source_start,
        source_end
    )

def update_If(source_If : If,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    orelse : Union[conditions | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> If:
    return If(
        source_If.test if isinstance(test, SourceFlag) else test,
        source_If.comment if isinstance(comment, SourceFlag) else comment,
        source_If.body if isinstance(body, SourceFlag) else body,
        source_If.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_If.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_If.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class With(stmt):
    items : sequence_with_item | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_With(self)

def make_With(
    items : sequence_with_item | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return With(
        items,
        comment,
        body,
        source_start,
        source_end
    )

def update_With(source_With : With,
    items : Union[sequence_with_item | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> With:
    return With(
        source_With.items if isinstance(items, SourceFlag) else items,
        source_With.comment if isinstance(comment, SourceFlag) else comment,
        source_With.body if isinstance(body, SourceFlag) else body,
        source_With.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_With.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AsyncWith(stmt):
    items : sequence_with_item | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AsyncWith(self)

def make_AsyncWith(
    items : sequence_with_item | None, 
    comment : str, 
    body : statements | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AsyncWith(
        items,
        comment,
        body,
        source_start,
        source_end
    )

def update_AsyncWith(source_AsyncWith : AsyncWith,
    items : Union[sequence_with_item | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AsyncWith:
    return AsyncWith(
        source_AsyncWith.items if isinstance(items, SourceFlag) else items,
        source_AsyncWith.comment if isinstance(comment, SourceFlag) else comment,
        source_AsyncWith.body if isinstance(body, SourceFlag) else body,
        source_AsyncWith.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AsyncWith.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Raise(stmt):
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Raise(self)

def make_Raise(
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Raise(
        source_start,
        source_end
    )

def update_Raise(source_Raise : Raise,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Raise:
    return Raise(
        source_Raise.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Raise.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class RaiseExc(stmt):
    exc : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseExc(self)

def make_RaiseExc(
    exc : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return RaiseExc(
        exc,
        source_start,
        source_end
    )

def update_RaiseExc(source_RaiseExc : RaiseExc,
    exc : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> RaiseExc:
    return RaiseExc(
        source_RaiseExc.exc if isinstance(exc, SourceFlag) else exc,
        source_RaiseExc.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_RaiseExc.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class RaiseFrom(stmt):
    exc : expr | None
    caus : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_RaiseFrom(self)

def make_RaiseFrom(
    exc : expr | None, 
    caus : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return RaiseFrom(
        exc,
        caus,
        source_start,
        source_end
    )

def update_RaiseFrom(source_RaiseFrom : RaiseFrom,
    exc : Union[expr | None, SourceFlag] = SourceFlag(),
    caus : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> RaiseFrom:
    return RaiseFrom(
        source_RaiseFrom.exc if isinstance(exc, SourceFlag) else exc,
        source_RaiseFrom.caus if isinstance(caus, SourceFlag) else caus,
        source_RaiseFrom.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_RaiseFrom.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Try(stmt):
    comment : str
    body : statements | None
    handlers : sequence_ExceptHandler | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Try(self)

def make_Try(
    comment : str, 
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Try(
        comment,
        body,
        handlers,
        source_start,
        source_end
    )

def update_Try(source_Try : Try,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Try:
    return Try(
        source_Try.comment if isinstance(comment, SourceFlag) else comment,
        source_Try.body if isinstance(body, SourceFlag) else body,
        source_Try.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_Try.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Try.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TryElse(stmt):
    comment : str
    body : statements | None
    handlers : sequence_ExceptHandler | None
    orelse : ElseBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElse(self)

def make_TryElse(
    comment : str, 
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    orelse : ElseBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return TryElse(
        comment,
        body,
        handlers,
        orelse,
        source_start,
        source_end
    )

def update_TryElse(source_TryElse : TryElse,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TryElse:
    return TryElse(
        source_TryElse.comment if isinstance(comment, SourceFlag) else comment,
        source_TryElse.body if isinstance(body, SourceFlag) else body,
        source_TryElse.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryElse.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_TryElse.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TryElse.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TryExceptFin(stmt):
    comment : str
    body : statements | None
    handlers : sequence_ExceptHandler | None
    fin : FinallyBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryExceptFin(self)

def make_TryExceptFin(
    comment : str, 
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    fin : FinallyBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return TryExceptFin(
        comment,
        body,
        handlers,
        fin,
        source_start,
        source_end
    )

def update_TryExceptFin(source_TryExceptFin : TryExceptFin,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TryExceptFin:
    return TryExceptFin(
        source_TryExceptFin.comment if isinstance(comment, SourceFlag) else comment,
        source_TryExceptFin.body if isinstance(body, SourceFlag) else body,
        source_TryExceptFin.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryExceptFin.fin if isinstance(fin, SourceFlag) else fin,
        source_TryExceptFin.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TryExceptFin.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TryFin(stmt):
    comment : str
    body : statements | None
    fin : FinallyBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryFin(self)

def make_TryFin(
    comment : str, 
    body : statements | None, 
    fin : FinallyBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return TryFin(
        comment,
        body,
        fin,
        source_start,
        source_end
    )

def update_TryFin(source_TryFin : TryFin,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TryFin:
    return TryFin(
        source_TryFin.comment if isinstance(comment, SourceFlag) else comment,
        source_TryFin.body if isinstance(body, SourceFlag) else body,
        source_TryFin.fin if isinstance(fin, SourceFlag) else fin,
        source_TryFin.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TryFin.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class TryElseFin(stmt):
    comment : str
    body : statements | None
    handlers : sequence_ExceptHandler | None
    orelse : ElseBlock | None
    fin : FinallyBlock | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_TryElseFin(self)

def make_TryElseFin(
    comment : str, 
    body : statements | None, 
    handlers : sequence_ExceptHandler | None, 
    orelse : ElseBlock | None, 
    fin : FinallyBlock | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return TryElseFin(
        comment,
        body,
        handlers,
        orelse,
        fin,
        source_start,
        source_end
    )

def update_TryElseFin(source_TryElseFin : TryElseFin,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    handlers : Union[sequence_ExceptHandler | None, SourceFlag] = SourceFlag(),
    orelse : Union[ElseBlock | None, SourceFlag] = SourceFlag(),
    fin : Union[FinallyBlock | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> TryElseFin:
    return TryElseFin(
        source_TryElseFin.comment if isinstance(comment, SourceFlag) else comment,
        source_TryElseFin.body if isinstance(body, SourceFlag) else body,
        source_TryElseFin.handlers if isinstance(handlers, SourceFlag) else handlers,
        source_TryElseFin.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_TryElseFin.fin if isinstance(fin, SourceFlag) else fin,
        source_TryElseFin.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_TryElseFin.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Assert(stmt):
    test : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Assert(self)

def make_Assert(
    test : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Assert(
        test,
        source_start,
        source_end
    )

def update_Assert(source_Assert : Assert,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Assert:
    return Assert(
        source_Assert.test if isinstance(test, SourceFlag) else test,
        source_Assert.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Assert.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AssertMsg(stmt):
    test : expr | None
    msg : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_AssertMsg(self)

def make_AssertMsg(
    test : expr | None, 
    msg : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return AssertMsg(
        test,
        msg,
        source_start,
        source_end
    )

def update_AssertMsg(source_AssertMsg : AssertMsg,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    msg : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AssertMsg:
    return AssertMsg(
        source_AssertMsg.test if isinstance(test, SourceFlag) else test,
        source_AssertMsg.msg if isinstance(msg, SourceFlag) else msg,
        source_AssertMsg.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AssertMsg.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Import(stmt):
    names : sequence_import_name | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Import(self)

def make_Import(
    names : sequence_import_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Import(
        names,
        source_start,
        source_end
    )

def update_Import(source_Import : Import,
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Import:
    return Import(
        source_Import.names if isinstance(names, SourceFlag) else names,
        source_Import.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Import.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ImportFrom(stmt):
    module : str
    names : sequence_import_name | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportFrom(self)

def make_ImportFrom(
    module : str, 
    names : sequence_import_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return ImportFrom(
        module,
        names,
        source_start,
        source_end
    )

def update_ImportFrom(source_ImportFrom : ImportFrom,
    module : Union[str, SourceFlag] = SourceFlag(),
    names : Union[sequence_import_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ImportFrom:
    return ImportFrom(
        source_ImportFrom.module if isinstance(module, SourceFlag) else module,
        source_ImportFrom.names if isinstance(names, SourceFlag) else names,
        source_ImportFrom.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ImportFrom.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ImportWildCard(stmt):
    module : str
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_ImportWildCard(self)

def make_ImportWildCard(
    module : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return ImportWildCard(
        module,
        source_start,
        source_end
    )

def update_ImportWildCard(source_ImportWildCard : ImportWildCard,
    module : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ImportWildCard:
    return ImportWildCard(
        source_ImportWildCard.module if isinstance(module, SourceFlag) else module,
        source_ImportWildCard.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ImportWildCard.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Global(stmt):
    names : sequence_name | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Global(self)

def make_Global(
    names : sequence_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Global(
        names,
        source_start,
        source_end
    )

def update_Global(source_Global : Global,
    names : Union[sequence_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Global:
    return Global(
        source_Global.names if isinstance(names, SourceFlag) else names,
        source_Global.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Global.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Nonlocal(stmt):
    names : sequence_name | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Nonlocal(self)

def make_Nonlocal(
    names : sequence_name | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Nonlocal(
        names,
        source_start,
        source_end
    )

def update_Nonlocal(source_Nonlocal : Nonlocal,
    names : Union[sequence_name | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Nonlocal:
    return Nonlocal(
        source_Nonlocal.names if isinstance(names, SourceFlag) else names,
        source_Nonlocal.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Nonlocal.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Expr(stmt):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Expr(self)

def make_Expr(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Expr(
        content,
        source_start,
        source_end
    )

def update_Expr(source_Expr : Expr,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Expr:
    return Expr(
        source_Expr.content if isinstance(content, SourceFlag) else content,
        source_Expr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Expr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Pass(stmt):
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Pass(self)

def make_Pass(
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Pass(
        source_start,
        source_end
    )

def update_Pass(source_Pass : Pass,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Pass:
    return Pass(
        source_Pass.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Pass.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Break(stmt):
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Break(self)

def make_Break(
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Break(
        source_start,
        source_end
    )

def update_Break(source_Break : Break,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Break:
    return Break(
        source_Break.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Break.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Continue(stmt):
    source_start : int
    source_end : int

    def match(self, handlers : StmtHandlers[T]) -> T:
        return handlers.case_Continue(self)

def make_Continue(
    source_start : int = 0, 
    source_end : int = 0
) -> stmt:
    return Continue(
        source_start,
        source_end
    )

def update_Continue(source_Continue : Continue,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Continue:
    return Continue(
        source_Continue.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Continue.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type stmt
@dataclass(frozen=True, eq=True)
class StmtHandlers(Generic[T]):
    case_Comment : Callable[[Comment], T]
    case_DecFunctionDef : Callable[[DecFunctionDef], T]
    case_DecClassDef : Callable[[DecClassDef], T]
    case_ReturnSomething : Callable[[ReturnSomething], T]
    case_Return : Callable[[Return], T]
    case_Delete : Callable[[Delete], T]
    case_Assign : Callable[[Assign], T]
    case_AugAssign : Callable[[AugAssign], T]
    case_AnnoAssign : Callable[[AnnoAssign], T]
    case_AnnoDeclar : Callable[[AnnoDeclar], T]
    case_For : Callable[[For], T]
    case_ForElse : Callable[[ForElse], T]
    case_AsyncFor : Callable[[AsyncFor], T]
    case_AsyncForElse : Callable[[AsyncForElse], T]
    case_While : Callable[[While], T]
    case_WhileElse : Callable[[WhileElse], T]
    case_If : Callable[[If], T]
    case_With : Callable[[With], T]
    case_AsyncWith : Callable[[AsyncWith], T]
    case_Raise : Callable[[Raise], T]
    case_RaiseExc : Callable[[RaiseExc], T]
    case_RaiseFrom : Callable[[RaiseFrom], T]
    case_Try : Callable[[Try], T]
    case_TryElse : Callable[[TryElse], T]
    case_TryExceptFin : Callable[[TryExceptFin], T]
    case_TryFin : Callable[[TryFin], T]
    case_TryElseFin : Callable[[TryElseFin], T]
    case_Assert : Callable[[Assert], T]
    case_AssertMsg : Callable[[AssertMsg], T]
    case_Import : Callable[[Import], T]
    case_ImportFrom : Callable[[ImportFrom], T]
    case_ImportWildCard : Callable[[ImportWildCard], T]
    case_Global : Callable[[Global], T]
    case_Nonlocal : Callable[[Nonlocal], T]
    case_Expr : Callable[[Expr], T]
    case_Pass : Callable[[Pass], T]
    case_Break : Callable[[Break], T]
    case_Continue : Callable[[Continue], T]


# matching for type stmt
def match_stmt(o : stmt, handlers : StmtHandlers[T]) -> T :
    return o.match(handlers)


stmt_union = Union[Comment, DecFunctionDef, DecClassDef, ReturnSomething, Return, Delete, Assign, AugAssign, AnnoAssign, AnnoDeclar, For, ForElse, AsyncFor, AsyncForElse, While, WhileElse, If, With, AsyncWith, Raise, RaiseExc, RaiseFrom, Try, TryElse, TryExceptFin, TryFin, TryElseFin, Assert, AssertMsg, Import, ImportFrom, ImportWildCard, Global, Nonlocal, Expr, Pass, Break, Continue]

# unguarding for type stmt
def unguard_stmt(o : stmt) -> stmt_union :
    return match_stmt(o, StmtHandlers(
        case_Comment = lambda x : x, 
        case_DecFunctionDef = lambda x : x, 
        case_DecClassDef = lambda x : x, 
        case_ReturnSomething = lambda x : x, 
        case_Return = lambda x : x, 
        case_Delete = lambda x : x, 
        case_Assign = lambda x : x, 
        case_AugAssign = lambda x : x, 
        case_AnnoAssign = lambda x : x, 
        case_AnnoDeclar = lambda x : x, 
        case_For = lambda x : x, 
        case_ForElse = lambda x : x, 
        case_AsyncFor = lambda x : x, 
        case_AsyncForElse = lambda x : x, 
        case_While = lambda x : x, 
        case_WhileElse = lambda x : x, 
        case_If = lambda x : x, 
        case_With = lambda x : x, 
        case_AsyncWith = lambda x : x, 
        case_Raise = lambda x : x, 
        case_RaiseExc = lambda x : x, 
        case_RaiseFrom = lambda x : x, 
        case_Try = lambda x : x, 
        case_TryElse = lambda x : x, 
        case_TryExceptFin = lambda x : x, 
        case_TryFin = lambda x : x, 
        case_TryElseFin = lambda x : x, 
        case_Assert = lambda x : x, 
        case_AssertMsg = lambda x : x, 
        case_Import = lambda x : x, 
        case_ImportFrom = lambda x : x, 
        case_ImportWildCard = lambda x : x, 
        case_Global = lambda x : x, 
        case_Nonlocal = lambda x : x, 
        case_Expr = lambda x : x, 
        case_Pass = lambda x : x, 
        case_Break = lambda x : x, 
        case_Continue = lambda x : x

    ))
    

# type expr
@dataclass(frozen=True, eq=True)
class expr(ABC):
    # @abstractmethod
    def match(self, handlers : ExprHandlers[T]) -> T:
        raise Exception()


# constructors for type expr

@dataclass(frozen=True, eq=True)
class ParenExpr(expr):
    pre_comment : str
    content : expr | None
    post_comment : str
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ParenExpr(self)

def make_ParenExpr(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return ParenExpr(
        pre_comment,
        content,
        post_comment,
        source_start,
        source_end
    )

def update_ParenExpr(source_ParenExpr : ParenExpr,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ParenExpr:
    return ParenExpr(
        source_ParenExpr.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ParenExpr.content if isinstance(content, SourceFlag) else content,
        source_ParenExpr.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ParenExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ParenExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class BoolOp(expr):
    left : expr | None
    pre_comment : str
    op : bool_rator | None
    post_comment : str
    right : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BoolOp(self)

def make_BoolOp(
    left : expr | None, 
    pre_comment : str, 
    op : bool_rator | None, 
    post_comment : str, 
    right : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return BoolOp(
        left,
        pre_comment,
        op,
        post_comment,
        right,
        source_start,
        source_end
    )

def update_BoolOp(source_BoolOp : BoolOp,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    op : Union[bool_rator | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    right : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> BoolOp:
    return BoolOp(
        source_BoolOp.left if isinstance(left, SourceFlag) else left,
        source_BoolOp.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_BoolOp.op if isinstance(op, SourceFlag) else op,
        source_BoolOp.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_BoolOp.right if isinstance(right, SourceFlag) else right,
        source_BoolOp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_BoolOp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class AssignExpr(expr):
    target : expr | None
    pre_comment : str
    post_comment : str
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_AssignExpr(self)

def make_AssignExpr(
    target : expr | None, 
    pre_comment : str, 
    post_comment : str, 
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return AssignExpr(
        target,
        pre_comment,
        post_comment,
        content,
        source_start,
        source_end
    )

def update_AssignExpr(source_AssignExpr : AssignExpr,
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AssignExpr:
    return AssignExpr(
        source_AssignExpr.target if isinstance(target, SourceFlag) else target,
        source_AssignExpr.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_AssignExpr.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_AssignExpr.content if isinstance(content, SourceFlag) else content,
        source_AssignExpr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AssignExpr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class BinOp(expr):
    left : expr | None
    pre_comment : str
    rator : bin_rator | None
    post_comment : str
    right : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_BinOp(self)

def make_BinOp(
    left : expr | None, 
    pre_comment : str, 
    rator : bin_rator | None, 
    post_comment : str, 
    right : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return BinOp(
        left,
        pre_comment,
        rator,
        post_comment,
        right,
        source_start,
        source_end
    )

def update_BinOp(source_BinOp : BinOp,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    rator : Union[bin_rator | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    right : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> BinOp:
    return BinOp(
        source_BinOp.left if isinstance(left, SourceFlag) else left,
        source_BinOp.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_BinOp.rator if isinstance(rator, SourceFlag) else rator,
        source_BinOp.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_BinOp.right if isinstance(right, SourceFlag) else right,
        source_BinOp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_BinOp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class UnaryOp(expr):
    rator : unary_rator | None
    comment : str
    rand : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_UnaryOp(self)

def make_UnaryOp(
    rator : unary_rator | None, 
    comment : str, 
    rand : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return UnaryOp(
        rator,
        comment,
        rand,
        source_start,
        source_end
    )

def update_UnaryOp(source_UnaryOp : UnaryOp,
    rator : Union[unary_rator | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    rand : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> UnaryOp:
    return UnaryOp(
        source_UnaryOp.rator if isinstance(rator, SourceFlag) else rator,
        source_UnaryOp.comment if isinstance(comment, SourceFlag) else comment,
        source_UnaryOp.rand if isinstance(rand, SourceFlag) else rand,
        source_UnaryOp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_UnaryOp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Lambda(expr):
    comment_a : str
    params : parameters | None
    comment_b : str
    comment_c : str
    body : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Lambda(self)

def make_Lambda(
    comment_a : str, 
    params : parameters | None, 
    comment_b : str, 
    comment_c : str, 
    body : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Lambda(
        comment_a,
        params,
        comment_b,
        comment_c,
        body,
        source_start,
        source_end
    )

def update_Lambda(source_Lambda : Lambda,
    comment_a : Union[str, SourceFlag] = SourceFlag(),
    params : Union[parameters | None, SourceFlag] = SourceFlag(),
    comment_b : Union[str, SourceFlag] = SourceFlag(),
    comment_c : Union[str, SourceFlag] = SourceFlag(),
    body : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Lambda:
    return Lambda(
        source_Lambda.comment_a if isinstance(comment_a, SourceFlag) else comment_a,
        source_Lambda.params if isinstance(params, SourceFlag) else params,
        source_Lambda.comment_b if isinstance(comment_b, SourceFlag) else comment_b,
        source_Lambda.comment_c if isinstance(comment_c, SourceFlag) else comment_c,
        source_Lambda.body if isinstance(body, SourceFlag) else body,
        source_Lambda.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Lambda.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class IfExp(expr):
    body : expr | None
    comment_a : str
    comment_b : str
    test : expr | None
    comment_c : str
    comment_d : str
    orelse : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_IfExp(self)

def make_IfExp(
    body : expr | None, 
    comment_a : str, 
    comment_b : str, 
    test : expr | None, 
    comment_c : str, 
    comment_d : str, 
    orelse : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return IfExp(
        body,
        comment_a,
        comment_b,
        test,
        comment_c,
        comment_d,
        orelse,
        source_start,
        source_end
    )

def update_IfExp(source_IfExp : IfExp,
    body : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_a : Union[str, SourceFlag] = SourceFlag(),
    comment_b : Union[str, SourceFlag] = SourceFlag(),
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_c : Union[str, SourceFlag] = SourceFlag(),
    comment_d : Union[str, SourceFlag] = SourceFlag(),
    orelse : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> IfExp:
    return IfExp(
        source_IfExp.body if isinstance(body, SourceFlag) else body,
        source_IfExp.comment_a if isinstance(comment_a, SourceFlag) else comment_a,
        source_IfExp.comment_b if isinstance(comment_b, SourceFlag) else comment_b,
        source_IfExp.test if isinstance(test, SourceFlag) else test,
        source_IfExp.comment_c if isinstance(comment_c, SourceFlag) else comment_c,
        source_IfExp.comment_d if isinstance(comment_d, SourceFlag) else comment_d,
        source_IfExp.orelse if isinstance(orelse, SourceFlag) else orelse,
        source_IfExp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_IfExp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Dictionary(expr):
    content : dictionary_content | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Dictionary(self)

def make_Dictionary(
    content : dictionary_content | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Dictionary(
        content,
        source_start,
        source_end
    )

def update_Dictionary(source_Dictionary : Dictionary,
    content : Union[dictionary_content | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Dictionary:
    return Dictionary(
        source_Dictionary.content if isinstance(content, SourceFlag) else content,
        source_Dictionary.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Dictionary.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class EmptyDictionary(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyDictionary(self)

def make_EmptyDictionary(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return EmptyDictionary(
        source_start,
        source_end
    )

def update_EmptyDictionary(source_EmptyDictionary : EmptyDictionary,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> EmptyDictionary:
    return EmptyDictionary(
        source_EmptyDictionary.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_EmptyDictionary.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Set(expr):
    content : comma_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Set(self)

def make_Set(
    content : comma_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Set(
        content,
        source_start,
        source_end
    )

def update_Set(source_Set : Set,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Set:
    return Set(
        source_Set.content if isinstance(content, SourceFlag) else content,
        source_Set.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Set.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ListComp(expr):
    pre_comment : str
    content : expr | None
    post_comment : str
    constraints : comprehension_constraints | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ListComp(self)

def make_ListComp(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    constraints : comprehension_constraints | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return ListComp(
        pre_comment,
        content,
        post_comment,
        constraints,
        source_start,
        source_end
    )

def update_ListComp(source_ListComp : ListComp,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ListComp:
    return ListComp(
        source_ListComp.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_ListComp.content if isinstance(content, SourceFlag) else content,
        source_ListComp.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_ListComp.constraints if isinstance(constraints, SourceFlag) else constraints,
        source_ListComp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ListComp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class SetComp(expr):
    pre_comment : str
    content : expr | None
    post_comment : str
    constraints : comprehension_constraints | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_SetComp(self)

def make_SetComp(
    pre_comment : str, 
    content : expr | None, 
    post_comment : str, 
    constraints : comprehension_constraints | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return SetComp(
        pre_comment,
        content,
        post_comment,
        constraints,
        source_start,
        source_end
    )

def update_SetComp(source_SetComp : SetComp,
    pre_comment : Union[str, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    post_comment : Union[str, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> SetComp:
    return SetComp(
        source_SetComp.pre_comment if isinstance(pre_comment, SourceFlag) else pre_comment,
        source_SetComp.content if isinstance(content, SourceFlag) else content,
        source_SetComp.post_comment if isinstance(post_comment, SourceFlag) else post_comment,
        source_SetComp.constraints if isinstance(constraints, SourceFlag) else constraints,
        source_SetComp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_SetComp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class DictionaryComp(expr):
    key : expr | None
    content : expr | None
    constraints : comprehension_constraints | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_DictionaryComp(self)

def make_DictionaryComp(
    key : expr | None, 
    content : expr | None, 
    constraints : comprehension_constraints | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return DictionaryComp(
        key,
        content,
        constraints,
        source_start,
        source_end
    )

def update_DictionaryComp(source_DictionaryComp : DictionaryComp,
    key : Union[expr | None, SourceFlag] = SourceFlag(),
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> DictionaryComp:
    return DictionaryComp(
        source_DictionaryComp.key if isinstance(key, SourceFlag) else key,
        source_DictionaryComp.content if isinstance(content, SourceFlag) else content,
        source_DictionaryComp.constraints if isinstance(constraints, SourceFlag) else constraints,
        source_DictionaryComp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_DictionaryComp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class GeneratorExp(expr):
    content : expr | None
    constraints : comprehension_constraints | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_GeneratorExp(self)

def make_GeneratorExp(
    content : expr | None, 
    constraints : comprehension_constraints | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return GeneratorExp(
        content,
        constraints,
        source_start,
        source_end
    )

def update_GeneratorExp(source_GeneratorExp : GeneratorExp,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    constraints : Union[comprehension_constraints | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> GeneratorExp:
    return GeneratorExp(
        source_GeneratorExp.content if isinstance(content, SourceFlag) else content,
        source_GeneratorExp.constraints if isinstance(constraints, SourceFlag) else constraints,
        source_GeneratorExp.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_GeneratorExp.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Await(expr):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Await(self)

def make_Await(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Await(
        content,
        source_start,
        source_end
    )

def update_Await(source_Await : Await,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Await:
    return Await(
        source_Await.content if isinstance(content, SourceFlag) else content,
        source_Await.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Await.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class YieldNothing(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldNothing(self)

def make_YieldNothing(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return YieldNothing(
        source_start,
        source_end
    )

def update_YieldNothing(source_YieldNothing : YieldNothing,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> YieldNothing:
    return YieldNothing(
        source_YieldNothing.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_YieldNothing.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Yield(expr):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Yield(self)

def make_Yield(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Yield(
        content,
        source_start,
        source_end
    )

def update_Yield(source_Yield : Yield,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Yield:
    return Yield(
        source_Yield.content if isinstance(content, SourceFlag) else content,
        source_Yield.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Yield.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class YieldFrom(expr):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_YieldFrom(self)

def make_YieldFrom(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return YieldFrom(
        content,
        source_start,
        source_end
    )

def update_YieldFrom(source_YieldFrom : YieldFrom,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> YieldFrom:
    return YieldFrom(
        source_YieldFrom.content if isinstance(content, SourceFlag) else content,
        source_YieldFrom.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_YieldFrom.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Compare(expr):
    left : expr | None
    comps : comparisons | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Compare(self)

def make_Compare(
    left : expr | None, 
    comps : comparisons | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Compare(
        left,
        comps,
        source_start,
        source_end
    )

def update_Compare(source_Compare : Compare,
    left : Union[expr | None, SourceFlag] = SourceFlag(),
    comps : Union[comparisons | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Compare:
    return Compare(
        source_Compare.left if isinstance(left, SourceFlag) else left,
        source_Compare.comps if isinstance(comps, SourceFlag) else comps,
        source_Compare.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Compare.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Call(expr):
    func : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Call(self)

def make_Call(
    func : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Call(
        func,
        source_start,
        source_end
    )

def update_Call(source_Call : Call,
    func : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Call:
    return Call(
        source_Call.func if isinstance(func, SourceFlag) else func,
        source_Call.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Call.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class CallArgs(expr):
    func : expr | None
    args : arguments | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_CallArgs(self)

def make_CallArgs(
    func : expr | None, 
    args : arguments | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return CallArgs(
        func,
        args,
        source_start,
        source_end
    )

def update_CallArgs(source_CallArgs : CallArgs,
    func : Union[expr | None, SourceFlag] = SourceFlag(),
    args : Union[arguments | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> CallArgs:
    return CallArgs(
        source_CallArgs.func if isinstance(func, SourceFlag) else func,
        source_CallArgs.args if isinstance(args, SourceFlag) else args,
        source_CallArgs.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_CallArgs.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Integer(expr):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Integer(self)

def make_Integer(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Integer(
        content,
        source_start,
        source_end
    )

def update_Integer(source_Integer : Integer,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Integer:
    return Integer(
        source_Integer.content if isinstance(content, SourceFlag) else content,
        source_Integer.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Integer.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Float(expr):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Float(self)

def make_Float(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Float(
        content,
        source_start,
        source_end
    )

def update_Float(source_Float : Float,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Float:
    return Float(
        source_Float.content if isinstance(content, SourceFlag) else content,
        source_Float.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Float.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class ConcatString(expr):
    content : sequence_string | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_ConcatString(self)

def make_ConcatString(
    content : sequence_string | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return ConcatString(
        content,
        source_start,
        source_end
    )

def update_ConcatString(source_ConcatString : ConcatString,
    content : Union[sequence_string | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ConcatString:
    return ConcatString(
        source_ConcatString.content if isinstance(content, SourceFlag) else content,
        source_ConcatString.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_ConcatString.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class True_(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_True_(self)

def make_True_(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return True_(
        source_start,
        source_end
    )

def update_True_(source_True_ : True_,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> True_:
    return True_(
        source_True_.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_True_.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class False_(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_False_(self)

def make_False_(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return False_(
        source_start,
        source_end
    )

def update_False_(source_False_ : False_,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> False_:
    return False_(
        source_False_.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_False_.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class None_(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_None_(self)

def make_None_(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return None_(
        source_start,
        source_end
    )

def update_None_(source_None_ : None_,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> None_:
    return None_(
        source_None_.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_None_.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Ellip(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Ellip(self)

def make_Ellip(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Ellip(
        source_start,
        source_end
    )

def update_Ellip(source_Ellip : Ellip,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Ellip:
    return Ellip(
        source_Ellip.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Ellip.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Attribute(expr):
    content : expr | None
    name : str
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Attribute(self)

def make_Attribute(
    content : expr | None, 
    name : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Attribute(
        content,
        name,
        source_start,
        source_end
    )

def update_Attribute(source_Attribute : Attribute,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    name : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Attribute:
    return Attribute(
        source_Attribute.content if isinstance(content, SourceFlag) else content,
        source_Attribute.name if isinstance(name, SourceFlag) else name,
        source_Attribute.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Attribute.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Subscript(expr):
    content : expr | None
    slice : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Subscript(self)

def make_Subscript(
    content : expr | None, 
    slice : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Subscript(
        content,
        slice,
        source_start,
        source_end
    )

def update_Subscript(source_Subscript : Subscript,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    slice : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Subscript:
    return Subscript(
        source_Subscript.content if isinstance(content, SourceFlag) else content,
        source_Subscript.slice if isinstance(slice, SourceFlag) else slice,
        source_Subscript.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Subscript.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Starred(expr):
    content : expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Starred(self)

def make_Starred(
    content : expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Starred(
        content,
        source_start,
        source_end
    )

def update_Starred(source_Starred : Starred,
    content : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Starred:
    return Starred(
        source_Starred.content if isinstance(content, SourceFlag) else content,
        source_Starred.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Starred.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Name(expr):
    content : str
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Name(self)

def make_Name(
    content : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Name(
        content,
        source_start,
        source_end
    )

def update_Name(source_Name : Name,
    content : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Name:
    return Name(
        source_Name.content if isinstance(content, SourceFlag) else content,
        source_Name.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Name.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class List(expr):
    content : comma_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_List(self)

def make_List(
    content : comma_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return List(
        content,
        source_start,
        source_end
    )

def update_List(source_List : List,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> List:
    return List(
        source_List.content if isinstance(content, SourceFlag) else content,
        source_List.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_List.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class EmptyList(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyList(self)

def make_EmptyList(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return EmptyList(
        source_start,
        source_end
    )

def update_EmptyList(source_EmptyList : EmptyList,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> EmptyList:
    return EmptyList(
        source_EmptyList.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_EmptyList.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Tuple(expr):
    content : comma_exprs | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Tuple(self)

def make_Tuple(
    content : comma_exprs | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Tuple(
        content,
        source_start,
        source_end
    )

def update_Tuple(source_Tuple : Tuple,
    content : Union[comma_exprs | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Tuple:
    return Tuple(
        source_Tuple.content if isinstance(content, SourceFlag) else content,
        source_Tuple.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Tuple.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class EmptyTuple(expr):
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_EmptyTuple(self)

def make_EmptyTuple(
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return EmptyTuple(
        source_start,
        source_end
    )

def update_EmptyTuple(source_EmptyTuple : EmptyTuple,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> EmptyTuple:
    return EmptyTuple(
        source_EmptyTuple.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_EmptyTuple.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Slice(expr):
    lower : option_expr | None
    upper : option_expr | None
    step : option_expr | None
    source_start : int
    source_end : int

    def match(self, handlers : ExprHandlers[T]) -> T:
        return handlers.case_Slice(self)

def make_Slice(
    lower : option_expr | None, 
    upper : option_expr | None, 
    step : option_expr | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> expr:
    return Slice(
        lower,
        upper,
        step,
        source_start,
        source_end
    )

def update_Slice(source_Slice : Slice,
    lower : Union[option_expr | None, SourceFlag] = SourceFlag(),
    upper : Union[option_expr | None, SourceFlag] = SourceFlag(),
    step : Union[option_expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Slice:
    return Slice(
        source_Slice.lower if isinstance(lower, SourceFlag) else lower,
        source_Slice.upper if isinstance(upper, SourceFlag) else upper,
        source_Slice.step if isinstance(step, SourceFlag) else step,
        source_Slice.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Slice.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type expr
@dataclass(frozen=True, eq=True)
class ExprHandlers(Generic[T]):
    case_ParenExpr : Callable[[ParenExpr], T]
    case_BoolOp : Callable[[BoolOp], T]
    case_AssignExpr : Callable[[AssignExpr], T]
    case_BinOp : Callable[[BinOp], T]
    case_UnaryOp : Callable[[UnaryOp], T]
    case_Lambda : Callable[[Lambda], T]
    case_IfExp : Callable[[IfExp], T]
    case_Dictionary : Callable[[Dictionary], T]
    case_EmptyDictionary : Callable[[EmptyDictionary], T]
    case_Set : Callable[[Set], T]
    case_ListComp : Callable[[ListComp], T]
    case_SetComp : Callable[[SetComp], T]
    case_DictionaryComp : Callable[[DictionaryComp], T]
    case_GeneratorExp : Callable[[GeneratorExp], T]
    case_Await : Callable[[Await], T]
    case_YieldNothing : Callable[[YieldNothing], T]
    case_Yield : Callable[[Yield], T]
    case_YieldFrom : Callable[[YieldFrom], T]
    case_Compare : Callable[[Compare], T]
    case_Call : Callable[[Call], T]
    case_CallArgs : Callable[[CallArgs], T]
    case_Integer : Callable[[Integer], T]
    case_Float : Callable[[Float], T]
    case_ConcatString : Callable[[ConcatString], T]
    case_True_ : Callable[[True_], T]
    case_False_ : Callable[[False_], T]
    case_None_ : Callable[[None_], T]
    case_Ellip : Callable[[Ellip], T]
    case_Attribute : Callable[[Attribute], T]
    case_Subscript : Callable[[Subscript], T]
    case_Starred : Callable[[Starred], T]
    case_Name : Callable[[Name], T]
    case_List : Callable[[List], T]
    case_EmptyList : Callable[[EmptyList], T]
    case_Tuple : Callable[[Tuple], T]
    case_EmptyTuple : Callable[[EmptyTuple], T]
    case_Slice : Callable[[Slice], T]


# matching for type expr
def match_expr(o : expr, handlers : ExprHandlers[T]) -> T :
    return o.match(handlers)


expr_union = Union[ParenExpr, BoolOp, AssignExpr, BinOp, UnaryOp, Lambda, IfExp, Dictionary, EmptyDictionary, Set, ListComp, SetComp, DictionaryComp, GeneratorExp, Await, YieldNothing, Yield, YieldFrom, Compare, Call, CallArgs, Integer, Float, ConcatString, True_, False_, None_, Ellip, Attribute, Subscript, Starred, Name, List, EmptyList, Tuple, EmptyTuple, Slice]

# unguarding for type expr
def unguard_expr(o : expr) -> expr_union :
    return match_expr(o, ExprHandlers(
        case_ParenExpr = lambda x : x, 
        case_BoolOp = lambda x : x, 
        case_AssignExpr = lambda x : x, 
        case_BinOp = lambda x : x, 
        case_UnaryOp = lambda x : x, 
        case_Lambda = lambda x : x, 
        case_IfExp = lambda x : x, 
        case_Dictionary = lambda x : x, 
        case_EmptyDictionary = lambda x : x, 
        case_Set = lambda x : x, 
        case_ListComp = lambda x : x, 
        case_SetComp = lambda x : x, 
        case_DictionaryComp = lambda x : x, 
        case_GeneratorExp = lambda x : x, 
        case_Await = lambda x : x, 
        case_YieldNothing = lambda x : x, 
        case_Yield = lambda x : x, 
        case_YieldFrom = lambda x : x, 
        case_Compare = lambda x : x, 
        case_Call = lambda x : x, 
        case_CallArgs = lambda x : x, 
        case_Integer = lambda x : x, 
        case_Float = lambda x : x, 
        case_ConcatString = lambda x : x, 
        case_True_ = lambda x : x, 
        case_False_ = lambda x : x, 
        case_None_ = lambda x : x, 
        case_Ellip = lambda x : x, 
        case_Attribute = lambda x : x, 
        case_Subscript = lambda x : x, 
        case_Starred = lambda x : x, 
        case_Name = lambda x : x, 
        case_List = lambda x : x, 
        case_EmptyList = lambda x : x, 
        case_Tuple = lambda x : x, 
        case_EmptyTuple = lambda x : x, 
        case_Slice = lambda x : x

    ))
    

# type bool_rator
@dataclass(frozen=True, eq=True)
class bool_rator(ABC):
    # @abstractmethod
    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type bool_rator

@dataclass(frozen=True, eq=True)
class And(bool_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        return handlers.case_And(self)

def make_And(
    source_start : int = 0, 
    source_end : int = 0
) -> bool_rator:
    return And(
        source_start,
        source_end
    )

def update_And(source_And : And,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> And:
    return And(
        source_And.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_And.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Or(bool_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BoolRatorHandlers[T]) -> T:
        return handlers.case_Or(self)

def make_Or(
    source_start : int = 0, 
    source_end : int = 0
) -> bool_rator:
    return Or(
        source_start,
        source_end
    )

def update_Or(source_Or : Or,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Or:
    return Or(
        source_Or.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Or.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type bool_rator
@dataclass(frozen=True, eq=True)
class BoolRatorHandlers(Generic[T]):
    case_And : Callable[[And], T]
    case_Or : Callable[[Or], T]


# matching for type bool_rator
def match_bool_rator(o : bool_rator, handlers : BoolRatorHandlers[T]) -> T :
    return o.match(handlers)


bool_rator_union = Union[And, Or]

# unguarding for type bool_rator
def unguard_bool_rator(o : bool_rator) -> bool_rator_union :
    return match_bool_rator(o, BoolRatorHandlers(
        case_And = lambda x : x, 
        case_Or = lambda x : x

    ))
    

# type bin_rator
@dataclass(frozen=True, eq=True)
class bin_rator(ABC):
    # @abstractmethod
    def match(self, handlers : BinRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type bin_rator

@dataclass(frozen=True, eq=True)
class Add(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Add(self)

def make_Add(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Add(
        source_start,
        source_end
    )

def update_Add(source_Add : Add,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Add:
    return Add(
        source_Add.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Add.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Sub(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Sub(self)

def make_Sub(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Sub(
        source_start,
        source_end
    )

def update_Sub(source_Sub : Sub,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Sub:
    return Sub(
        source_Sub.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Sub.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Mult(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Mult(self)

def make_Mult(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Mult(
        source_start,
        source_end
    )

def update_Mult(source_Mult : Mult,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Mult:
    return Mult(
        source_Mult.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Mult.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class MatMult(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_MatMult(self)

def make_MatMult(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return MatMult(
        source_start,
        source_end
    )

def update_MatMult(source_MatMult : MatMult,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> MatMult:
    return MatMult(
        source_MatMult.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_MatMult.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Div(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Div(self)

def make_Div(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Div(
        source_start,
        source_end
    )

def update_Div(source_Div : Div,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Div:
    return Div(
        source_Div.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Div.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Mod(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Mod(self)

def make_Mod(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Mod(
        source_start,
        source_end
    )

def update_Mod(source_Mod : Mod,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Mod:
    return Mod(
        source_Mod.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Mod.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Pow(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_Pow(self)

def make_Pow(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return Pow(
        source_start,
        source_end
    )

def update_Pow(source_Pow : Pow,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Pow:
    return Pow(
        source_Pow.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Pow.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class LShift(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_LShift(self)

def make_LShift(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return LShift(
        source_start,
        source_end
    )

def update_LShift(source_LShift : LShift,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> LShift:
    return LShift(
        source_LShift.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_LShift.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class RShift(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_RShift(self)

def make_RShift(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return RShift(
        source_start,
        source_end
    )

def update_RShift(source_RShift : RShift,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> RShift:
    return RShift(
        source_RShift.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_RShift.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class BitOr(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitOr(self)

def make_BitOr(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return BitOr(
        source_start,
        source_end
    )

def update_BitOr(source_BitOr : BitOr,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> BitOr:
    return BitOr(
        source_BitOr.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_BitOr.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class BitXor(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitXor(self)

def make_BitXor(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return BitXor(
        source_start,
        source_end
    )

def update_BitXor(source_BitXor : BitXor,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> BitXor:
    return BitXor(
        source_BitXor.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_BitXor.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class BitAnd(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_BitAnd(self)

def make_BitAnd(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return BitAnd(
        source_start,
        source_end
    )

def update_BitAnd(source_BitAnd : BitAnd,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> BitAnd:
    return BitAnd(
        source_BitAnd.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_BitAnd.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class FloorDiv(bin_rator):
    source_start : int
    source_end : int

    def match(self, handlers : BinRatorHandlers[T]) -> T:
        return handlers.case_FloorDiv(self)

def make_FloorDiv(
    source_start : int = 0, 
    source_end : int = 0
) -> bin_rator:
    return FloorDiv(
        source_start,
        source_end
    )

def update_FloorDiv(source_FloorDiv : FloorDiv,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> FloorDiv:
    return FloorDiv(
        source_FloorDiv.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_FloorDiv.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type bin_rator
@dataclass(frozen=True, eq=True)
class BinRatorHandlers(Generic[T]):
    case_Add : Callable[[Add], T]
    case_Sub : Callable[[Sub], T]
    case_Mult : Callable[[Mult], T]
    case_MatMult : Callable[[MatMult], T]
    case_Div : Callable[[Div], T]
    case_Mod : Callable[[Mod], T]
    case_Pow : Callable[[Pow], T]
    case_LShift : Callable[[LShift], T]
    case_RShift : Callable[[RShift], T]
    case_BitOr : Callable[[BitOr], T]
    case_BitXor : Callable[[BitXor], T]
    case_BitAnd : Callable[[BitAnd], T]
    case_FloorDiv : Callable[[FloorDiv], T]


# matching for type bin_rator
def match_bin_rator(o : bin_rator, handlers : BinRatorHandlers[T]) -> T :
    return o.match(handlers)


bin_rator_union = Union[Add, Sub, Mult, MatMult, Div, Mod, Pow, LShift, RShift, BitOr, BitXor, BitAnd, FloorDiv]

# unguarding for type bin_rator
def unguard_bin_rator(o : bin_rator) -> bin_rator_union :
    return match_bin_rator(o, BinRatorHandlers(
        case_Add = lambda x : x, 
        case_Sub = lambda x : x, 
        case_Mult = lambda x : x, 
        case_MatMult = lambda x : x, 
        case_Div = lambda x : x, 
        case_Mod = lambda x : x, 
        case_Pow = lambda x : x, 
        case_LShift = lambda x : x, 
        case_RShift = lambda x : x, 
        case_BitOr = lambda x : x, 
        case_BitXor = lambda x : x, 
        case_BitAnd = lambda x : x, 
        case_FloorDiv = lambda x : x

    ))
    

# type unary_rator
@dataclass(frozen=True, eq=True)
class unary_rator(ABC):
    # @abstractmethod
    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type unary_rator

@dataclass(frozen=True, eq=True)
class Invert(unary_rator):
    source_start : int
    source_end : int

    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_Invert(self)

def make_Invert(
    source_start : int = 0, 
    source_end : int = 0
) -> unary_rator:
    return Invert(
        source_start,
        source_end
    )

def update_Invert(source_Invert : Invert,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Invert:
    return Invert(
        source_Invert.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Invert.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Not(unary_rator):
    source_start : int
    source_end : int

    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_Not(self)

def make_Not(
    source_start : int = 0, 
    source_end : int = 0
) -> unary_rator:
    return Not(
        source_start,
        source_end
    )

def update_Not(source_Not : Not,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Not:
    return Not(
        source_Not.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Not.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class UAdd(unary_rator):
    source_start : int
    source_end : int

    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_UAdd(self)

def make_UAdd(
    source_start : int = 0, 
    source_end : int = 0
) -> unary_rator:
    return UAdd(
        source_start,
        source_end
    )

def update_UAdd(source_UAdd : UAdd,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> UAdd:
    return UAdd(
        source_UAdd.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_UAdd.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class USub(unary_rator):
    source_start : int
    source_end : int

    def match(self, handlers : UnaryRatorHandlers[T]) -> T:
        return handlers.case_USub(self)

def make_USub(
    source_start : int = 0, 
    source_end : int = 0
) -> unary_rator:
    return USub(
        source_start,
        source_end
    )

def update_USub(source_USub : USub,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> USub:
    return USub(
        source_USub.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_USub.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type unary_rator
@dataclass(frozen=True, eq=True)
class UnaryRatorHandlers(Generic[T]):
    case_Invert : Callable[[Invert], T]
    case_Not : Callable[[Not], T]
    case_UAdd : Callable[[UAdd], T]
    case_USub : Callable[[USub], T]


# matching for type unary_rator
def match_unary_rator(o : unary_rator, handlers : UnaryRatorHandlers[T]) -> T :
    return o.match(handlers)


unary_rator_union = Union[Invert, Not, UAdd, USub]

# unguarding for type unary_rator
def unguard_unary_rator(o : unary_rator) -> unary_rator_union :
    return match_unary_rator(o, UnaryRatorHandlers(
        case_Invert = lambda x : x, 
        case_Not = lambda x : x, 
        case_UAdd = lambda x : x, 
        case_USub = lambda x : x

    ))
    

# type cmp_rator
@dataclass(frozen=True, eq=True)
class cmp_rator(ABC):
    # @abstractmethod
    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        raise Exception()


# constructors for type cmp_rator

@dataclass(frozen=True, eq=True)
class Eq(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Eq(self)

def make_Eq(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return Eq(
        source_start,
        source_end
    )

def update_Eq(source_Eq : Eq,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Eq:
    return Eq(
        source_Eq.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Eq.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NotEq(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_NotEq(self)

def make_NotEq(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return NotEq(
        source_start,
        source_end
    )

def update_NotEq(source_NotEq : NotEq,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NotEq:
    return NotEq(
        source_NotEq.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NotEq.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Lt(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Lt(self)

def make_Lt(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return Lt(
        source_start,
        source_end
    )

def update_Lt(source_Lt : Lt,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Lt:
    return Lt(
        source_Lt.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Lt.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class LtE(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_LtE(self)

def make_LtE(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return LtE(
        source_start,
        source_end
    )

def update_LtE(source_LtE : LtE,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> LtE:
    return LtE(
        source_LtE.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_LtE.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Gt(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Gt(self)

def make_Gt(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return Gt(
        source_start,
        source_end
    )

def update_Gt(source_Gt : Gt,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Gt:
    return Gt(
        source_Gt.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Gt.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class GtE(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_GtE(self)

def make_GtE(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return GtE(
        source_start,
        source_end
    )

def update_GtE(source_GtE : GtE,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> GtE:
    return GtE(
        source_GtE.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_GtE.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Is(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_Is(self)

def make_Is(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return Is(
        source_start,
        source_end
    )

def update_Is(source_Is : Is,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Is:
    return Is(
        source_Is.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Is.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class IsNot(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_IsNot(self)

def make_IsNot(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return IsNot(
        source_start,
        source_end
    )

def update_IsNot(source_IsNot : IsNot,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> IsNot:
    return IsNot(
        source_IsNot.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_IsNot.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class In(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_In(self)

def make_In(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return In(
        source_start,
        source_end
    )

def update_In(source_In : In,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> In:
    return In(
        source_In.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_In.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class NotIn(cmp_rator):
    source_start : int
    source_end : int

    def match(self, handlers : CmpRatorHandlers[T]) -> T:
        return handlers.case_NotIn(self)

def make_NotIn(
    source_start : int = 0, 
    source_end : int = 0
) -> cmp_rator:
    return NotIn(
        source_start,
        source_end
    )

def update_NotIn(source_NotIn : NotIn,
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> NotIn:
    return NotIn(
        source_NotIn.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_NotIn.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type cmp_rator
@dataclass(frozen=True, eq=True)
class CmpRatorHandlers(Generic[T]):
    case_Eq : Callable[[Eq], T]
    case_NotEq : Callable[[NotEq], T]
    case_Lt : Callable[[Lt], T]
    case_LtE : Callable[[LtE], T]
    case_Gt : Callable[[Gt], T]
    case_GtE : Callable[[GtE], T]
    case_Is : Callable[[Is], T]
    case_IsNot : Callable[[IsNot], T]
    case_In : Callable[[In], T]
    case_NotIn : Callable[[NotIn], T]


# matching for type cmp_rator
def match_cmp_rator(o : cmp_rator, handlers : CmpRatorHandlers[T]) -> T :
    return o.match(handlers)


cmp_rator_union = Union[Eq, NotEq, Lt, LtE, Gt, GtE, Is, IsNot, In, NotIn]

# unguarding for type cmp_rator
def unguard_cmp_rator(o : cmp_rator) -> cmp_rator_union :
    return match_cmp_rator(o, CmpRatorHandlers(
        case_Eq = lambda x : x, 
        case_NotEq = lambda x : x, 
        case_Lt = lambda x : x, 
        case_LtE = lambda x : x, 
        case_Gt = lambda x : x, 
        case_GtE = lambda x : x, 
        case_Is = lambda x : x, 
        case_IsNot = lambda x : x, 
        case_In = lambda x : x, 
        case_NotIn = lambda x : x

    ))
    

# type constraint
@dataclass(frozen=True, eq=True)
class constraint(ABC):
    # @abstractmethod
    def match(self, handlers : ConstraintHandlers[T]) -> T:
        raise Exception()


# constructors for type constraint

@dataclass(frozen=True, eq=True)
class AsyncConstraint(constraint):
    comment_a : str
    target : expr | None
    comment_b : str
    comment_c : str
    search_space : expr | None
    comment_d : str
    filts : constraint_filters | None
    source_start : int
    source_end : int

    def match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_AsyncConstraint(self)

def make_AsyncConstraint(
    comment_a : str, 
    target : expr | None, 
    comment_b : str, 
    comment_c : str, 
    search_space : expr | None, 
    comment_d : str, 
    filts : constraint_filters | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> constraint:
    return AsyncConstraint(
        comment_a,
        target,
        comment_b,
        comment_c,
        search_space,
        comment_d,
        filts,
        source_start,
        source_end
    )

def update_AsyncConstraint(source_AsyncConstraint : AsyncConstraint,
    comment_a : Union[str, SourceFlag] = SourceFlag(),
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_b : Union[str, SourceFlag] = SourceFlag(),
    comment_c : Union[str, SourceFlag] = SourceFlag(),
    search_space : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_d : Union[str, SourceFlag] = SourceFlag(),
    filts : Union[constraint_filters | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> AsyncConstraint:
    return AsyncConstraint(
        source_AsyncConstraint.comment_a if isinstance(comment_a, SourceFlag) else comment_a,
        source_AsyncConstraint.target if isinstance(target, SourceFlag) else target,
        source_AsyncConstraint.comment_b if isinstance(comment_b, SourceFlag) else comment_b,
        source_AsyncConstraint.comment_c if isinstance(comment_c, SourceFlag) else comment_c,
        source_AsyncConstraint.search_space if isinstance(search_space, SourceFlag) else search_space,
        source_AsyncConstraint.comment_d if isinstance(comment_d, SourceFlag) else comment_d,
        source_AsyncConstraint.filts if isinstance(filts, SourceFlag) else filts,
        source_AsyncConstraint.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_AsyncConstraint.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Constraint(constraint):
    comment_a : str
    target : expr | None
    comment_b : str
    comment_c : str
    search_space : expr | None
    comment_d : str
    filts : constraint_filters | None
    source_start : int
    source_end : int

    def match(self, handlers : ConstraintHandlers[T]) -> T:
        return handlers.case_Constraint(self)

def make_Constraint(
    comment_a : str, 
    target : expr | None, 
    comment_b : str, 
    comment_c : str, 
    search_space : expr | None, 
    comment_d : str, 
    filts : constraint_filters | None, 
    source_start : int = 0, 
    source_end : int = 0
) -> constraint:
    return Constraint(
        comment_a,
        target,
        comment_b,
        comment_c,
        search_space,
        comment_d,
        filts,
        source_start,
        source_end
    )

def update_Constraint(source_Constraint : Constraint,
    comment_a : Union[str, SourceFlag] = SourceFlag(),
    target : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_b : Union[str, SourceFlag] = SourceFlag(),
    comment_c : Union[str, SourceFlag] = SourceFlag(),
    search_space : Union[expr | None, SourceFlag] = SourceFlag(),
    comment_d : Union[str, SourceFlag] = SourceFlag(),
    filts : Union[constraint_filters | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Constraint:
    return Constraint(
        source_Constraint.comment_a if isinstance(comment_a, SourceFlag) else comment_a,
        source_Constraint.target if isinstance(target, SourceFlag) else target,
        source_Constraint.comment_b if isinstance(comment_b, SourceFlag) else comment_b,
        source_Constraint.comment_c if isinstance(comment_c, SourceFlag) else comment_c,
        source_Constraint.search_space if isinstance(search_space, SourceFlag) else search_space,
        source_Constraint.comment_d if isinstance(comment_d, SourceFlag) else comment_d,
        source_Constraint.filts if isinstance(filts, SourceFlag) else filts,
        source_Constraint.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Constraint.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

# case handlers for type constraint
@dataclass(frozen=True, eq=True)
class ConstraintHandlers(Generic[T]):
    case_AsyncConstraint : Callable[[AsyncConstraint], T]
    case_Constraint : Callable[[Constraint], T]


# matching for type constraint
def match_constraint(o : constraint, handlers : ConstraintHandlers[T]) -> T :
    return o.match(handlers)


constraint_union = Union[AsyncConstraint, Constraint]

# unguarding for type constraint
def unguard_constraint(o : constraint) -> constraint_union :
    return match_constraint(o, ConstraintHandlers(
        case_AsyncConstraint = lambda x : x, 
        case_Constraint = lambda x : x

    ))
     


# type and constructor CompareRight
@dataclass(frozen=True, eq=True)
class CompareRight:
    rator : cmp_rator | None
    rand : expr | None
    source_start : int
    source_end : int


def make_CompareRight(
    rator : cmp_rator | None,
    rand : expr | None,
    source_start : int = 0,
    source_end : int = 0
) -> CompareRight:
    return CompareRight(
        rator,
        rand,
        source_start,
        source_end)

def update_CompareRight(source_CompareRight : CompareRight,
    rator : Union[cmp_rator | None, SourceFlag] = SourceFlag(),
    rand : Union[expr | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> CompareRight:
    return CompareRight(
        source_CompareRight.rator if isinstance(rator, SourceFlag) else rator, 
        source_CompareRight.rand if isinstance(rand, SourceFlag) else rand, 
        source_CompareRight.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_CompareRight.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor ExceptHandler
@dataclass(frozen=True, eq=True)
class ExceptHandler:
    arg : except_arg | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int


def make_ExceptHandler(
    arg : except_arg | None,
    comment : str,
    body : statements | None,
    source_start : int = 0,
    source_end : int = 0
) -> ExceptHandler:
    return ExceptHandler(
        arg,
        comment,
        body,
        source_start,
        source_end)

def update_ExceptHandler(source_ExceptHandler : ExceptHandler,
    arg : Union[except_arg | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ExceptHandler:
    return ExceptHandler(
        source_ExceptHandler.arg if isinstance(arg, SourceFlag) else arg, 
        source_ExceptHandler.comment if isinstance(comment, SourceFlag) else comment, 
        source_ExceptHandler.body if isinstance(body, SourceFlag) else body, 
        source_ExceptHandler.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_ExceptHandler.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor Param
@dataclass(frozen=True, eq=True)
class Param:
    name : str
    anno : param_annotation | None
    default : param_default | None
    source_start : int
    source_end : int


def make_Param(
    name : str,
    anno : param_annotation | None,
    default : param_default | None,
    source_start : int = 0,
    source_end : int = 0
) -> Param:
    return Param(
        name,
        anno,
        default,
        source_start,
        source_end)

def update_Param(source_Param : Param,
    name : Union[str, SourceFlag] = SourceFlag(),
    anno : Union[param_annotation | None, SourceFlag] = SourceFlag(),
    default : Union[param_default | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Param:
    return Param(
        source_Param.name if isinstance(name, SourceFlag) else name, 
        source_Param.anno if isinstance(anno, SourceFlag) else anno, 
        source_Param.default if isinstance(default, SourceFlag) else default, 
        source_Param.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_Param.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor ClassDef
@dataclass(frozen=True, eq=True)
class ClassDef:
    name : str
    bs : bases | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int


def make_ClassDef(
    name : str,
    bs : bases | None,
    comment : str,
    body : statements | None,
    source_start : int = 0,
    source_end : int = 0
) -> ClassDef:
    return ClassDef(
        name,
        bs,
        comment,
        body,
        source_start,
        source_end)

def update_ClassDef(source_ClassDef : ClassDef,
    name : Union[str, SourceFlag] = SourceFlag(),
    bs : Union[bases | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ClassDef:
    return ClassDef(
        source_ClassDef.name if isinstance(name, SourceFlag) else name, 
        source_ClassDef.bs if isinstance(bs, SourceFlag) else bs, 
        source_ClassDef.comment if isinstance(comment, SourceFlag) else comment, 
        source_ClassDef.body if isinstance(body, SourceFlag) else body, 
        source_ClassDef.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_ClassDef.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor ElifBlock
@dataclass(frozen=True, eq=True)
class ElifBlock:
    test : expr | None
    comment : str
    body : statements | None
    source_start : int
    source_end : int


def make_ElifBlock(
    test : expr | None,
    comment : str,
    body : statements | None,
    source_start : int = 0,
    source_end : int = 0
) -> ElifBlock:
    return ElifBlock(
        test,
        comment,
        body,
        source_start,
        source_end)

def update_ElifBlock(source_ElifBlock : ElifBlock,
    test : Union[expr | None, SourceFlag] = SourceFlag(),
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ElifBlock:
    return ElifBlock(
        source_ElifBlock.test if isinstance(test, SourceFlag) else test, 
        source_ElifBlock.comment if isinstance(comment, SourceFlag) else comment, 
        source_ElifBlock.body if isinstance(body, SourceFlag) else body, 
        source_ElifBlock.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_ElifBlock.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor ElseBlock
@dataclass(frozen=True, eq=True)
class ElseBlock:
    comment : str
    body : statements | None
    source_start : int
    source_end : int


def make_ElseBlock(
    comment : str,
    body : statements | None,
    source_start : int = 0,
    source_end : int = 0
) -> ElseBlock:
    return ElseBlock(
        comment,
        body,
        source_start,
        source_end)

def update_ElseBlock(source_ElseBlock : ElseBlock,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> ElseBlock:
    return ElseBlock(
        source_ElseBlock.comment if isinstance(comment, SourceFlag) else comment, 
        source_ElseBlock.body if isinstance(body, SourceFlag) else body, 
        source_ElseBlock.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_ElseBlock.source_end if isinstance(source_end, SourceFlag) else source_end)

    

# type and constructor FinallyBlock
@dataclass(frozen=True, eq=True)
class FinallyBlock:
    comment : str
    body : statements | None
    source_start : int
    source_end : int


def make_FinallyBlock(
    comment : str,
    body : statements | None,
    source_start : int = 0,
    source_end : int = 0
) -> FinallyBlock:
    return FinallyBlock(
        comment,
        body,
        source_start,
        source_end)

def update_FinallyBlock(source_FinallyBlock : FinallyBlock,
    comment : Union[str, SourceFlag] = SourceFlag(),
    body : Union[statements | None, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> FinallyBlock:
    return FinallyBlock(
        source_FinallyBlock.comment if isinstance(comment, SourceFlag) else comment, 
        source_FinallyBlock.body if isinstance(body, SourceFlag) else body, 
        source_FinallyBlock.source_start if isinstance(source_start, SourceFlag) else source_start, 
        source_FinallyBlock.source_end if isinstance(source_end, SourceFlag) else source_end)

     
    

ast = Union[
    CompareRight,
    ExceptHandler,
    Param,
    ClassDef,
    ElifBlock,
    ElseBlock,
    FinallyBlock,
    SomeReturnAnno,
    NoReturnAnno,
    SomeExceptArg,
    SomeExceptArgName,
    NoExceptArg,
    SomeParamAnno,
    NoParamAnno,
    SomeParamDefault,
    NoParamDefault,
    ConsKwParam,
    SingleKwParam,
    TransKwParam,
    SingleTupleBundleParam,
    TransTupleBundleParam,
    ParamsD,
    DoubleBundleParam,
    DictionaryBundleParam,
    ConsPosKeyParam,
    SinglePosKeyParam,
    ParamsC,
    ConsPosParam,
    SinglePosParam,
    TransPosParam,
    ParamsA,
    ParamsB,
    NoParam,
    NamedKeyword,
    SplatKeyword,
    ImportNameAlias,
    ImportNameOnly,
    WithItemAlias,
    WithItemOnly,
    SomeBases,
    NoBases,
    ConsBase,
    SingleBase,
    KeywordBases,
    ConsKeyword,
    SingleKeyword,
    ConsCompareRight,
    SingleCompareRight,
    SomeExpr,
    NoExpr,
    ConsExpr,
    SingleExpr,
    ConsTargetExpr,
    SingleTargetExpr,
    ExprDec,
    CmntDec,
    ConsDec,
    NoDec,
    ConsFilter,
    SingleFilter,
    NoFilter,
    ConsStr,
    SingleStr,
    ConsArg,
    SingleArg,
    KeywordsArg,
    Field,
    DictionarySplatFields,
    ConsDictionaryItem,
    SingleDictionaryItem,
    ConsId,
    SingleId,
    ConsImportName,
    SingleImportName,
    ConsWithItem,
    SingleWithItem,
    FutureMod,
    SimpleMod,
    ConsStmt,
    SingleStmt,
    ConsConstraint,
    SingleConstraint,
    ConsExceptHandler,
    SingleExceptHandler,
    ElifCond,
    ElseCond,
    NoCond,
    FunctionDef,
    AsyncFunctionDef,
    Comment,
    DecFunctionDef,
    DecClassDef,
    ReturnSomething,
    Return,
    Delete,
    Assign,
    AugAssign,
    AnnoAssign,
    AnnoDeclar,
    For,
    ForElse,
    AsyncFor,
    AsyncForElse,
    While,
    WhileElse,
    If,
    With,
    AsyncWith,
    Raise,
    RaiseExc,
    RaiseFrom,
    Try,
    TryElse,
    TryExceptFin,
    TryFin,
    TryElseFin,
    Assert,
    AssertMsg,
    Import,
    ImportFrom,
    ImportWildCard,
    Global,
    Nonlocal,
    Expr,
    Pass,
    Break,
    Continue,
    ParenExpr,
    BoolOp,
    AssignExpr,
    BinOp,
    UnaryOp,
    Lambda,
    IfExp,
    Dictionary,
    EmptyDictionary,
    Set,
    ListComp,
    SetComp,
    DictionaryComp,
    GeneratorExp,
    Await,
    YieldNothing,
    Yield,
    YieldFrom,
    Compare,
    Call,
    CallArgs,
    Integer,
    Float,
    ConcatString,
    True_,
    False_,
    None_,
    Ellip,
    Attribute,
    Subscript,
    Starred,
    Name,
    List,
    EmptyList,
    Tuple,
    EmptyTuple,
    Slice,
    And,
    Or,
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
    Invert,
    Not,
    UAdd,
    USub,
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
    AsyncConstraint,
    Constraint,
    return_annotation,
    except_arg,
    param_annotation,
    param_default,
    parameters_d,
    parameters_c,
    parameters_b,
    parameters_a,
    parameters,
    keyword,
    import_name,
    with_item,
    bases,
    bases_a,
    keywords,
    comparisons,
    option_expr,
    comma_exprs,
    target_exprs,
    decorator,
    decorators,
    constraint_filters,
    sequence_string,
    arguments,
    dictionary_item,
    dictionary_content,
    sequence_name,
    sequence_import_name,
    sequence_with_item,
    module,
    statements,
    comprehension_constraints,
    sequence_ExceptHandler,
    conditions,
    function_def,
    stmt,
    expr,
    bool_rator,
    bin_rator,
    unary_rator,
    cmp_rator,
    constraint,
    str
] 
    