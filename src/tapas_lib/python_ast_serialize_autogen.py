# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST


from __future__ import annotations
import tapas_base.abstract_token_system
from tapas_base.abstract_token_construct_autogen import abstract_token
from tapas_base.abstract_token_construct_autogen import Hole, make_Grammar, make_Vocab
from tapas_base.line_format_construct_autogen import InLine, NewLine, IndentLine



from tapas_lib.python_ast_construct_autogen import *
    



def from_return_annotation(
    o : return_annotation | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[return_annotation | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, return_annotation):

            
            def handle_SomeReturnAnno(o : SomeReturnAnno): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'return_annotation',
                        selection = 'SomeReturnAnno'
                    )])
                )
    

            def handle_NoReturnAnno(o : NoReturnAnno): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'return_annotation',
                        selection = 'NoReturnAnno'
                    )])
                )
    


            match_return_annotation(stack_item, ReturnAnnotationHandlers(
                case_SomeReturnAnno = handle_SomeReturnAnno,
                case_NoReturnAnno = handle_NoReturnAnno
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_except_arg(
    o : except_arg | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[except_arg | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, except_arg):

            
            def handle_SomeExceptArg(o : SomeExceptArg): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'except_arg',
                        selection = 'SomeExceptArg'
                    )])
                )
    

            def handle_SomeExceptArgName(o : SomeExceptArgName): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        


                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'except_arg',
                        selection = 'SomeExceptArgName'
                    )])
                )
    

            def handle_NoExceptArg(o : NoExceptArg): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'except_arg',
                        selection = 'NoExceptArg'
                    )])
                )
    


            match_except_arg(stack_item, ExceptArgHandlers(
                case_SomeExceptArg = handle_SomeExceptArg,
                case_SomeExceptArgName = handle_SomeExceptArgName,
                case_NoExceptArg = handle_NoExceptArg
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_param_annotation(
    o : param_annotation | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[param_annotation | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, param_annotation):

            
            def handle_SomeParamAnno(o : SomeParamAnno): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'param_annotation',
                        selection = 'SomeParamAnno'
                    )])
                )
    

            def handle_NoParamAnno(o : NoParamAnno): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'param_annotation',
                        selection = 'NoParamAnno'
                    )])
                )
    


            match_param_annotation(stack_item, ParamAnnotationHandlers(
                case_SomeParamAnno = handle_SomeParamAnno,
                case_NoParamAnno = handle_NoParamAnno
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_param_default(
    o : param_default | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[param_default | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, param_default):

            
            def handle_SomeParamDefault(o : SomeParamDefault): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'param_default',
                        selection = 'SomeParamDefault'
                    )])
                )
    

            def handle_NoParamDefault(o : NoParamDefault): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'param_default',
                        selection = 'NoParamDefault'
                    )])
                )
    


            match_param_default(stack_item, ParamDefaultHandlers(
                case_SomeParamDefault = handle_SomeParamDefault,
                case_NoParamDefault = handle_NoParamDefault
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_parameters_d(
    o : parameters_d | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[parameters_d | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, parameters_d):

            
            def handle_ConsKwParam(o : ConsKwParam): 
                
                stack.append(o.tail)


                stack.append(from_Param(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_d',
                        selection = 'ConsKwParam'
                    )])
                )
    

            def handle_SingleKwParam(o : SingleKwParam): 
                
                stack.append(from_Param(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_d',
                        selection = 'SingleKwParam'
                    )])
                )
    

            def handle_DictionarySplatParam(o : DictionarySplatParam): 
                
                stack.append(from_Param(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_d',
                        selection = 'DictionarySplatParam'
                    )])
                )
    


            match_parameters_d(stack_item, ParametersDHandlers(
                case_ConsKwParam = handle_ConsKwParam,
                case_SingleKwParam = handle_SingleKwParam,
                case_DictionarySplatParam = handle_DictionarySplatParam
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_parameters_c(
    o : parameters_c | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[parameters_c | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, parameters_c):

            
            def handle_SingleListSplatParam(o : SingleListSplatParam): 
                
                stack.append(from_Param(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_c',
                        selection = 'SingleListSplatParam'
                    )])
                )
    

            def handle_TransListSplatParam(o : TransListSplatParam): 
                
                stack.append(from_parameters_d(o.tail))


                stack.append(from_Param(o.head))

                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_c',
                        selection = 'TransListSplatParam'
                    )])
                )
    

            def handle_ParamsD(o : ParamsD): 
                
                stack.append(from_parameters_d(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_c',
                        selection = 'ParamsD'
                    )])
                )
    


            match_parameters_c(stack_item, ParametersCHandlers(
                case_SingleListSplatParam = handle_SingleListSplatParam,
                case_TransListSplatParam = handle_TransListSplatParam,
                case_ParamsD = handle_ParamsD
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_parameters_b(
    o : parameters_b | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[parameters_b | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, parameters_b):

            
            def handle_ConsPosKeyParam(o : ConsPosKeyParam): 
                
                stack.append(o.tail)


                stack.append(from_Param(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_b',
                        selection = 'ConsPosKeyParam'
                    )])
                )
    

            def handle_SinglePosKeyParam(o : SinglePosKeyParam): 
                
                stack.append(from_Param(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_b',
                        selection = 'SinglePosKeyParam'
                    )])
                )
    

            def handle_ParamsC(o : ParamsC): 
                
                stack.append(from_parameters_c(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_b',
                        selection = 'ParamsC'
                    )])
                )
    


            match_parameters_b(stack_item, ParametersBHandlers(
                case_ConsPosKeyParam = handle_ConsPosKeyParam,
                case_SinglePosKeyParam = handle_SinglePosKeyParam,
                case_ParamsC = handle_ParamsC
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_parameters_a(
    o : parameters_a | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[parameters_a | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, parameters_a):

            
            def handle_ConsPosParam(o : ConsPosParam): 
                
                stack.append(o.tail)


                stack.append(from_Param(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_a',
                        selection = 'ConsPosParam'
                    )])
                )
    

            def handle_SinglePosParam(o : SinglePosParam): 
                

                stack.append(from_Param(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_a',
                        selection = 'SinglePosParam'
                    )])
                )
    

            def handle_TransPosParam(o : TransPosParam): 
                
                stack.append(from_parameters_b(o.tail))


                stack.append(from_Param(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters_a',
                        selection = 'TransPosParam'
                    )])
                )
    


            match_parameters_a(stack_item, ParametersAHandlers(
                case_ConsPosParam = handle_ConsPosParam,
                case_SinglePosParam = handle_SinglePosParam,
                case_TransPosParam = handle_TransPosParam
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_parameters(
    o : parameters | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[parameters | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, parameters):

            
            def handle_ParamsA(o : ParamsA): 
                
                stack.append(from_parameters_a(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters',
                        selection = 'ParamsA'
                    )])
                )
    

            def handle_ParamsB(o : ParamsB): 
                
                stack.append(from_parameters_b(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters',
                        selection = 'ParamsB'
                    )])
                )
    

            def handle_NoParam(o : NoParam): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'parameters',
                        selection = 'NoParam'
                    )])
                )
    


            match_parameters(stack_item, ParametersHandlers(
                case_ParamsA = handle_ParamsA,
                case_ParamsB = handle_ParamsB,
                case_NoParam = handle_NoParam
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_keyword(
    o : keyword | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[keyword | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, keyword):

            
            def handle_NamedKeyword(o : NamedKeyword): 
                
                stack.append(from_expr(o.content))


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'keyword',
                        selection = 'NamedKeyword'
                    )])
                )
    

            def handle_SplatKeyword(o : SplatKeyword): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'keyword',
                        selection = 'SplatKeyword'
                    )])
                )
    


            match_keyword(stack_item, KeywordHandlers(
                case_NamedKeyword = handle_NamedKeyword,
                case_SplatKeyword = handle_SplatKeyword
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_import_name(
    o : import_name | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[import_name | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, import_name):

            
            def handle_ImportNameAlias(o : ImportNameAlias): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.alias
                    )])
                )
        


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'import_name',
                        selection = 'ImportNameAlias'
                    )])
                )
    

            def handle_ImportNameOnly(o : ImportNameOnly): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'import_name',
                        selection = 'ImportNameOnly'
                    )])
                )
    


            match_import_name(stack_item, ImportNameHandlers(
                case_ImportNameAlias = handle_ImportNameAlias,
                case_ImportNameOnly = handle_ImportNameOnly
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_with_item(
    o : with_item | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[with_item | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, with_item):

            
            def handle_WithItemAlias(o : WithItemAlias): 
                
                stack.append(from_expr(o.alias))


                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'with_item',
                        selection = 'WithItemAlias'
                    )])
                )
    

            def handle_WithItemOnly(o : WithItemOnly): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'with_item',
                        selection = 'WithItemOnly'
                    )])
                )
    


            match_with_item(stack_item, WithItemHandlers(
                case_WithItemAlias = handle_WithItemAlias,
                case_WithItemOnly = handle_WithItemOnly
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_bases(
    o : bases | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[bases | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, bases):

            
            def handle_SomeBases(o : SomeBases): 
                

                stack.append(from_bases_a(o.bases))

                stack.append(
                    tuple([make_Grammar(
                        options = 'bases',
                        selection = 'SomeBases'
                    )])
                )
    

            def handle_NoBases(o : NoBases): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bases',
                        selection = 'NoBases'
                    )])
                )
    


            match_bases(stack_item, BasesHandlers(
                case_SomeBases = handle_SomeBases,
                case_NoBases = handle_NoBases
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_bases_a(
    o : bases_a | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[bases_a | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, bases_a):

            
            def handle_ConsBase(o : ConsBase): 
                
                stack.append(o.tail)


                stack.append(from_expr(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'bases_a',
                        selection = 'ConsBase'
                    )])
                )
    

            def handle_SingleBase(o : SingleBase): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'bases_a',
                        selection = 'SingleBase'
                    )])
                )
    

            def handle_KeywordBases(o : KeywordBases): 
                
                stack.append(from_keywords(o.kws))
                stack.append(
                    tuple([make_Grammar(
                        options = 'bases_a',
                        selection = 'KeywordBases'
                    )])
                )
    


            match_bases_a(stack_item, BasesAHandlers(
                case_ConsBase = handle_ConsBase,
                case_SingleBase = handle_SingleBase,
                case_KeywordBases = handle_KeywordBases
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_keywords(
    o : keywords | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[keywords | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, keywords):

            
            def handle_ConsKeyword(o : ConsKeyword): 
                
                stack.append(o.tail)


                stack.append(from_keyword(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'keywords',
                        selection = 'ConsKeyword'
                    )])
                )
    

            def handle_SingleKeyword(o : SingleKeyword): 
                
                stack.append(from_keyword(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'keywords',
                        selection = 'SingleKeyword'
                    )])
                )
    


            match_keywords(stack_item, KeywordsHandlers(
                case_ConsKeyword = handle_ConsKeyword,
                case_SingleKeyword = handle_SingleKeyword
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_comparisons(
    o : comparisons | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[comparisons | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, comparisons):

            
            def handle_ConsCompareRight(o : ConsCompareRight): 
                
                stack.append(o.tail)


                stack.append(from_CompareRight(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comparisons',
                        selection = 'ConsCompareRight'
                    )])
                )
    

            def handle_SingleCompareRight(o : SingleCompareRight): 
                
                stack.append(from_CompareRight(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comparisons',
                        selection = 'SingleCompareRight'
                    )])
                )
    


            match_comparisons(stack_item, ComparisonsHandlers(
                case_ConsCompareRight = handle_ConsCompareRight,
                case_SingleCompareRight = handle_SingleCompareRight
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_option_expr(
    o : option_expr | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[option_expr | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, option_expr):

            
            def handle_SomeExpr(o : SomeExpr): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'option_expr',
                        selection = 'SomeExpr'
                    )])
                )
    

            def handle_NoExpr(o : NoExpr): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'option_expr',
                        selection = 'NoExpr'
                    )])
                )
    


            match_option_expr(stack_item, OptionExprHandlers(
                case_SomeExpr = handle_SomeExpr,
                case_NoExpr = handle_NoExpr
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_comma_exprs(
    o : comma_exprs | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[comma_exprs | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, comma_exprs):

            
            def handle_ConsExpr(o : ConsExpr): 
                
                stack.append(o.tail)


                stack.append(from_expr(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comma_exprs',
                        selection = 'ConsExpr'
                    )])
                )
    

            def handle_SingleExpr(o : SingleExpr): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comma_exprs',
                        selection = 'SingleExpr'
                    )])
                )
    


            match_comma_exprs(stack_item, CommaExprsHandlers(
                case_ConsExpr = handle_ConsExpr,
                case_SingleExpr = handle_SingleExpr
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_target_exprs(
    o : target_exprs | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[target_exprs | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, target_exprs):

            
            def handle_ConsTargetExpr(o : ConsTargetExpr): 
                
                stack.append(o.tail)


                stack.append(from_expr(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'target_exprs',
                        selection = 'ConsTargetExpr'
                    )])
                )
    

            def handle_SingleTargetExpr(o : SingleTargetExpr): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'target_exprs',
                        selection = 'SingleTargetExpr'
                    )])
                )
    


            match_target_exprs(stack_item, TargetExprsHandlers(
                case_ConsTargetExpr = handle_ConsTargetExpr,
                case_SingleTargetExpr = handle_SingleTargetExpr
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_decorators(
    o : decorators | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[decorators | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, decorators):

            
            def handle_ConsDec(o : ConsDec): 
                
                stack.append(o.tail)

                stack.append(from_expr(o.head))

                stack.append(
                    tuple([make_Grammar(
                        options = 'decorators',
                        selection = 'ConsDec'
                    )])
                )
    

            def handle_NoDec(o : NoDec): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'decorators',
                        selection = 'NoDec'
                    )])
                )
    


            match_decorators(stack_item, DecoratorsHandlers(
                case_ConsDec = handle_ConsDec,
                case_NoDec = handle_NoDec
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_constraint_filters(
    o : constraint_filters | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[constraint_filters | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, constraint_filters):

            
            def handle_ConsFilter(o : ConsFilter): 
                
                stack.append(o.tail)

                stack.append(from_expr(o.head))

                stack.append(
                    tuple([make_Grammar(
                        options = 'constraint_filters',
                        selection = 'ConsFilter'
                    )])
                )
    

            def handle_SingleFilter(o : SingleFilter): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'constraint_filters',
                        selection = 'SingleFilter'
                    )])
                )
    

            def handle_NoFilter(o : NoFilter): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'constraint_filters',
                        selection = 'NoFilter'
                    )])
                )
    


            match_constraint_filters(stack_item, ConstraintFiltersHandlers(
                case_ConsFilter = handle_ConsFilter,
                case_SingleFilter = handle_SingleFilter,
                case_NoFilter = handle_NoFilter
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_sequence_string(
    o : sequence_string | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[sequence_string | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, sequence_string):

            
            def handle_ConsStr(o : ConsStr): 
                
                stack.append(o.tail)


                stack.append(
                    tuple([make_Vocab(
                        options = 'string',
                        selection = o.head
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_string',
                        selection = 'ConsStr'
                    )])
                )
    

            def handle_SingleStr(o : SingleStr): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'string',
                        selection = o.content
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_string',
                        selection = 'SingleStr'
                    )])
                )
    


            match_sequence_string(stack_item, SequenceStringHandlers(
                case_ConsStr = handle_ConsStr,
                case_SingleStr = handle_SingleStr
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_arguments(
    o : arguments | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[arguments | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, arguments):

            
            def handle_ConsArg(o : ConsArg): 
                
                stack.append(o.tail)


                stack.append(from_expr(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'arguments',
                        selection = 'ConsArg'
                    )])
                )
    

            def handle_SingleArg(o : SingleArg): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'arguments',
                        selection = 'SingleArg'
                    )])
                )
    

            def handle_KeywordsArg(o : KeywordsArg): 
                
                stack.append(from_keywords(o.kws))
                stack.append(
                    tuple([make_Grammar(
                        options = 'arguments',
                        selection = 'KeywordsArg'
                    )])
                )
    


            match_arguments(stack_item, ArgumentsHandlers(
                case_ConsArg = handle_ConsArg,
                case_SingleArg = handle_SingleArg,
                case_KeywordsArg = handle_KeywordsArg
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_dictionary_item(
    o : dictionary_item | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[dictionary_item | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, dictionary_item):

            
            def handle_Field(o : Field): 
                
                stack.append(from_expr(o.content))


                stack.append(from_expr(o.key))
                stack.append(
                    tuple([make_Grammar(
                        options = 'dictionary_item',
                        selection = 'Field'
                    )])
                )
    

            def handle_DictionarySplatFields(o : DictionarySplatFields): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'dictionary_item',
                        selection = 'DictionarySplatFields'
                    )])
                )
    


            match_dictionary_item(stack_item, DictionaryItemHandlers(
                case_Field = handle_Field,
                case_DictionarySplatFields = handle_DictionarySplatFields
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_dictionary_content(
    o : dictionary_content | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[dictionary_content | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, dictionary_content):

            
            def handle_ConsDictionaryItem(o : ConsDictionaryItem): 
                
                stack.append(o.tail)


                stack.append(from_dictionary_item(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'dictionary_content',
                        selection = 'ConsDictionaryItem'
                    )])
                )
    

            def handle_SingleDictionaryItem(o : SingleDictionaryItem): 
                
                stack.append(from_dictionary_item(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'dictionary_content',
                        selection = 'SingleDictionaryItem'
                    )])
                )
    


            match_dictionary_content(stack_item, DictionaryContentHandlers(
                case_ConsDictionaryItem = handle_ConsDictionaryItem,
                case_SingleDictionaryItem = handle_SingleDictionaryItem
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_sequence_name(
    o : sequence_name | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[sequence_name | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, sequence_name):

            
            def handle_ConsId(o : ConsId): 
                
                stack.append(o.tail)


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.head
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_name',
                        selection = 'ConsId'
                    )])
                )
    

            def handle_SingleId(o : SingleId): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.content
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_name',
                        selection = 'SingleId'
                    )])
                )
    


            match_sequence_name(stack_item, SequenceNameHandlers(
                case_ConsId = handle_ConsId,
                case_SingleId = handle_SingleId
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_sequence_import_name(
    o : sequence_import_name | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[sequence_import_name | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, sequence_import_name):

            
            def handle_ConsImportName(o : ConsImportName): 
                
                stack.append(o.tail)


                stack.append(from_import_name(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_import_name',
                        selection = 'ConsImportName'
                    )])
                )
    

            def handle_SingleImportName(o : SingleImportName): 
                
                stack.append(from_import_name(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_import_name',
                        selection = 'SingleImportName'
                    )])
                )
    


            match_sequence_import_name(stack_item, SequenceImportNameHandlers(
                case_ConsImportName = handle_ConsImportName,
                case_SingleImportName = handle_SingleImportName
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_sequence_with_item(
    o : sequence_with_item | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[sequence_with_item | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, sequence_with_item):

            
            def handle_ConsWithItem(o : ConsWithItem): 
                
                stack.append(o.tail)


                stack.append(from_with_item(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_with_item',
                        selection = 'ConsWithItem'
                    )])
                )
    

            def handle_SingleWithItem(o : SingleWithItem): 
                
                stack.append(from_with_item(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_with_item',
                        selection = 'SingleWithItem'
                    )])
                )
    


            match_sequence_with_item(stack_item, SequenceWithItemHandlers(
                case_ConsWithItem = handle_ConsWithItem,
                case_SingleWithItem = handle_SingleWithItem
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_module(
    o : module | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[module | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, module):

            
            def handle_FutureMod(o : FutureMod): 
                
                stack.append(from_statements(o.body))

                stack.append(from_sequence_import_name(o.names))

                stack.append(
                    tuple([make_Grammar(
                        options = 'module',
                        selection = 'FutureMod'
                    )])
                )
    

            def handle_SimpleMod(o : SimpleMod): 
                
                stack.append(from_statements(o.body))
                stack.append(
                    tuple([make_Grammar(
                        options = 'module',
                        selection = 'SimpleMod'
                    )])
                )
    


            match_module(stack_item, ModuleHandlers(
                case_FutureMod = handle_FutureMod,
                case_SimpleMod = handle_SimpleMod
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_statements(
    o : statements | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[statements | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, statements):

            
            def handle_ConsStmt(o : ConsStmt): 
                
                stack.append(o.tail)

                stack.append(from_stmt(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'statements',
                        selection = 'ConsStmt'
                    )])
                )
    

            def handle_SingleStmt(o : SingleStmt): 
                
                stack.append(from_stmt(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'statements',
                        selection = 'SingleStmt'
                    )])
                )
    


            match_statements(stack_item, StatementsHandlers(
                case_ConsStmt = handle_ConsStmt,
                case_SingleStmt = handle_SingleStmt
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_comprehension_constraints(
    o : comprehension_constraints | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[comprehension_constraints | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, comprehension_constraints):

            
            def handle_ConsConstraint(o : ConsConstraint): 
                
                stack.append(o.tail)

                stack.append(from_constraint(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comprehension_constraints',
                        selection = 'ConsConstraint'
                    )])
                )
    

            def handle_SingleConstraint(o : SingleConstraint): 
                
                stack.append(from_constraint(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'comprehension_constraints',
                        selection = 'SingleConstraint'
                    )])
                )
    


            match_comprehension_constraints(stack_item, ComprehensionConstraintsHandlers(
                case_ConsConstraint = handle_ConsConstraint,
                case_SingleConstraint = handle_SingleConstraint
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_sequence_ExceptHandler(
    o : sequence_ExceptHandler | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[sequence_ExceptHandler | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, sequence_ExceptHandler):

            
            def handle_ConsExceptHandler(o : ConsExceptHandler): 
                
                stack.append(o.tail)

                stack.append(from_ExceptHandler(o.head))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_ExceptHandler',
                        selection = 'ConsExceptHandler'
                    )])
                )
    

            def handle_SingleExceptHandler(o : SingleExceptHandler): 
                
                stack.append(from_ExceptHandler(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'sequence_ExceptHandler',
                        selection = 'SingleExceptHandler'
                    )])
                )
    


            match_sequence_ExceptHandler(stack_item, SequenceExceptHandlerHandlers(
                case_ConsExceptHandler = handle_ConsExceptHandler,
                case_SingleExceptHandler = handle_SingleExceptHandler
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_conditions(
    o : conditions | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[conditions | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, conditions):

            
            def handle_ElifCond(o : ElifCond): 
                
                stack.append(o.tail)

                stack.append(from_ElifBlock(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'conditions',
                        selection = 'ElifCond'
                    )])
                )
    

            def handle_ElseCond(o : ElseCond): 
                
                stack.append(from_ElseBlock(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'conditions',
                        selection = 'ElseCond'
                    )])
                )
    

            def handle_NoCond(o : NoCond): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'conditions',
                        selection = 'NoCond'
                    )])
                )
    


            match_conditions(stack_item, ConditionsHandlers(
                case_ElifCond = handle_ElifCond,
                case_ElseCond = handle_ElseCond,
                case_NoCond = handle_NoCond
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_function_def(
    o : function_def | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[function_def | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, function_def):

            
            def handle_FunctionDef(o : FunctionDef): 
                
                stack.append(from_statements(o.body))


                stack.append(from_return_annotation(o.ret_anno))


                stack.append(from_parameters(o.params))


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        

                stack.append(
                    tuple([make_Grammar(
                        options = 'function_def',
                        selection = 'FunctionDef'
                    )])
                )
    

            def handle_AsyncFunctionDef(o : AsyncFunctionDef): 
                
                stack.append(from_statements(o.body))


                stack.append(from_return_annotation(o.ret_anno))


                stack.append(from_parameters(o.params))


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        

                stack.append(
                    tuple([make_Grammar(
                        options = 'function_def',
                        selection = 'AsyncFunctionDef'
                    )])
                )
    


            match_function_def(stack_item, FunctionDefHandlers(
                case_FunctionDef = handle_FunctionDef,
                case_AsyncFunctionDef = handle_AsyncFunctionDef
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_stmt(
    o : stmt | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[stmt | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, stmt):

            
            def handle_DecFunctionDef(o : DecFunctionDef): 
                
                stack.append(from_function_def(o.fun_def))

                stack.append(from_decorators(o.decs))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'DecFunctionDef'
                    )])
                )
    

            def handle_DecClassDef(o : DecClassDef): 
                
                stack.append(from_ClassDef(o.class_def))

                stack.append(from_decorators(o.decs))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'DecClassDef'
                    )])
                )
    

            def handle_ReturnSomething(o : ReturnSomething): 
                
                stack.append(from_expr(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'ReturnSomething'
                    )])
                )
    

            def handle_Return(o : Return): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Return'
                    )])
                )
    

            def handle_Delete(o : Delete): 
                
                stack.append(from_comma_exprs(o.targets))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Delete'
                    )])
                )
    

            def handle_Assign(o : Assign): 
                
                stack.append(from_expr(o.content))


                stack.append(from_target_exprs(o.targets))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Assign'
                    )])
                )
    

            def handle_AugAssign(o : AugAssign): 
                
                stack.append(from_expr(o.content))


                stack.append(from_bin_rator(o.op))


                stack.append(from_expr(o.target))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AugAssign'
                    )])
                )
    

            def handle_AnnoAssign(o : AnnoAssign): 
                
                stack.append(from_expr(o.content))


                stack.append(from_expr(o.anno))


                stack.append(from_expr(o.target))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AnnoAssign'
                    )])
                )
    

            def handle_AnnoDeclar(o : AnnoDeclar): 
                
                stack.append(from_expr(o.anno))


                stack.append(from_expr(o.target))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AnnoDeclar'
                    )])
                )
    

            def handle_For(o : For): 
                
                stack.append(from_statements(o.body))


                stack.append(from_expr(o.iter))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'For'
                    )])
                )
    

            def handle_ForElse(o : ForElse): 
                
                stack.append(from_ElseBlock(o.orelse))

                stack.append(from_statements(o.body))


                stack.append(from_expr(o.iter))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'ForElse'
                    )])
                )
    

            def handle_AsyncFor(o : AsyncFor): 
                
                stack.append(from_statements(o.body))


                stack.append(from_expr(o.iter))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AsyncFor'
                    )])
                )
    

            def handle_AsyncForElse(o : AsyncForElse): 
                
                stack.append(from_ElseBlock(o.orelse))

                stack.append(from_statements(o.body))


                stack.append(from_expr(o.iter))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AsyncForElse'
                    )])
                )
    

            def handle_While(o : While): 
                
                stack.append(from_statements(o.body))


                stack.append(from_expr(o.test))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'While'
                    )])
                )
    

            def handle_WhileElse(o : WhileElse): 
                
                stack.append(from_ElseBlock(o.orelse))

                stack.append(from_statements(o.body))


                stack.append(from_expr(o.test))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'WhileElse'
                    )])
                )
    

            def handle_If(o : If): 
                
                stack.append(from_conditions(o.orelse))

                stack.append(from_statements(o.body))


                stack.append(from_expr(o.test))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'If'
                    )])
                )
    

            def handle_With(o : With): 
                
                stack.append(from_statements(o.body))


                stack.append(from_sequence_with_item(o.items))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'With'
                    )])
                )
    

            def handle_AsyncWith(o : AsyncWith): 
                
                stack.append(from_statements(o.body))


                stack.append(from_sequence_with_item(o.items))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AsyncWith'
                    )])
                )
    

            def handle_Raise(o : Raise): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Raise'
                    )])
                )
    

            def handle_RaiseExc(o : RaiseExc): 
                
                stack.append(from_expr(o.exc))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'RaiseExc'
                    )])
                )
    

            def handle_RaiseFrom(o : RaiseFrom): 
                
                stack.append(from_expr(o.caus))


                stack.append(from_expr(o.exc))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'RaiseFrom'
                    )])
                )
    

            def handle_Try(o : Try): 
                
                stack.append(from_sequence_ExceptHandler(o.handlers))

                stack.append(from_statements(o.body))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Try'
                    )])
                )
    

            def handle_TryElse(o : TryElse): 
                
                stack.append(from_ElseBlock(o.orelse))

                stack.append(from_sequence_ExceptHandler(o.handlers))

                stack.append(from_statements(o.body))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'TryElse'
                    )])
                )
    

            def handle_TryExceptFin(o : TryExceptFin): 
                
                stack.append(from_FinallyBlock(o.fin))

                stack.append(from_sequence_ExceptHandler(o.handlers))

                stack.append(from_statements(o.body))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'TryExceptFin'
                    )])
                )
    

            def handle_TryFin(o : TryFin): 
                
                stack.append(from_FinallyBlock(o.fin))

                stack.append(from_statements(o.body))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'TryFin'
                    )])
                )
    

            def handle_TryElseFin(o : TryElseFin): 
                
                stack.append(from_FinallyBlock(o.fin))

                stack.append(from_ElseBlock(o.orelse))

                stack.append(from_sequence_ExceptHandler(o.handlers))

                stack.append(from_statements(o.body))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'TryElseFin'
                    )])
                )
    

            def handle_Assert(o : Assert): 
                
                stack.append(from_expr(o.test))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Assert'
                    )])
                )
    

            def handle_AssertMsg(o : AssertMsg): 
                
                stack.append(from_expr(o.msg))


                stack.append(from_expr(o.test))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'AssertMsg'
                    )])
                )
    

            def handle_Import(o : Import): 
                
                stack.append(from_sequence_import_name(o.names))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Import'
                    )])
                )
    

            def handle_ImportFrom(o : ImportFrom): 
                
                stack.append(from_sequence_import_name(o.names))


                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.module
                    )])
                )
        

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'ImportFrom'
                    )])
                )
    

            def handle_ImportWildCard(o : ImportWildCard): 
                

                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.module
                    )])
                )
        

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'ImportWildCard'
                    )])
                )
    

            def handle_Global(o : Global): 
                
                stack.append(from_sequence_name(o.names))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Global'
                    )])
                )
    

            def handle_Nonlocal(o : Nonlocal): 
                
                stack.append(from_sequence_name(o.names))

                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Nonlocal'
                    )])
                )
    

            def handle_Expr(o : Expr): 
                
                stack.append(from_expr(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Expr'
                    )])
                )
    

            def handle_Pass(o : Pass): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Pass'
                    )])
                )
    

            def handle_Break(o : Break): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Break'
                    )])
                )
    

            def handle_Continue(o : Continue): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'stmt',
                        selection = 'Continue'
                    )])
                )
    


            match_stmt(stack_item, StmtHandlers(
                case_DecFunctionDef = handle_DecFunctionDef,
                case_DecClassDef = handle_DecClassDef,
                case_ReturnSomething = handle_ReturnSomething,
                case_Return = handle_Return,
                case_Delete = handle_Delete,
                case_Assign = handle_Assign,
                case_AugAssign = handle_AugAssign,
                case_AnnoAssign = handle_AnnoAssign,
                case_AnnoDeclar = handle_AnnoDeclar,
                case_For = handle_For,
                case_ForElse = handle_ForElse,
                case_AsyncFor = handle_AsyncFor,
                case_AsyncForElse = handle_AsyncForElse,
                case_While = handle_While,
                case_WhileElse = handle_WhileElse,
                case_If = handle_If,
                case_With = handle_With,
                case_AsyncWith = handle_AsyncWith,
                case_Raise = handle_Raise,
                case_RaiseExc = handle_RaiseExc,
                case_RaiseFrom = handle_RaiseFrom,
                case_Try = handle_Try,
                case_TryElse = handle_TryElse,
                case_TryExceptFin = handle_TryExceptFin,
                case_TryFin = handle_TryFin,
                case_TryElseFin = handle_TryElseFin,
                case_Assert = handle_Assert,
                case_AssertMsg = handle_AssertMsg,
                case_Import = handle_Import,
                case_ImportFrom = handle_ImportFrom,
                case_ImportWildCard = handle_ImportWildCard,
                case_Global = handle_Global,
                case_Nonlocal = handle_Nonlocal,
                case_Expr = handle_Expr,
                case_Pass = handle_Pass,
                case_Break = handle_Break,
                case_Continue = handle_Continue
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_expr(
    o : expr | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[expr | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, expr):

            
            def handle_BoolOp(o : BoolOp): 
                

                stack.append(o.right)


                stack.append(from_bool_rator(o.op))


                stack.append(o.left)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'BoolOp'
                    )])
                )
    

            def handle_AssignExpr(o : AssignExpr): 
                
                stack.append(o.content)


                stack.append(o.target)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'AssignExpr'
                    )])
                )
    

            def handle_BinOp(o : BinOp): 
                

                stack.append(o.right)


                stack.append(from_bin_rator(o.rator))


                stack.append(o.left)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'BinOp'
                    )])
                )
    

            def handle_UnaryOp(o : UnaryOp): 
                

                stack.append(o.rand)


                stack.append(from_unary_rator(o.rator))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'UnaryOp'
                    )])
                )
    

            def handle_Lambda(o : Lambda): 
                
                stack.append(o.body)


                stack.append(from_parameters(o.params))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Lambda'
                    )])
                )
    

            def handle_IfExp(o : IfExp): 
                
                stack.append(o.orelse)


                stack.append(o.test)


                stack.append(o.body)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'IfExp'
                    )])
                )
    

            def handle_Dictionary(o : Dictionary): 
                

                stack.append(from_dictionary_content(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Dictionary'
                    )])
                )
    

            def handle_EmptyDictionary(o : EmptyDictionary): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'EmptyDictionary'
                    )])
                )
    

            def handle_Set(o : Set): 
                

                stack.append(from_comma_exprs(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Set'
                    )])
                )
    

            def handle_ListComp(o : ListComp): 
                

                stack.append(from_comprehension_constraints(o.constraints))

                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'ListComp'
                    )])
                )
    

            def handle_SetComp(o : SetComp): 
                

                stack.append(from_comprehension_constraints(o.constraints))

                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'SetComp'
                    )])
                )
    

            def handle_DictionaryComp(o : DictionaryComp): 
                

                stack.append(from_comprehension_constraints(o.constraints))

                stack.append(o.content)


                stack.append(o.key)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'DictionaryComp'
                    )])
                )
    

            def handle_GeneratorExp(o : GeneratorExp): 
                

                stack.append(from_comprehension_constraints(o.constraints))

                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'GeneratorExp'
                    )])
                )
    

            def handle_Await(o : Await): 
                
                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Await'
                    )])
                )
    

            def handle_YieldNothing(o : YieldNothing): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'YieldNothing'
                    )])
                )
    

            def handle_Yield(o : Yield): 
                
                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Yield'
                    )])
                )
    

            def handle_YieldFrom(o : YieldFrom): 
                
                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'YieldFrom'
                    )])
                )
    

            def handle_Compare(o : Compare): 
                
                stack.append(from_comparisons(o.comps))


                stack.append(o.left)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Compare'
                    )])
                )
    

            def handle_Call(o : Call): 
                

                stack.append(o.func)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Call'
                    )])
                )
    

            def handle_CallArgs(o : CallArgs): 
                

                stack.append(from_arguments(o.args))


                stack.append(o.func)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'CallArgs'
                    )])
                )
    

            def handle_Integer(o : Integer): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'integer',
                        selection = o.content
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Integer'
                    )])
                )
    

            def handle_Float(o : Float): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'float',
                        selection = o.content
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Float'
                    )])
                )
    

            def handle_ConcatString(o : ConcatString): 
                
                stack.append(from_sequence_string(o.content))
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'ConcatString'
                    )])
                )
    

            def handle_True_(o : True_): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'True_'
                    )])
                )
    

            def handle_False_(o : False_): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'False_'
                    )])
                )
    

            def handle_None_(o : None_): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'None_'
                    )])
                )
    

            def handle_Ellip(o : Ellip): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Ellip'
                    )])
                )
    

            def handle_Attribute(o : Attribute): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.name
                    )])
                )
        


                stack.append(o.content)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Attribute'
                    )])
                )
    

            def handle_Subscript(o : Subscript): 
                

                stack.append(o.slice)


                stack.append(o.content)
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Subscript'
                    )])
                )
    

            def handle_Starred(o : Starred): 
                
                stack.append(o.content)

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Starred'
                    )])
                )
    

            def handle_Name(o : Name): 
                
                stack.append(
                    tuple([make_Vocab(
                        options = 'identifier',
                        selection = o.content
                    )])
                )
        
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Name'
                    )])
                )
    

            def handle_List(o : List): 
                

                stack.append(from_comma_exprs(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'List'
                    )])
                )
    

            def handle_EmptyList(o : EmptyList): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'EmptyList'
                    )])
                )
    

            def handle_Tuple(o : Tuple): 
                

                stack.append(from_comma_exprs(o.content))

                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Tuple'
                    )])
                )
    

            def handle_EmptyTuple(o : EmptyTuple): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'EmptyTuple'
                    )])
                )
    

            def handle_Slice(o : Slice): 
                
                stack.append(from_option_expr(o.step))


                stack.append(from_option_expr(o.upper))


                stack.append(from_option_expr(o.lower))
                stack.append(
                    tuple([make_Grammar(
                        options = 'expr',
                        selection = 'Slice'
                    )])
                )
    


            match_expr(stack_item, ExprHandlers(
                case_BoolOp = handle_BoolOp,
                case_AssignExpr = handle_AssignExpr,
                case_BinOp = handle_BinOp,
                case_UnaryOp = handle_UnaryOp,
                case_Lambda = handle_Lambda,
                case_IfExp = handle_IfExp,
                case_Dictionary = handle_Dictionary,
                case_EmptyDictionary = handle_EmptyDictionary,
                case_Set = handle_Set,
                case_ListComp = handle_ListComp,
                case_SetComp = handle_SetComp,
                case_DictionaryComp = handle_DictionaryComp,
                case_GeneratorExp = handle_GeneratorExp,
                case_Await = handle_Await,
                case_YieldNothing = handle_YieldNothing,
                case_Yield = handle_Yield,
                case_YieldFrom = handle_YieldFrom,
                case_Compare = handle_Compare,
                case_Call = handle_Call,
                case_CallArgs = handle_CallArgs,
                case_Integer = handle_Integer,
                case_Float = handle_Float,
                case_ConcatString = handle_ConcatString,
                case_True_ = handle_True_,
                case_False_ = handle_False_,
                case_None_ = handle_None_,
                case_Ellip = handle_Ellip,
                case_Attribute = handle_Attribute,
                case_Subscript = handle_Subscript,
                case_Starred = handle_Starred,
                case_Name = handle_Name,
                case_List = handle_List,
                case_EmptyList = handle_EmptyList,
                case_Tuple = handle_Tuple,
                case_EmptyTuple = handle_EmptyTuple,
                case_Slice = handle_Slice
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_bool_rator(
    o : bool_rator | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[bool_rator | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, bool_rator):

            
            def handle_And(o : And): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bool_rator',
                        selection = 'And'
                    )])
                )
    

            def handle_Or(o : Or): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bool_rator',
                        selection = 'Or'
                    )])
                )
    


            match_bool_rator(stack_item, BoolRatorHandlers(
                case_And = handle_And,
                case_Or = handle_Or
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_bin_rator(
    o : bin_rator | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[bin_rator | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, bin_rator):

            
            def handle_Add(o : Add): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Add'
                    )])
                )
    

            def handle_Sub(o : Sub): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Sub'
                    )])
                )
    

            def handle_Mult(o : Mult): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Mult'
                    )])
                )
    

            def handle_MatMult(o : MatMult): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'MatMult'
                    )])
                )
    

            def handle_Div(o : Div): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Div'
                    )])
                )
    

            def handle_Mod(o : Mod): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Mod'
                    )])
                )
    

            def handle_Pow(o : Pow): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'Pow'
                    )])
                )
    

            def handle_LShift(o : LShift): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'LShift'
                    )])
                )
    

            def handle_RShift(o : RShift): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'RShift'
                    )])
                )
    

            def handle_BitOr(o : BitOr): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'BitOr'
                    )])
                )
    

            def handle_BitXor(o : BitXor): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'BitXor'
                    )])
                )
    

            def handle_BitAnd(o : BitAnd): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'BitAnd'
                    )])
                )
    

            def handle_FloorDiv(o : FloorDiv): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'bin_rator',
                        selection = 'FloorDiv'
                    )])
                )
    


            match_bin_rator(stack_item, BinRatorHandlers(
                case_Add = handle_Add,
                case_Sub = handle_Sub,
                case_Mult = handle_Mult,
                case_MatMult = handle_MatMult,
                case_Div = handle_Div,
                case_Mod = handle_Mod,
                case_Pow = handle_Pow,
                case_LShift = handle_LShift,
                case_RShift = handle_RShift,
                case_BitOr = handle_BitOr,
                case_BitXor = handle_BitXor,
                case_BitAnd = handle_BitAnd,
                case_FloorDiv = handle_FloorDiv
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_unary_rator(
    o : unary_rator | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[unary_rator | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, unary_rator):

            
            def handle_Invert(o : Invert): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'unary_rator',
                        selection = 'Invert'
                    )])
                )
    

            def handle_Not(o : Not): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'unary_rator',
                        selection = 'Not'
                    )])
                )
    

            def handle_UAdd(o : UAdd): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'unary_rator',
                        selection = 'UAdd'
                    )])
                )
    

            def handle_USub(o : USub): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'unary_rator',
                        selection = 'USub'
                    )])
                )
    


            match_unary_rator(stack_item, UnaryRatorHandlers(
                case_Invert = handle_Invert,
                case_Not = handle_Not,
                case_UAdd = handle_UAdd,
                case_USub = handle_USub
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_cmp_rator(
    o : cmp_rator | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[cmp_rator | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, cmp_rator):

            
            def handle_Eq(o : Eq): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'Eq'
                    )])
                )
    

            def handle_NotEq(o : NotEq): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'NotEq'
                    )])
                )
    

            def handle_Lt(o : Lt): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'Lt'
                    )])
                )
    

            def handle_LtE(o : LtE): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'LtE'
                    )])
                )
    

            def handle_Gt(o : Gt): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'Gt'
                    )])
                )
    

            def handle_GtE(o : GtE): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'GtE'
                    )])
                )
    

            def handle_Is(o : Is): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'Is'
                    )])
                )
    

            def handle_IsNot(o : IsNot): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'IsNot'
                    )])
                )
    

            def handle_In(o : In): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'In'
                    )])
                )
    

            def handle_NotIn(o : NotIn): 
                
                stack.append(
                    tuple([make_Grammar(
                        options = 'cmp_rator',
                        selection = 'NotIn'
                    )])
                )
    


            match_cmp_rator(stack_item, CmpRatorHandlers(
                case_Eq = handle_Eq,
                case_NotEq = handle_NotEq,
                case_Lt = handle_Lt,
                case_LtE = handle_LtE,
                case_Gt = handle_Gt,
                case_GtE = handle_GtE,
                case_Is = handle_Is,
                case_IsNot = handle_IsNot,
                case_In = handle_In,
                case_NotIn = handle_NotIn
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
    


def from_constraint(
    o : constraint | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    result = () 

    stack : list[constraint | None | tuple[abstract_token, ...]] = [o]
    while stack:
        stack_item = stack.pop()
        if isinstance(stack_item, constraint):

            
            def handle_AsyncConstraint(o : AsyncConstraint): 
                
                stack.append(from_constraint_filters(o.filts))

                stack.append(from_expr(o.search_space))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'constraint',
                        selection = 'AsyncConstraint'
                    )])
                )
    

            def handle_Constraint(o : Constraint): 
                
                stack.append(from_constraint_filters(o.filts))

                stack.append(from_expr(o.search_space))


                stack.append(from_expr(o.target))

                stack.append(
                    tuple([make_Grammar(
                        options = 'constraint',
                        selection = 'Constraint'
                    )])
                )
    


            match_constraint(stack_item, ConstraintHandlers(
                case_AsyncConstraint = handle_AsyncConstraint,
                case_Constraint = handle_Constraint
            ))

        elif stack_item == None:
            result += (Hole(),) 
        else:
            result += stack_item 

    return result
     



def from_CompareRight(
    o : CompareRight | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'CompareRight',
            selection = 'CompareRight'
        )]) +

        from_cmp_rator(o.rator) +
        from_expr(o.rand)

    )
    


def from_ExceptHandler(
    o : ExceptHandler | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'ExceptHandler',
            selection = 'ExceptHandler'
        )]) +

        from_except_arg(o.arg) +
        from_statements(o.body)

    )
    


def from_Param(
    o : Param | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'Param',
            selection = 'Param'
        )]) +

        tuple([make_Vocab(options = 'identifier', selection = o.name)]) +
        from_param_annotation(o.anno) +
        from_param_default(o.default)

    )
    


def from_ClassDef(
    o : ClassDef | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'ClassDef',
            selection = 'ClassDef'
        )]) +

        tuple([make_Vocab(options = 'identifier', selection = o.name)]) +
        from_bases(o.bs) +
        from_statements(o.body)

    )
    


def from_ElifBlock(
    o : ElifBlock | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'ElifBlock',
            selection = 'ElifBlock'
        )]) +

        from_expr(o.test) +
        from_statements(o.body)

    )
    


def from_ElseBlock(
    o : ElseBlock | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'ElseBlock',
            selection = 'ElseBlock'
        )]) +

        from_statements(o.body)

    )
    


def from_FinallyBlock(
    o : FinallyBlock | None
) -> tuple[abstract_token, ...]:
    if o == None:
        return (Hole(),)

    return (
        tuple([make_Grammar(
            options = 'FinallyBlock',
            selection = 'FinallyBlock'
        )]) +

        from_statements(o.body)

    )
     

    