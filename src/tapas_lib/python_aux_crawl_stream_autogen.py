# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from abc import ABC, abstractmethod
from typing import Dict, TypeVar, Any, Generic, Union, Optional, Iterable
from collections.abc import Callable

from tapas_base.abstract_token_construct_autogen import abstract_token, Vocab, Grammar, make_Grammar

from queue import Queue



from tapas_lib.python_ast_construct_autogen import * 
        

InherAux = TypeVar('InherAux') 
SynthAux = TypeVar('SynthAux') 

class SyntaxError(Exception):
    pass

@dataclass(frozen=True, eq=True)
class Result(Generic[SynthAux]):
    tree : ast
    aux : SynthAux


class Server(ABC, Generic[InherAux, SynthAux]): 

    def __init__(self, in_stream : Queue[abstract_token | Exception], out_stream : Queue[InherAux | Exception]):  

        def next(inher_aux : InherAux) -> abstract_token: 
            out_stream.put(inher_aux)
            tok = in_stream.get()
            if isinstance(tok, Exception):
                raise tok
            else:
                return tok

        self.next = next


    
    # inspect return_annotation"
    def inspect_return_annotation(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "return_annotation": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeReturnAnno":
            return self.inspect_return_annotation_SomeReturnAnno(inher_aux)
            

        elif token.selection == "NoReturnAnno":
            return self.inspect_return_annotation_NoReturnAnno(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_return_annotation(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_return_annotation(token, inher_aux)

    
    # inspect except_arg"
    def inspect_except_arg(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "except_arg": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeExceptArg":
            return self.inspect_except_arg_SomeExceptArg(inher_aux)
            

        elif token.selection == "SomeExceptArgName":
            return self.inspect_except_arg_SomeExceptArgName(inher_aux)
            

        elif token.selection == "NoExceptArg":
            return self.inspect_except_arg_NoExceptArg(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_except_arg(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_except_arg(token, inher_aux)

    
    # inspect param_annotation"
    def inspect_param_annotation(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "param_annotation": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeParamAnno":
            return self.inspect_param_annotation_SomeParamAnno(inher_aux)
            

        elif token.selection == "NoParamAnno":
            return self.inspect_param_annotation_NoParamAnno(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_param_annotation(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_param_annotation(token, inher_aux)

    
    # inspect param_default"
    def inspect_param_default(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "param_default": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeParamDefault":
            return self.inspect_param_default_SomeParamDefault(inher_aux)
            

        elif token.selection == "NoParamDefault":
            return self.inspect_param_default_NoParamDefault(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_param_default(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_param_default(token, inher_aux)

     # inspect: parameters_d
    def inspect_parameters_d(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "parameters_d": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsKwParam": 
            return self.inspect_parameters_d_ConsKwParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleKwParam": 
            return self.inspect_parameters_d_SingleKwParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "TransKwParam": 
            return self.inspect_parameters_d_TransKwParam(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_parameters_d(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_parameters_d(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect parameters_c"
    def inspect_parameters_c(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "parameters_c": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SingleTupleBundleParam":
            return self.inspect_parameters_c_SingleTupleBundleParam(inher_aux)
            

        elif token.selection == "TransTupleBundleParam":
            return self.inspect_parameters_c_TransTupleBundleParam(inher_aux)
            

        elif token.selection == "ParamsD":
            return self.inspect_parameters_c_ParamsD(inher_aux)
            

        elif token.selection == "DoubleBundleParam":
            return self.inspect_parameters_c_DoubleBundleParam(inher_aux)
            

        elif token.selection == "DictionaryBundleParam":
            return self.inspect_parameters_c_DictionaryBundleParam(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_parameters_c(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_parameters_c(token, inher_aux)

     # inspect: parameters_b
    def inspect_parameters_b(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "parameters_b": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsPosKeyParam": 
            return self.inspect_parameters_b_ConsPosKeyParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SinglePosKeyParam": 
            return self.inspect_parameters_b_SinglePosKeyParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "ParamsC": 
            return self.inspect_parameters_b_ParamsC(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_parameters_b(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_parameters_b(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: parameters_a
    def inspect_parameters_a(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "parameters_a": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsPosParam": 
            return self.inspect_parameters_a_ConsPosParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SinglePosParam": 
            return self.inspect_parameters_a_SinglePosParam(inher_aux, children, stack_result, stack)
            

        elif rule_name == "TransPosParam": 
            return self.inspect_parameters_a_TransPosParam(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_parameters_a(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_parameters_a(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect parameters"
    def inspect_parameters(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "parameters": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "ParamsA":
            return self.inspect_parameters_ParamsA(inher_aux)
            

        elif token.selection == "ParamsB":
            return self.inspect_parameters_ParamsB(inher_aux)
            

        elif token.selection == "NoParam":
            return self.inspect_parameters_NoParam(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_parameters(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_parameters(token, inher_aux)

    
    # inspect keyword"
    def inspect_keyword(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "keyword": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "NamedKeyword":
            return self.inspect_keyword_NamedKeyword(inher_aux)
            

        elif token.selection == "SplatKeyword":
            return self.inspect_keyword_SplatKeyword(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_keyword(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_keyword(token, inher_aux)

    
    # inspect import_name"
    def inspect_import_name(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "import_name": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "ImportNameAlias":
            return self.inspect_import_name_ImportNameAlias(inher_aux)
            

        elif token.selection == "ImportNameOnly":
            return self.inspect_import_name_ImportNameOnly(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_import_name(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_import_name(token, inher_aux)

    
    # inspect with_item"
    def inspect_with_item(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "with_item": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "WithItemAlias":
            return self.inspect_with_item_WithItemAlias(inher_aux)
            

        elif token.selection == "WithItemOnly":
            return self.inspect_with_item_WithItemOnly(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_with_item(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_with_item(token, inher_aux)

    
    # inspect bases"
    def inspect_bases(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "bases": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeBases":
            return self.inspect_bases_SomeBases(inher_aux)
            

        elif token.selection == "NoBases":
            return self.inspect_bases_NoBases(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_bases(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_bases(token, inher_aux)

     # inspect: bases_a
    def inspect_bases_a(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "bases_a": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsBase": 
            return self.inspect_bases_a_ConsBase(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleBase": 
            return self.inspect_bases_a_SingleBase(inher_aux, children, stack_result, stack)
            

        elif rule_name == "KeywordBases": 
            return self.inspect_bases_a_KeywordBases(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_bases_a(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_bases_a(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: keywords
    def inspect_keywords(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "keywords": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsKeyword": 
            return self.inspect_keywords_ConsKeyword(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleKeyword": 
            return self.inspect_keywords_SingleKeyword(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_keywords(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_keywords(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: comparisons
    def inspect_comparisons(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "comparisons": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsCompareRight": 
            return self.inspect_comparisons_ConsCompareRight(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleCompareRight": 
            return self.inspect_comparisons_SingleCompareRight(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_comparisons(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_comparisons(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect option_expr"
    def inspect_option_expr(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "option_expr": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "SomeExpr":
            return self.inspect_option_expr_SomeExpr(inher_aux)
            

        elif token.selection == "NoExpr":
            return self.inspect_option_expr_NoExpr(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_option_expr(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_option_expr(token, inher_aux)

     # inspect: comma_exprs
    def inspect_comma_exprs(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "comma_exprs": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsExpr": 
            return self.inspect_comma_exprs_ConsExpr(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleExpr": 
            return self.inspect_comma_exprs_SingleExpr(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_comma_exprs(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_comma_exprs(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: target_exprs
    def inspect_target_exprs(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "target_exprs": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsTargetExpr": 
            return self.inspect_target_exprs_ConsTargetExpr(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleTargetExpr": 
            return self.inspect_target_exprs_SingleTargetExpr(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_target_exprs(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_target_exprs(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect decorator"
    def inspect_decorator(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "decorator": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "ExprDec":
            return self.inspect_decorator_ExprDec(inher_aux)
            

        elif token.selection == "CmntDec":
            return self.inspect_decorator_CmntDec(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_decorator(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_decorator(token, inher_aux)

     # inspect: decorators
    def inspect_decorators(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "decorators": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsDec": 
            return self.inspect_decorators_ConsDec(inher_aux, children, stack_result, stack)
            

        elif rule_name == "NoDec": 
            return self.inspect_decorators_NoDec(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_decorators(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_decorators(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: constraint_filters
    def inspect_constraint_filters(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "constraint_filters": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsFilter": 
            return self.inspect_constraint_filters_ConsFilter(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleFilter": 
            return self.inspect_constraint_filters_SingleFilter(inher_aux, children, stack_result, stack)
            

        elif rule_name == "NoFilter": 
            return self.inspect_constraint_filters_NoFilter(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_constraint_filters(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_constraint_filters(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: sequence_string
    def inspect_sequence_string(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "sequence_string": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsStr": 
            return self.inspect_sequence_string_ConsStr(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleStr": 
            return self.inspect_sequence_string_SingleStr(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_sequence_string(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_sequence_string(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: arguments
    def inspect_arguments(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "arguments": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsArg": 
            return self.inspect_arguments_ConsArg(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleArg": 
            return self.inspect_arguments_SingleArg(inher_aux, children, stack_result, stack)
            

        elif rule_name == "KeywordsArg": 
            return self.inspect_arguments_KeywordsArg(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_arguments(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_arguments(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect dictionary_item"
    def inspect_dictionary_item(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "dictionary_item": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "Field":
            return self.inspect_dictionary_item_Field(inher_aux)
            

        elif token.selection == "DictionarySplatFields":
            return self.inspect_dictionary_item_DictionarySplatFields(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_dictionary_item(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_dictionary_item(token, inher_aux)

     # inspect: dictionary_content
    def inspect_dictionary_content(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "dictionary_content": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsDictionaryItem": 
            return self.inspect_dictionary_content_ConsDictionaryItem(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleDictionaryItem": 
            return self.inspect_dictionary_content_SingleDictionaryItem(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_dictionary_content(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_dictionary_content(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: sequence_name
    def inspect_sequence_name(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "sequence_name": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsId": 
            return self.inspect_sequence_name_ConsId(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleId": 
            return self.inspect_sequence_name_SingleId(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_sequence_name(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_sequence_name(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: sequence_import_name
    def inspect_sequence_import_name(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "sequence_import_name": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsImportName": 
            return self.inspect_sequence_import_name_ConsImportName(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleImportName": 
            return self.inspect_sequence_import_name_SingleImportName(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_sequence_import_name(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_sequence_import_name(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: sequence_with_item
    def inspect_sequence_with_item(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "sequence_with_item": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsWithItem": 
            return self.inspect_sequence_with_item_ConsWithItem(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleWithItem": 
            return self.inspect_sequence_with_item_SingleWithItem(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_sequence_with_item(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_sequence_with_item(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect module"
    def inspect_module(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "module": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "FutureMod":
            return self.inspect_module_FutureMod(inher_aux)
            

        elif token.selection == "SimpleMod":
            return self.inspect_module_SimpleMod(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_module(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_module(token, inher_aux)

     # inspect: statements
    def inspect_statements(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "statements": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsStmt": 
            return self.inspect_statements_ConsStmt(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleStmt": 
            return self.inspect_statements_SingleStmt(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_statements(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_statements(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: comprehension_constraints
    def inspect_comprehension_constraints(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "comprehension_constraints": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsConstraint": 
            return self.inspect_comprehension_constraints_ConsConstraint(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleConstraint": 
            return self.inspect_comprehension_constraints_SingleConstraint(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_comprehension_constraints(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_comprehension_constraints(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: sequence_ExceptHandler
    def inspect_sequence_ExceptHandler(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "sequence_ExceptHandler": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ConsExceptHandler": 
            return self.inspect_sequence_ExceptHandler_ConsExceptHandler(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SingleExceptHandler": 
            return self.inspect_sequence_ExceptHandler_SingleExceptHandler(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_sequence_ExceptHandler(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_sequence_ExceptHandler(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

     # inspect: conditions
    def inspect_conditions(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "conditions": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ElifCond": 
            return self.inspect_conditions_ElifCond(inher_aux, children, stack_result, stack)
            

        elif rule_name == "ElseCond": 
            return self.inspect_conditions_ElseCond(inher_aux, children, stack_result, stack)
            

        elif rule_name == "NoCond": 
            return self.inspect_conditions_NoCond(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_conditions(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_conditions(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect function_def"
    def inspect_function_def(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "function_def": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "FunctionDef":
            return self.inspect_function_def_FunctionDef(inher_aux)
            

        elif token.selection == "AsyncFunctionDef":
            return self.inspect_function_def_AsyncFunctionDef(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_function_def(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_function_def(token, inher_aux)

    
    # inspect stmt"
    def inspect_stmt(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "stmt": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "Comment":
            return self.inspect_stmt_Comment(inher_aux)
            

        elif token.selection == "DecFunctionDef":
            return self.inspect_stmt_DecFunctionDef(inher_aux)
            

        elif token.selection == "DecClassDef":
            return self.inspect_stmt_DecClassDef(inher_aux)
            

        elif token.selection == "ReturnSomething":
            return self.inspect_stmt_ReturnSomething(inher_aux)
            

        elif token.selection == "Return":
            return self.inspect_stmt_Return(inher_aux)
            

        elif token.selection == "Delete":
            return self.inspect_stmt_Delete(inher_aux)
            

        elif token.selection == "Assign":
            return self.inspect_stmt_Assign(inher_aux)
            

        elif token.selection == "AugAssign":
            return self.inspect_stmt_AugAssign(inher_aux)
            

        elif token.selection == "AnnoAssign":
            return self.inspect_stmt_AnnoAssign(inher_aux)
            

        elif token.selection == "AnnoDeclar":
            return self.inspect_stmt_AnnoDeclar(inher_aux)
            

        elif token.selection == "For":
            return self.inspect_stmt_For(inher_aux)
            

        elif token.selection == "ForElse":
            return self.inspect_stmt_ForElse(inher_aux)
            

        elif token.selection == "AsyncFor":
            return self.inspect_stmt_AsyncFor(inher_aux)
            

        elif token.selection == "AsyncForElse":
            return self.inspect_stmt_AsyncForElse(inher_aux)
            

        elif token.selection == "While":
            return self.inspect_stmt_While(inher_aux)
            

        elif token.selection == "WhileElse":
            return self.inspect_stmt_WhileElse(inher_aux)
            

        elif token.selection == "If":
            return self.inspect_stmt_If(inher_aux)
            

        elif token.selection == "With":
            return self.inspect_stmt_With(inher_aux)
            

        elif token.selection == "AsyncWith":
            return self.inspect_stmt_AsyncWith(inher_aux)
            

        elif token.selection == "Raise":
            return self.inspect_stmt_Raise(inher_aux)
            

        elif token.selection == "RaiseExc":
            return self.inspect_stmt_RaiseExc(inher_aux)
            

        elif token.selection == "RaiseFrom":
            return self.inspect_stmt_RaiseFrom(inher_aux)
            

        elif token.selection == "Try":
            return self.inspect_stmt_Try(inher_aux)
            

        elif token.selection == "TryElse":
            return self.inspect_stmt_TryElse(inher_aux)
            

        elif token.selection == "TryExceptFin":
            return self.inspect_stmt_TryExceptFin(inher_aux)
            

        elif token.selection == "TryFin":
            return self.inspect_stmt_TryFin(inher_aux)
            

        elif token.selection == "TryElseFin":
            return self.inspect_stmt_TryElseFin(inher_aux)
            

        elif token.selection == "Assert":
            return self.inspect_stmt_Assert(inher_aux)
            

        elif token.selection == "AssertMsg":
            return self.inspect_stmt_AssertMsg(inher_aux)
            

        elif token.selection == "Import":
            return self.inspect_stmt_Import(inher_aux)
            

        elif token.selection == "ImportFrom":
            return self.inspect_stmt_ImportFrom(inher_aux)
            

        elif token.selection == "ImportWildCard":
            return self.inspect_stmt_ImportWildCard(inher_aux)
            

        elif token.selection == "Global":
            return self.inspect_stmt_Global(inher_aux)
            

        elif token.selection == "Nonlocal":
            return self.inspect_stmt_Nonlocal(inher_aux)
            

        elif token.selection == "Expr":
            return self.inspect_stmt_Expr(inher_aux)
            

        elif token.selection == "Pass":
            return self.inspect_stmt_Pass(inher_aux)
            

        elif token.selection == "Break":
            return self.inspect_stmt_Break(inher_aux)
            

        elif token.selection == "Continue":
            return self.inspect_stmt_Continue(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_stmt(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_stmt(token, inher_aux)

     # inspect: expr
    def inspect_expr(self, 
        token : Grammar, 
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:
        if token.options != "expr": raise SyntaxError()
        rule_name = token.selection

        if False: 
            pass
        
        elif rule_name == "ParenExpr": 
            return self.inspect_expr_ParenExpr(inher_aux, children, stack_result, stack)
            

        elif rule_name == "BoolOp": 
            return self.inspect_expr_BoolOp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "AssignExpr": 
            return self.inspect_expr_AssignExpr(inher_aux, children, stack_result, stack)
            

        elif rule_name == "BinOp": 
            return self.inspect_expr_BinOp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "UnaryOp": 
            return self.inspect_expr_UnaryOp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Lambda": 
            return self.inspect_expr_Lambda(inher_aux, children, stack_result, stack)
            

        elif rule_name == "IfExp": 
            return self.inspect_expr_IfExp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Dictionary": 
            return self.inspect_expr_Dictionary(inher_aux, children, stack_result, stack)
            

        elif rule_name == "EmptyDictionary": 
            return self.inspect_expr_EmptyDictionary(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Set": 
            return self.inspect_expr_Set(inher_aux, children, stack_result, stack)
            

        elif rule_name == "ListComp": 
            return self.inspect_expr_ListComp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "SetComp": 
            return self.inspect_expr_SetComp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "DictionaryComp": 
            return self.inspect_expr_DictionaryComp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "GeneratorExp": 
            return self.inspect_expr_GeneratorExp(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Await": 
            return self.inspect_expr_Await(inher_aux, children, stack_result, stack)
            

        elif rule_name == "YieldNothing": 
            return self.inspect_expr_YieldNothing(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Yield": 
            return self.inspect_expr_Yield(inher_aux, children, stack_result, stack)
            

        elif rule_name == "YieldFrom": 
            return self.inspect_expr_YieldFrom(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Compare": 
            return self.inspect_expr_Compare(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Call": 
            return self.inspect_expr_Call(inher_aux, children, stack_result, stack)
            

        elif rule_name == "CallArgs": 
            return self.inspect_expr_CallArgs(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Integer": 
            return self.inspect_expr_Integer(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Float": 
            return self.inspect_expr_Float(inher_aux, children, stack_result, stack)
            

        elif rule_name == "ConcatString": 
            return self.inspect_expr_ConcatString(inher_aux, children, stack_result, stack)
            

        elif rule_name == "True_": 
            return self.inspect_expr_True_(inher_aux, children, stack_result, stack)
            

        elif rule_name == "False_": 
            return self.inspect_expr_False_(inher_aux, children, stack_result, stack)
            

        elif rule_name == "None_": 
            return self.inspect_expr_None_(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Ellip": 
            return self.inspect_expr_Ellip(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Attribute": 
            return self.inspect_expr_Attribute(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Subscript": 
            return self.inspect_expr_Subscript(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Starred": 
            return self.inspect_expr_Starred(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Name": 
            return self.inspect_expr_Name(inher_aux, children, stack_result, stack)
            

        elif rule_name == "List": 
            return self.inspect_expr_List(inher_aux, children, stack_result, stack)
            

        elif rule_name == "EmptyList": 
            return self.inspect_expr_EmptyList(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Tuple": 
            return self.inspect_expr_Tuple(inher_aux, children, stack_result, stack)
            

        elif rule_name == "EmptyTuple": 
            return self.inspect_expr_EmptyTuple(inher_aux, children, stack_result, stack)
            

        elif rule_name == "Slice": 
            return self.inspect_expr_Slice(inher_aux, children, stack_result, stack)
            
        else:
            raise SyntaxError()



    def crawl_expr(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:

        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]] = [(token, inher_aux, ())]

        stack_result : Optional[Result[SynthAux]] = None 
        while stack:

            (token, inher_aux, children) = stack.pop()

            if not isinstance(token, Grammar): raise SyntaxError()
            stack_result = self.inspect_expr(token, inher_aux, children, stack_result, stack)

        assert stack_result
        return stack_result

    
    # inspect bool_rator"
    def inspect_bool_rator(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "bool_rator": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "And":
            return self.inspect_bool_rator_And(inher_aux)
            

        elif token.selection == "Or":
            return self.inspect_bool_rator_Or(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_bool_rator(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_bool_rator(token, inher_aux)

    
    # inspect bin_rator"
    def inspect_bin_rator(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "bin_rator": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "Add":
            return self.inspect_bin_rator_Add(inher_aux)
            

        elif token.selection == "Sub":
            return self.inspect_bin_rator_Sub(inher_aux)
            

        elif token.selection == "Mult":
            return self.inspect_bin_rator_Mult(inher_aux)
            

        elif token.selection == "MatMult":
            return self.inspect_bin_rator_MatMult(inher_aux)
            

        elif token.selection == "Div":
            return self.inspect_bin_rator_Div(inher_aux)
            

        elif token.selection == "Mod":
            return self.inspect_bin_rator_Mod(inher_aux)
            

        elif token.selection == "Pow":
            return self.inspect_bin_rator_Pow(inher_aux)
            

        elif token.selection == "LShift":
            return self.inspect_bin_rator_LShift(inher_aux)
            

        elif token.selection == "RShift":
            return self.inspect_bin_rator_RShift(inher_aux)
            

        elif token.selection == "BitOr":
            return self.inspect_bin_rator_BitOr(inher_aux)
            

        elif token.selection == "BitXor":
            return self.inspect_bin_rator_BitXor(inher_aux)
            

        elif token.selection == "BitAnd":
            return self.inspect_bin_rator_BitAnd(inher_aux)
            

        elif token.selection == "FloorDiv":
            return self.inspect_bin_rator_FloorDiv(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_bin_rator(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_bin_rator(token, inher_aux)

    
    # inspect unary_rator"
    def inspect_unary_rator(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "unary_rator": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "Invert":
            return self.inspect_unary_rator_Invert(inher_aux)
            

        elif token.selection == "Not":
            return self.inspect_unary_rator_Not(inher_aux)
            

        elif token.selection == "UAdd":
            return self.inspect_unary_rator_UAdd(inher_aux)
            

        elif token.selection == "USub":
            return self.inspect_unary_rator_USub(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_unary_rator(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_unary_rator(token, inher_aux)

    
    # inspect cmp_rator"
    def inspect_cmp_rator(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "cmp_rator": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "Eq":
            return self.inspect_cmp_rator_Eq(inher_aux)
            

        elif token.selection == "NotEq":
            return self.inspect_cmp_rator_NotEq(inher_aux)
            

        elif token.selection == "Lt":
            return self.inspect_cmp_rator_Lt(inher_aux)
            

        elif token.selection == "LtE":
            return self.inspect_cmp_rator_LtE(inher_aux)
            

        elif token.selection == "Gt":
            return self.inspect_cmp_rator_Gt(inher_aux)
            

        elif token.selection == "GtE":
            return self.inspect_cmp_rator_GtE(inher_aux)
            

        elif token.selection == "Is":
            return self.inspect_cmp_rator_Is(inher_aux)
            

        elif token.selection == "IsNot":
            return self.inspect_cmp_rator_IsNot(inher_aux)
            

        elif token.selection == "In":
            return self.inspect_cmp_rator_In(inher_aux)
            

        elif token.selection == "NotIn":
            return self.inspect_cmp_rator_NotIn(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_cmp_rator(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_cmp_rator(token, inher_aux)

    
    # inspect constraint"
    def inspect_constraint(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.options != "constraint": raise SyntaxError()

        if False:
            pass
        
        elif token.selection == "AsyncConstraint":
            return self.inspect_constraint_AsyncConstraint(inher_aux)
            

        elif token.selection == "Constraint":
            return self.inspect_constraint_Constraint(inher_aux)
            
        else:
            raise SyntaxError()

    def crawl_constraint(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        return self.inspect_constraint(token, inher_aux)

     
    
    # crawl CompareRight" +
    def crawl_CompareRight(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "CompareRight": raise SyntaxError()

        return self.inspect_CompareRight(token, inher_aux)
    
    # crawl ExceptHandler" +
    def crawl_ExceptHandler(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "ExceptHandler": raise SyntaxError()

        return self.inspect_ExceptHandler(token, inher_aux)
    
    # crawl Param" +
    def crawl_Param(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "Param": raise SyntaxError()

        return self.inspect_Param(token, inher_aux)
    
    # crawl ClassDef" +
    def crawl_ClassDef(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "ClassDef": raise SyntaxError()

        return self.inspect_ClassDef(token, inher_aux)
    
    # crawl ElifBlock" +
    def crawl_ElifBlock(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "ElifBlock": raise SyntaxError()

        return self.inspect_ElifBlock(token, inher_aux)
    
    # crawl ElseBlock" +
    def crawl_ElseBlock(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "ElseBlock": raise SyntaxError()

        return self.inspect_ElseBlock(token, inher_aux)
    
    # crawl FinallyBlock" +
    def crawl_FinallyBlock(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Grammar): raise SyntaxError()
        if token.options != "FinallyBlock": raise SyntaxError()

        return self.inspect_FinallyBlock(token, inher_aux)
     

    
    # inspect: return_annotation <-- SomeReturnAnno"
    def inspect_return_annotation_SomeReturnAnno(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_return_annotation_SomeReturnAnno_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_return_annotation_SomeReturnAnno(inher_aux, content_tree, content_aux)
    
    # inspect: return_annotation <-- NoReturnAnno"
    def inspect_return_annotation_NoReturnAnno(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_return_annotation_NoReturnAnno(inher_aux)
    
    # inspect: except_arg <-- SomeExceptArg"
    def inspect_except_arg_SomeExceptArg(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_except_arg_SomeExceptArg_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_except_arg_SomeExceptArg(inher_aux, content_tree, content_aux)
    
    # inspect: except_arg <-- SomeExceptArgName"
    def inspect_except_arg_SomeExceptArgName(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_except_arg_SomeExceptArgName_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        
        child_inher_aux = self.traverse_except_arg_SomeExceptArgName_name(
            inher_aux,
            content_tree, 
            content_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        

        return self.synthesize_for_except_arg_SomeExceptArgName(inher_aux, content_tree, content_aux, name_tree, name_aux)
    
    # inspect: except_arg <-- NoExceptArg"
    def inspect_except_arg_NoExceptArg(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_except_arg_NoExceptArg(inher_aux)
    
    # inspect: param_annotation <-- SomeParamAnno"
    def inspect_param_annotation_SomeParamAnno(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_param_annotation_SomeParamAnno_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_param_annotation_SomeParamAnno(inher_aux, content_tree, content_aux)
    
    # inspect: param_annotation <-- NoParamAnno"
    def inspect_param_annotation_NoParamAnno(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_param_annotation_NoParamAnno(inher_aux)
    
    # inspect: param_default <-- SomeParamDefault"
    def inspect_param_default_SomeParamDefault(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_param_default_SomeParamDefault_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_param_default_SomeParamDefault(inher_aux, content_tree, content_aux)
    
    # inspect: param_default <-- NoParamDefault"
    def inspect_param_default_NoParamDefault(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_param_default_NoParamDefault(inher_aux)
    
    # inspect: parameters_d <-- ConsKwParam
    def inspect_parameters_d_ConsKwParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, parameters_d)
            tail_aux = children[1].aux
                
            return self.synthesize_for_parameters_d_ConsKwParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_d_ConsKwParam_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_d", "ConsKwParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("parameters_d", "ConsKwParam"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_parameters_d_ConsKwParam_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: parameters_d <-- SingleKwParam
    def inspect_parameters_d_SingleKwParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, Param)
            content_aux = children[0].aux
                
            return self.synthesize_for_parameters_d_SingleKwParam(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_d_SingleKwParam_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_d", "SingleKwParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters_d <-- TransKwParam
    def inspect_parameters_d_TransKwParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, Param)
            tail_aux = children[1].aux
                
            return self.synthesize_for_parameters_d_TransKwParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_d_TransKwParam_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_d", "TransKwParam"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux


            child_inher_aux = self.traverse_parameters_d_TransKwParam_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_d", "TransKwParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters_c <-- SingleTupleBundleParam"
    def inspect_parameters_c_SingleTupleBundleParam(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_c_SingleTupleBundleParam_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_Param(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, Param)
        content_aux = synth.aux
        

        return self.synthesize_for_parameters_c_SingleTupleBundleParam(inher_aux, content_tree, content_aux)
    
    # inspect: parameters_c <-- TransTupleBundleParam"
    def inspect_parameters_c_TransTupleBundleParam(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_c_TransTupleBundleParam_head(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_Param(child_token, child_inher_aux)
        head_tree = synth.tree
        assert isinstance(head_tree, Param)
        head_aux = synth.aux
        
        child_inher_aux = self.traverse_parameters_c_TransTupleBundleParam_tail(
            inher_aux,
            head_tree, 
            head_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters_d(child_token, child_inher_aux)
        tail_tree = synth.tree
        assert isinstance(tail_tree, parameters_d)
        tail_aux = synth.aux
        

        return self.synthesize_for_parameters_c_TransTupleBundleParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
    
    # inspect: parameters_c <-- ParamsD"
    def inspect_parameters_c_ParamsD(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_c_ParamsD_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters_d(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, parameters_d)
        content_aux = synth.aux
        

        return self.synthesize_for_parameters_c_ParamsD(inher_aux, content_tree, content_aux)
    
    # inspect: parameters_c <-- DoubleBundleParam"
    def inspect_parameters_c_DoubleBundleParam(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_c_DoubleBundleParam_tuple_param(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_Param(child_token, child_inher_aux)
        tuple_param_tree = synth.tree
        assert isinstance(tuple_param_tree, Param)
        tuple_param_aux = synth.aux
        
        child_inher_aux = self.traverse_parameters_c_DoubleBundleParam_dict_param(
            inher_aux,
            tuple_param_tree, 
            tuple_param_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_Param(child_token, child_inher_aux)
        dict_param_tree = synth.tree
        assert isinstance(dict_param_tree, Param)
        dict_param_aux = synth.aux
        

        return self.synthesize_for_parameters_c_DoubleBundleParam(inher_aux, tuple_param_tree, tuple_param_aux, dict_param_tree, dict_param_aux)
    
    # inspect: parameters_c <-- DictionaryBundleParam"
    def inspect_parameters_c_DictionaryBundleParam(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_c_DictionaryBundleParam_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_Param(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, Param)
        content_aux = synth.aux
        

        return self.synthesize_for_parameters_c_DictionaryBundleParam(inher_aux, content_tree, content_aux)
    
    # inspect: parameters_b <-- ConsPosKeyParam
    def inspect_parameters_b_ConsPosKeyParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, parameters_b)
            tail_aux = children[1].aux
                
            return self.synthesize_for_parameters_b_ConsPosKeyParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_b_ConsPosKeyParam_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_b", "ConsPosKeyParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("parameters_b", "ConsPosKeyParam"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_parameters_b_ConsPosKeyParam_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: parameters_b <-- SinglePosKeyParam
    def inspect_parameters_b_SinglePosKeyParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, Param)
            content_aux = children[0].aux
                
            return self.synthesize_for_parameters_b_SinglePosKeyParam(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_b_SinglePosKeyParam_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_b", "SinglePosKeyParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters_b <-- ParamsC
    def inspect_parameters_b_ParamsC(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, parameters_c)
            content_aux = children[0].aux
                
            return self.synthesize_for_parameters_b_ParamsC(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_b_ParamsC_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_parameters_c(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_b", "ParamsC"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters_a <-- ConsPosParam
    def inspect_parameters_a_ConsPosParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, parameters_a)
            tail_aux = children[1].aux
                
            return self.synthesize_for_parameters_a_ConsPosParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_a_ConsPosParam_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_a", "ConsPosParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("parameters_a", "ConsPosParam"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_parameters_a_ConsPosParam_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: parameters_a <-- SinglePosParam
    def inspect_parameters_a_SinglePosParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, Param)
            content_aux = children[0].aux
                
            return self.synthesize_for_parameters_a_SinglePosParam(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_a_SinglePosParam_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_a", "SinglePosParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters_a <-- TransPosParam
    def inspect_parameters_a_TransPosParam(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, parameters_b)
            tail_aux = children[1].aux
                
            return self.synthesize_for_parameters_a_TransPosParam(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_parameters_a_TransPosParam_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_Param(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_a", "TransPosParam"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            head_tree = children[0].tree
            assert isinstance(head_tree, Param)
            head_aux = children[0].aux


            child_inher_aux = self.traverse_parameters_a_TransPosParam_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_parameters_b(child_token, child_inher_aux)

            stack.append((make_Grammar("parameters_a", "TransPosParam"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: parameters <-- ParamsA"
    def inspect_parameters_ParamsA(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_ParamsA_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters_a(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, parameters_a)
        content_aux = synth.aux
        

        return self.synthesize_for_parameters_ParamsA(inher_aux, content_tree, content_aux)
    
    # inspect: parameters <-- ParamsB"
    def inspect_parameters_ParamsB(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_parameters_ParamsB_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters_b(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, parameters_b)
        content_aux = synth.aux
        

        return self.synthesize_for_parameters_ParamsB(inher_aux, content_tree, content_aux)
    
    # inspect: parameters <-- NoParam"
    def inspect_parameters_NoParam(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_parameters_NoParam(inher_aux)
    
    # inspect: keyword <-- NamedKeyword"
    def inspect_keyword_NamedKeyword(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_keyword_NamedKeyword_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        
        child_inher_aux = self.traverse_keyword_NamedKeyword_content(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_keyword_NamedKeyword(inher_aux, name_tree, name_aux, content_tree, content_aux)
    
    # inspect: keyword <-- SplatKeyword"
    def inspect_keyword_SplatKeyword(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_keyword_SplatKeyword_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_keyword_SplatKeyword(inher_aux, content_tree, content_aux)
    
    # inspect: import_name <-- ImportNameAlias"
    def inspect_import_name_ImportNameAlias(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_import_name_ImportNameAlias_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        
        child_inher_aux = self.traverse_import_name_ImportNameAlias_alias(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        alias_tree = synth.tree
        assert isinstance(alias_tree, str)
        alias_aux = synth.aux
        

        return self.synthesize_for_import_name_ImportNameAlias(inher_aux, name_tree, name_aux, alias_tree, alias_aux)
    
    # inspect: import_name <-- ImportNameOnly"
    def inspect_import_name_ImportNameOnly(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_import_name_ImportNameOnly_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        

        return self.synthesize_for_import_name_ImportNameOnly(inher_aux, name_tree, name_aux)
    
    # inspect: with_item <-- WithItemAlias"
    def inspect_with_item_WithItemAlias(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_with_item_WithItemAlias_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        
        child_inher_aux = self.traverse_with_item_WithItemAlias_alias(
            inher_aux,
            content_tree, 
            content_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        alias_tree = synth.tree
        assert isinstance(alias_tree, expr)
        alias_aux = synth.aux
        

        return self.synthesize_for_with_item_WithItemAlias(inher_aux, content_tree, content_aux, alias_tree, alias_aux)
    
    # inspect: with_item <-- WithItemOnly"
    def inspect_with_item_WithItemOnly(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_with_item_WithItemOnly_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_with_item_WithItemOnly(inher_aux, content_tree, content_aux)
    
    # inspect: bases <-- SomeBases"
    def inspect_bases_SomeBases(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_bases_SomeBases_bases(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_bases_a(child_token, child_inher_aux)
        bases_tree = synth.tree
        assert isinstance(bases_tree, bases_a)
        bases_aux = synth.aux
        

        return self.synthesize_for_bases_SomeBases(inher_aux, bases_tree, bases_aux)
    
    # inspect: bases <-- NoBases"
    def inspect_bases_NoBases(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bases_NoBases(inher_aux)
    
    # inspect: bases_a <-- ConsBase
    def inspect_bases_a_ConsBase(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, bases_a)
            tail_aux = children[1].aux
                
            return self.synthesize_for_bases_a_ConsBase(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_bases_a_ConsBase_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("bases_a", "ConsBase"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("bases_a", "ConsBase"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_bases_a_ConsBase_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: bases_a <-- SingleBase
    def inspect_bases_a_SingleBase(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_bases_a_SingleBase(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_bases_a_SingleBase_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("bases_a", "SingleBase"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: bases_a <-- KeywordBases
    def inspect_bases_a_KeywordBases(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            kws_tree = children[0].tree
            assert isinstance(kws_tree, keywords)
            kws_aux = children[0].aux
                
            return self.synthesize_for_bases_a_KeywordBases(inher_aux, kws_tree, kws_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_bases_a_KeywordBases_kws(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_keywords(child_token, child_inher_aux)

            stack.append((make_Grammar("bases_a", "KeywordBases"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: keywords <-- ConsKeyword
    def inspect_keywords_ConsKeyword(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 4

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            head_tree = children[1].tree
            assert isinstance(head_tree, keyword)
            head_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            tail_tree = children[3].tree
            assert isinstance(tail_tree, keywords)
            tail_aux = children[3].aux
                
            return self.synthesize_for_keywords_ConsKeyword(inher_aux, pre_comment_tree, pre_comment_aux, head_tree, head_aux, post_comment_tree, post_comment_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_keywords_ConsKeyword_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "ConsKeyword"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_keywords_ConsKeyword_head(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_keyword(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "ConsKeyword"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, keyword)
            head_aux = children[1].aux


            child_inher_aux = self.traverse_keywords_ConsKeyword_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "ConsKeyword"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 3 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("keywords", "ConsKeyword"), inher_aux, children))

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, keyword)
            head_aux = children[1].aux
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux

            # add on child node 
            child_inher_aux = self.traverse_keywords_ConsKeyword_tail(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux,
                post_comment_tree, 
                post_comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: keywords <-- SingleKeyword
    def inspect_keywords_SingleKeyword(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, keyword)
            content_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            return self.synthesize_for_keywords_SingleKeyword(inher_aux, pre_comment_tree, pre_comment_aux, content_tree, content_aux, post_comment_tree, post_comment_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_keywords_SingleKeyword_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "SingleKeyword"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_keywords_SingleKeyword_content(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_keyword(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "SingleKeyword"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            content_tree = children[1].tree
            assert isinstance(content_tree, keyword)
            content_aux = children[1].aux


            child_inher_aux = self.traverse_keywords_SingleKeyword_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("keywords", "SingleKeyword"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: comparisons <-- ConsCompareRight
    def inspect_comparisons_ConsCompareRight(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, CompareRight)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, comparisons)
            tail_aux = children[1].aux
                
            return self.synthesize_for_comparisons_ConsCompareRight(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comparisons_ConsCompareRight_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_CompareRight(child_token, child_inher_aux)

            stack.append((make_Grammar("comparisons", "ConsCompareRight"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("comparisons", "ConsCompareRight"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, CompareRight)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_comparisons_ConsCompareRight_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: comparisons <-- SingleCompareRight
    def inspect_comparisons_SingleCompareRight(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, CompareRight)
            content_aux = children[0].aux
                
            return self.synthesize_for_comparisons_SingleCompareRight(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comparisons_SingleCompareRight_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_CompareRight(child_token, child_inher_aux)

            stack.append((make_Grammar("comparisons", "SingleCompareRight"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: option_expr <-- SomeExpr"
    def inspect_option_expr_SomeExpr(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_option_expr_SomeExpr_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_option_expr_SomeExpr(inher_aux, content_tree, content_aux)
    
    # inspect: option_expr <-- NoExpr"
    def inspect_option_expr_NoExpr(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_option_expr_NoExpr(inher_aux)
    
    # inspect: comma_exprs <-- ConsExpr
    def inspect_comma_exprs_ConsExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 4

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            tail_tree = children[3].tree
            assert isinstance(tail_tree, comma_exprs)
            tail_aux = children[3].aux
                
            return self.synthesize_for_comma_exprs_ConsExpr(inher_aux, pre_comment_tree, pre_comment_aux, head_tree, head_aux, post_comment_tree, post_comment_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comma_exprs_ConsExpr_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "ConsExpr"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_comma_exprs_ConsExpr_head(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "ConsExpr"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux


            child_inher_aux = self.traverse_comma_exprs_ConsExpr_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "ConsExpr"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 3 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("comma_exprs", "ConsExpr"), inher_aux, children))

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux

            # add on child node 
            child_inher_aux = self.traverse_comma_exprs_ConsExpr_tail(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux,
                post_comment_tree, 
                post_comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: comma_exprs <-- SingleExpr
    def inspect_comma_exprs_SingleExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            return self.synthesize_for_comma_exprs_SingleExpr(inher_aux, pre_comment_tree, pre_comment_aux, content_tree, content_aux, post_comment_tree, post_comment_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comma_exprs_SingleExpr_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "SingleExpr"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_comma_exprs_SingleExpr_content(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "SingleExpr"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux


            child_inher_aux = self.traverse_comma_exprs_SingleExpr_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("comma_exprs", "SingleExpr"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: target_exprs <-- ConsTargetExpr
    def inspect_target_exprs_ConsTargetExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, target_exprs)
            tail_aux = children[1].aux
                
            return self.synthesize_for_target_exprs_ConsTargetExpr(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_target_exprs_ConsTargetExpr_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("target_exprs", "ConsTargetExpr"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("target_exprs", "ConsTargetExpr"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_target_exprs_ConsTargetExpr_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: target_exprs <-- SingleTargetExpr
    def inspect_target_exprs_SingleTargetExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_target_exprs_SingleTargetExpr(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_target_exprs_SingleTargetExpr_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("target_exprs", "SingleTargetExpr"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: decorator <-- ExprDec"
    def inspect_decorator_ExprDec(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_decorator_ExprDec_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_decorator_ExprDec(inher_aux, content_tree, content_aux)
    
    # inspect: decorator <-- CmntDec"
    def inspect_decorator_CmntDec(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_decorator_CmntDec_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, str)
        content_aux = synth.aux
        

        return self.synthesize_for_decorator_CmntDec(inher_aux, content_tree, content_aux)
    
    # inspect: decorators <-- ConsDec
    def inspect_decorators_ConsDec(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, decorator)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, decorators)
            tail_aux = children[1].aux
                
            return self.synthesize_for_decorators_ConsDec(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_decorators_ConsDec_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_decorator(child_token, child_inher_aux)

            stack.append((make_Grammar("decorators", "ConsDec"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("decorators", "ConsDec"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, decorator)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_decorators_ConsDec_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: decorators <-- NoDec
    def inspect_decorators_NoDec(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_decorators_NoDec(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: constraint_filters <-- ConsFilter
    def inspect_constraint_filters_ConsFilter(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, constraint_filters)
            tail_aux = children[1].aux
                
            return self.synthesize_for_constraint_filters_ConsFilter(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_constraint_filters_ConsFilter_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("constraint_filters", "ConsFilter"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("constraint_filters", "ConsFilter"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, expr)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_constraint_filters_ConsFilter_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: constraint_filters <-- SingleFilter
    def inspect_constraint_filters_SingleFilter(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_constraint_filters_SingleFilter(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_constraint_filters_SingleFilter_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("constraint_filters", "SingleFilter"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: constraint_filters <-- NoFilter
    def inspect_constraint_filters_NoFilter(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_constraint_filters_NoFilter(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: sequence_string <-- ConsStr
    def inspect_sequence_string_ConsStr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, str)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, sequence_string)
            tail_aux = children[1].aux
                
            return self.synthesize_for_sequence_string_ConsStr(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_string_ConsStr_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_string", "ConsStr"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("sequence_string", "ConsStr"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, str)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_sequence_string_ConsStr_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: sequence_string <-- SingleStr
    def inspect_sequence_string_SingleStr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, str)
            content_aux = children[0].aux
                
            return self.synthesize_for_sequence_string_SingleStr(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_string_SingleStr_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_string", "SingleStr"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: arguments <-- ConsArg
    def inspect_arguments_ConsArg(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 4

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            tail_tree = children[3].tree
            assert isinstance(tail_tree, arguments)
            tail_aux = children[3].aux
                
            return self.synthesize_for_arguments_ConsArg(inher_aux, pre_comment_tree, pre_comment_aux, head_tree, head_aux, post_comment_tree, post_comment_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_arguments_ConsArg_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "ConsArg"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_arguments_ConsArg_head(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "ConsArg"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux


            child_inher_aux = self.traverse_arguments_ConsArg_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "ConsArg"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 3 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("arguments", "ConsArg"), inher_aux, children))

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            head_tree = children[1].tree
            assert isinstance(head_tree, expr)
            head_aux = children[1].aux
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux

            # add on child node 
            child_inher_aux = self.traverse_arguments_ConsArg_tail(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                head_tree, 
                head_aux,
                post_comment_tree, 
                post_comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: arguments <-- SingleArg
    def inspect_arguments_SingleArg(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            return self.synthesize_for_arguments_SingleArg(inher_aux, pre_comment_tree, pre_comment_aux, content_tree, content_aux, post_comment_tree, post_comment_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_arguments_SingleArg_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "SingleArg"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux


            child_inher_aux = self.traverse_arguments_SingleArg_content(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "SingleArg"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux


            child_inher_aux = self.traverse_arguments_SingleArg_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "SingleArg"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: arguments <-- KeywordsArg
    def inspect_arguments_KeywordsArg(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            kws_tree = children[0].tree
            assert isinstance(kws_tree, keywords)
            kws_aux = children[0].aux
                
            return self.synthesize_for_arguments_KeywordsArg(inher_aux, kws_tree, kws_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_arguments_KeywordsArg_kws(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_keywords(child_token, child_inher_aux)

            stack.append((make_Grammar("arguments", "KeywordsArg"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: dictionary_item <-- Field"
    def inspect_dictionary_item_Field(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_dictionary_item_Field_key(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        key_tree = synth.tree
        assert isinstance(key_tree, expr)
        key_aux = synth.aux
        
        child_inher_aux = self.traverse_dictionary_item_Field_content(
            inher_aux,
            key_tree, 
            key_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_dictionary_item_Field(inher_aux, key_tree, key_aux, content_tree, content_aux)
    
    # inspect: dictionary_item <-- DictionarySplatFields"
    def inspect_dictionary_item_DictionarySplatFields(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_dictionary_item_DictionarySplatFields_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_dictionary_item_DictionarySplatFields(inher_aux, content_tree, content_aux)
    
    # inspect: dictionary_content <-- ConsDictionaryItem
    def inspect_dictionary_content_ConsDictionaryItem(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, dictionary_item)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, dictionary_content)
            tail_aux = children[1].aux
                
            return self.synthesize_for_dictionary_content_ConsDictionaryItem(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_dictionary_content_ConsDictionaryItem_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_dictionary_item(child_token, child_inher_aux)

            stack.append((make_Grammar("dictionary_content", "ConsDictionaryItem"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("dictionary_content", "ConsDictionaryItem"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, dictionary_item)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_dictionary_content_ConsDictionaryItem_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: dictionary_content <-- SingleDictionaryItem
    def inspect_dictionary_content_SingleDictionaryItem(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, dictionary_item)
            content_aux = children[0].aux
                
            return self.synthesize_for_dictionary_content_SingleDictionaryItem(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_dictionary_content_SingleDictionaryItem_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_dictionary_item(child_token, child_inher_aux)

            stack.append((make_Grammar("dictionary_content", "SingleDictionaryItem"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: sequence_name <-- ConsId
    def inspect_sequence_name_ConsId(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, str)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, sequence_name)
            tail_aux = children[1].aux
                
            return self.synthesize_for_sequence_name_ConsId(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_name_ConsId_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_name", "ConsId"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("sequence_name", "ConsId"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, str)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_sequence_name_ConsId_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: sequence_name <-- SingleId
    def inspect_sequence_name_SingleId(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, str)
            content_aux = children[0].aux
                
            return self.synthesize_for_sequence_name_SingleId(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_name_SingleId_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_name", "SingleId"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: sequence_import_name <-- ConsImportName
    def inspect_sequence_import_name_ConsImportName(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, import_name)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, sequence_import_name)
            tail_aux = children[1].aux
                
            return self.synthesize_for_sequence_import_name_ConsImportName(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_import_name_ConsImportName_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_import_name(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_import_name", "ConsImportName"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("sequence_import_name", "ConsImportName"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, import_name)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_sequence_import_name_ConsImportName_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: sequence_import_name <-- SingleImportName
    def inspect_sequence_import_name_SingleImportName(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, import_name)
            content_aux = children[0].aux
                
            return self.synthesize_for_sequence_import_name_SingleImportName(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_import_name_SingleImportName_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_import_name(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_import_name", "SingleImportName"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: sequence_with_item <-- ConsWithItem
    def inspect_sequence_with_item_ConsWithItem(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, with_item)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, sequence_with_item)
            tail_aux = children[1].aux
                
            return self.synthesize_for_sequence_with_item_ConsWithItem(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_with_item_ConsWithItem_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_with_item(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_with_item", "ConsWithItem"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("sequence_with_item", "ConsWithItem"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, with_item)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_sequence_with_item_ConsWithItem_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: sequence_with_item <-- SingleWithItem
    def inspect_sequence_with_item_SingleWithItem(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, with_item)
            content_aux = children[0].aux
                
            return self.synthesize_for_sequence_with_item_SingleWithItem(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_with_item_SingleWithItem_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_with_item(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_with_item", "SingleWithItem"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: module <-- FutureMod"
    def inspect_module_FutureMod(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_module_FutureMod_names(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_import_name(child_token, child_inher_aux)
        names_tree = synth.tree
        assert isinstance(names_tree, sequence_import_name)
        names_aux = synth.aux
        
        child_inher_aux = self.traverse_module_FutureMod_body(
            inher_aux,
            names_tree, 
            names_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_module_FutureMod(inher_aux, names_tree, names_aux, body_tree, body_aux)
    
    # inspect: module <-- SimpleMod"
    def inspect_module_SimpleMod(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_module_SimpleMod_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_module_SimpleMod(inher_aux, body_tree, body_aux)
    
    # inspect: statements <-- ConsStmt
    def inspect_statements_ConsStmt(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, stmt)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, statements)
            tail_aux = children[1].aux
                
            return self.synthesize_for_statements_ConsStmt(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_statements_ConsStmt_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_stmt(child_token, child_inher_aux)

            stack.append((make_Grammar("statements", "ConsStmt"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("statements", "ConsStmt"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, stmt)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_statements_ConsStmt_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: statements <-- SingleStmt
    def inspect_statements_SingleStmt(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, stmt)
            content_aux = children[0].aux
                
            return self.synthesize_for_statements_SingleStmt(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_statements_SingleStmt_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_stmt(child_token, child_inher_aux)

            stack.append((make_Grammar("statements", "SingleStmt"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: comprehension_constraints <-- ConsConstraint
    def inspect_comprehension_constraints_ConsConstraint(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, constraint)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, comprehension_constraints)
            tail_aux = children[1].aux
                
            return self.synthesize_for_comprehension_constraints_ConsConstraint(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comprehension_constraints_ConsConstraint_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_constraint(child_token, child_inher_aux)

            stack.append((make_Grammar("comprehension_constraints", "ConsConstraint"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("comprehension_constraints", "ConsConstraint"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, constraint)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_comprehension_constraints_ConsConstraint_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: comprehension_constraints <-- SingleConstraint
    def inspect_comprehension_constraints_SingleConstraint(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, constraint)
            content_aux = children[0].aux
                
            return self.synthesize_for_comprehension_constraints_SingleConstraint(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_comprehension_constraints_SingleConstraint_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_constraint(child_token, child_inher_aux)

            stack.append((make_Grammar("comprehension_constraints", "SingleConstraint"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: sequence_ExceptHandler <-- ConsExceptHandler
    def inspect_sequence_ExceptHandler_ConsExceptHandler(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            head_tree = children[0].tree
            assert isinstance(head_tree, ExceptHandler)
            head_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, sequence_ExceptHandler)
            tail_aux = children[1].aux
                
            return self.synthesize_for_sequence_ExceptHandler_ConsExceptHandler(inher_aux, head_tree, head_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_ExceptHandler_ConsExceptHandler_head(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_ExceptHandler(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_ExceptHandler", "ConsExceptHandler"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("sequence_ExceptHandler", "ConsExceptHandler"), inher_aux, children))

            
            head_tree = children[0].tree
            assert isinstance(head_tree, ExceptHandler)
            head_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_sequence_ExceptHandler_ConsExceptHandler_tail(
                inher_aux,
                head_tree, 
                head_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: sequence_ExceptHandler <-- SingleExceptHandler
    def inspect_sequence_ExceptHandler_SingleExceptHandler(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, ExceptHandler)
            content_aux = children[0].aux
                
            return self.synthesize_for_sequence_ExceptHandler_SingleExceptHandler(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_sequence_ExceptHandler_SingleExceptHandler_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_ExceptHandler(child_token, child_inher_aux)

            stack.append((make_Grammar("sequence_ExceptHandler", "SingleExceptHandler"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: conditions <-- ElifCond
    def inspect_conditions_ElifCond(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, ElifBlock)
            content_aux = children[0].aux
                
            tail_tree = children[1].tree
            assert isinstance(tail_tree, conditions)
            tail_aux = children[1].aux
                
            return self.synthesize_for_conditions_ElifCond(inher_aux, content_tree, content_aux, tail_tree, tail_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_conditions_ElifCond_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_ElifBlock(child_token, child_inher_aux)

            stack.append((make_Grammar("conditions", "ElifCond"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("conditions", "ElifCond"), inher_aux, children))

            
            content_tree = children[0].tree
            assert isinstance(content_tree, ElifBlock)
            content_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_conditions_ElifCond_tail(
                inher_aux,
                content_tree, 
                content_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: conditions <-- ElseCond
    def inspect_conditions_ElseCond(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, ElseBlock)
            content_aux = children[0].aux
                
            return self.synthesize_for_conditions_ElseCond(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_conditions_ElseCond_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_ElseBlock(child_token, child_inher_aux)

            stack.append((make_Grammar("conditions", "ElseCond"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: conditions <-- NoCond
    def inspect_conditions_NoCond(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_conditions_NoCond(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: function_def <-- FunctionDef"
    def inspect_function_def_FunctionDef(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_function_def_FunctionDef_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_FunctionDef_params(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters(child_token, child_inher_aux)
        params_tree = synth.tree
        assert isinstance(params_tree, parameters)
        params_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_FunctionDef_ret_anno(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_return_annotation(child_token, child_inher_aux)
        ret_anno_tree = synth.tree
        assert isinstance(ret_anno_tree, return_annotation)
        ret_anno_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_FunctionDef_comment(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux,
            ret_anno_tree, 
            ret_anno_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_FunctionDef_body(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux,
            ret_anno_tree, 
            ret_anno_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_function_def_FunctionDef(inher_aux, name_tree, name_aux, params_tree, params_aux, ret_anno_tree, ret_anno_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: function_def <-- AsyncFunctionDef"
    def inspect_function_def_AsyncFunctionDef(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_function_def_AsyncFunctionDef_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_AsyncFunctionDef_params(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_parameters(child_token, child_inher_aux)
        params_tree = synth.tree
        assert isinstance(params_tree, parameters)
        params_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_AsyncFunctionDef_ret_anno(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_return_annotation(child_token, child_inher_aux)
        ret_anno_tree = synth.tree
        assert isinstance(ret_anno_tree, return_annotation)
        ret_anno_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_AsyncFunctionDef_comment(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux,
            ret_anno_tree, 
            ret_anno_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_function_def_AsyncFunctionDef_body(
            inher_aux,
            name_tree, 
            name_aux,
            params_tree, 
            params_aux,
            ret_anno_tree, 
            ret_anno_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_function_def_AsyncFunctionDef(inher_aux, name_tree, name_aux, params_tree, params_aux, ret_anno_tree, ret_anno_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- Comment"
    def inspect_stmt_Comment(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Comment_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, str)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_Comment(inher_aux, content_tree, content_aux)
    
    # inspect: stmt <-- DecFunctionDef"
    def inspect_stmt_DecFunctionDef(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_DecFunctionDef_decs(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_decorators(child_token, child_inher_aux)
        decs_tree = synth.tree
        assert isinstance(decs_tree, decorators)
        decs_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_DecFunctionDef_fun_def(
            inher_aux,
            decs_tree, 
            decs_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_function_def(child_token, child_inher_aux)
        fun_def_tree = synth.tree
        assert isinstance(fun_def_tree, function_def)
        fun_def_aux = synth.aux
        

        return self.synthesize_for_stmt_DecFunctionDef(inher_aux, decs_tree, decs_aux, fun_def_tree, fun_def_aux)
    
    # inspect: stmt <-- DecClassDef"
    def inspect_stmt_DecClassDef(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_DecClassDef_decs(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_decorators(child_token, child_inher_aux)
        decs_tree = synth.tree
        assert isinstance(decs_tree, decorators)
        decs_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_DecClassDef_class_def(
            inher_aux,
            decs_tree, 
            decs_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ClassDef(child_token, child_inher_aux)
        class_def_tree = synth.tree
        assert isinstance(class_def_tree, ClassDef)
        class_def_aux = synth.aux
        

        return self.synthesize_for_stmt_DecClassDef(inher_aux, decs_tree, decs_aux, class_def_tree, class_def_aux)
    
    # inspect: stmt <-- ReturnSomething"
    def inspect_stmt_ReturnSomething(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_ReturnSomething_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_ReturnSomething(inher_aux, content_tree, content_aux)
    
    # inspect: stmt <-- Return"
    def inspect_stmt_Return(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_stmt_Return(inher_aux)
    
    # inspect: stmt <-- Delete"
    def inspect_stmt_Delete(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Delete_targets(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_comma_exprs(child_token, child_inher_aux)
        targets_tree = synth.tree
        assert isinstance(targets_tree, comma_exprs)
        targets_aux = synth.aux
        

        return self.synthesize_for_stmt_Delete(inher_aux, targets_tree, targets_aux)
    
    # inspect: stmt <-- Assign"
    def inspect_stmt_Assign(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Assign_targets(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_target_exprs(child_token, child_inher_aux)
        targets_tree = synth.tree
        assert isinstance(targets_tree, target_exprs)
        targets_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_Assign_content(
            inher_aux,
            targets_tree, 
            targets_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_Assign(inher_aux, targets_tree, targets_aux, content_tree, content_aux)
    
    # inspect: stmt <-- AugAssign"
    def inspect_stmt_AugAssign(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AugAssign_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AugAssign_op(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_bin_rator(child_token, child_inher_aux)
        op_tree = synth.tree
        assert isinstance(op_tree, bin_rator)
        op_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AugAssign_content(
            inher_aux,
            target_tree, 
            target_aux,
            op_tree, 
            op_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_AugAssign(inher_aux, target_tree, target_aux, op_tree, op_aux, content_tree, content_aux)
    
    # inspect: stmt <-- AnnoAssign"
    def inspect_stmt_AnnoAssign(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AnnoAssign_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AnnoAssign_anno(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        anno_tree = synth.tree
        assert isinstance(anno_tree, expr)
        anno_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AnnoAssign_content(
            inher_aux,
            target_tree, 
            target_aux,
            anno_tree, 
            anno_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_AnnoAssign(inher_aux, target_tree, target_aux, anno_tree, anno_aux, content_tree, content_aux)
    
    # inspect: stmt <-- AnnoDeclar"
    def inspect_stmt_AnnoDeclar(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AnnoDeclar_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AnnoDeclar_anno(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        anno_tree = synth.tree
        assert isinstance(anno_tree, expr)
        anno_aux = synth.aux
        

        return self.synthesize_for_stmt_AnnoDeclar(inher_aux, target_tree, target_aux, anno_tree, anno_aux)
    
    # inspect: stmt <-- For"
    def inspect_stmt_For(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_For_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_For_iter(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        iter_tree = synth.tree
        assert isinstance(iter_tree, expr)
        iter_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_For_comment(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_For_body(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_stmt_For(inher_aux, target_tree, target_aux, iter_tree, iter_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- ForElse"
    def inspect_stmt_ForElse(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_ForElse_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_ForElse_iter(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        iter_tree = synth.tree
        assert isinstance(iter_tree, expr)
        iter_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_ForElse_comment(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_ForElse_body(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_ForElse_orelse(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ElseBlock(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, ElseBlock)
        orelse_aux = synth.aux
        

        return self.synthesize_for_stmt_ForElse(inher_aux, target_tree, target_aux, iter_tree, iter_aux, comment_tree, comment_aux, body_tree, body_aux, orelse_tree, orelse_aux)
    
    # inspect: stmt <-- AsyncFor"
    def inspect_stmt_AsyncFor(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AsyncFor_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncFor_iter(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        iter_tree = synth.tree
        assert isinstance(iter_tree, expr)
        iter_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncFor_comment(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncFor_body(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_stmt_AsyncFor(inher_aux, target_tree, target_aux, iter_tree, iter_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- AsyncForElse"
    def inspect_stmt_AsyncForElse(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AsyncForElse_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncForElse_iter(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        iter_tree = synth.tree
        assert isinstance(iter_tree, expr)
        iter_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncForElse_comment(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncForElse_body(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncForElse_orelse(
            inher_aux,
            target_tree, 
            target_aux,
            iter_tree, 
            iter_aux,
            comment_tree, 
            comment_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ElseBlock(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, ElseBlock)
        orelse_aux = synth.aux
        

        return self.synthesize_for_stmt_AsyncForElse(inher_aux, target_tree, target_aux, iter_tree, iter_aux, comment_tree, comment_aux, body_tree, body_aux, orelse_tree, orelse_aux)
    
    # inspect: stmt <-- While"
    def inspect_stmt_While(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_While_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_While_comment(
            inher_aux,
            test_tree, 
            test_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_While_body(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_stmt_While(inher_aux, test_tree, test_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- WhileElse"
    def inspect_stmt_WhileElse(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_WhileElse_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_WhileElse_comment(
            inher_aux,
            test_tree, 
            test_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_WhileElse_body(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_WhileElse_orelse(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ElseBlock(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, ElseBlock)
        orelse_aux = synth.aux
        

        return self.synthesize_for_stmt_WhileElse(inher_aux, test_tree, test_aux, comment_tree, comment_aux, body_tree, body_aux, orelse_tree, orelse_aux)
    
    # inspect: stmt <-- If"
    def inspect_stmt_If(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_If_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_If_comment(
            inher_aux,
            test_tree, 
            test_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_If_body(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_If_orelse(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_conditions(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, conditions)
        orelse_aux = synth.aux
        

        return self.synthesize_for_stmt_If(inher_aux, test_tree, test_aux, comment_tree, comment_aux, body_tree, body_aux, orelse_tree, orelse_aux)
    
    # inspect: stmt <-- With"
    def inspect_stmt_With(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_With_items(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_with_item(child_token, child_inher_aux)
        items_tree = synth.tree
        assert isinstance(items_tree, sequence_with_item)
        items_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_With_comment(
            inher_aux,
            items_tree, 
            items_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_With_body(
            inher_aux,
            items_tree, 
            items_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_stmt_With(inher_aux, items_tree, items_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- AsyncWith"
    def inspect_stmt_AsyncWith(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AsyncWith_items(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_with_item(child_token, child_inher_aux)
        items_tree = synth.tree
        assert isinstance(items_tree, sequence_with_item)
        items_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncWith_comment(
            inher_aux,
            items_tree, 
            items_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AsyncWith_body(
            inher_aux,
            items_tree, 
            items_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        

        return self.synthesize_for_stmt_AsyncWith(inher_aux, items_tree, items_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: stmt <-- Raise"
    def inspect_stmt_Raise(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_stmt_Raise(inher_aux)
    
    # inspect: stmt <-- RaiseExc"
    def inspect_stmt_RaiseExc(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_RaiseExc_exc(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        exc_tree = synth.tree
        assert isinstance(exc_tree, expr)
        exc_aux = synth.aux
        

        return self.synthesize_for_stmt_RaiseExc(inher_aux, exc_tree, exc_aux)
    
    # inspect: stmt <-- RaiseFrom"
    def inspect_stmt_RaiseFrom(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_RaiseFrom_exc(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        exc_tree = synth.tree
        assert isinstance(exc_tree, expr)
        exc_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_RaiseFrom_caus(
            inher_aux,
            exc_tree, 
            exc_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        caus_tree = synth.tree
        assert isinstance(caus_tree, expr)
        caus_aux = synth.aux
        

        return self.synthesize_for_stmt_RaiseFrom(inher_aux, exc_tree, exc_aux, caus_tree, caus_aux)
    
    # inspect: stmt <-- Try"
    def inspect_stmt_Try(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Try_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_Try_handlers(
            inher_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_ExceptHandler(child_token, child_inher_aux)
        handlers_tree = synth.tree
        assert isinstance(handlers_tree, sequence_ExceptHandler)
        handlers_aux = synth.aux
        

        return self.synthesize_for_stmt_Try(inher_aux, body_tree, body_aux, handlers_tree, handlers_aux)
    
    # inspect: stmt <-- TryElse"
    def inspect_stmt_TryElse(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_TryElse_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryElse_handlers(
            inher_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_ExceptHandler(child_token, child_inher_aux)
        handlers_tree = synth.tree
        assert isinstance(handlers_tree, sequence_ExceptHandler)
        handlers_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryElse_orelse(
            inher_aux,
            body_tree, 
            body_aux,
            handlers_tree, 
            handlers_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ElseBlock(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, ElseBlock)
        orelse_aux = synth.aux
        

        return self.synthesize_for_stmt_TryElse(inher_aux, body_tree, body_aux, handlers_tree, handlers_aux, orelse_tree, orelse_aux)
    
    # inspect: stmt <-- TryExceptFin"
    def inspect_stmt_TryExceptFin(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_TryExceptFin_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryExceptFin_handlers(
            inher_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_ExceptHandler(child_token, child_inher_aux)
        handlers_tree = synth.tree
        assert isinstance(handlers_tree, sequence_ExceptHandler)
        handlers_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryExceptFin_fin(
            inher_aux,
            body_tree, 
            body_aux,
            handlers_tree, 
            handlers_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_FinallyBlock(child_token, child_inher_aux)
        fin_tree = synth.tree
        assert isinstance(fin_tree, FinallyBlock)
        fin_aux = synth.aux
        

        return self.synthesize_for_stmt_TryExceptFin(inher_aux, body_tree, body_aux, handlers_tree, handlers_aux, fin_tree, fin_aux)
    
    # inspect: stmt <-- TryFin"
    def inspect_stmt_TryFin(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_TryFin_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryFin_fin(
            inher_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_FinallyBlock(child_token, child_inher_aux)
        fin_tree = synth.tree
        assert isinstance(fin_tree, FinallyBlock)
        fin_aux = synth.aux
        

        return self.synthesize_for_stmt_TryFin(inher_aux, body_tree, body_aux, fin_tree, fin_aux)
    
    # inspect: stmt <-- TryElseFin"
    def inspect_stmt_TryElseFin(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_TryElseFin_body(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryElseFin_handlers(
            inher_aux,
            body_tree, 
            body_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_ExceptHandler(child_token, child_inher_aux)
        handlers_tree = synth.tree
        assert isinstance(handlers_tree, sequence_ExceptHandler)
        handlers_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryElseFin_orelse(
            inher_aux,
            body_tree, 
            body_aux,
            handlers_tree, 
            handlers_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_ElseBlock(child_token, child_inher_aux)
        orelse_tree = synth.tree
        assert isinstance(orelse_tree, ElseBlock)
        orelse_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_TryElseFin_fin(
            inher_aux,
            body_tree, 
            body_aux,
            handlers_tree, 
            handlers_aux,
            orelse_tree, 
            orelse_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_FinallyBlock(child_token, child_inher_aux)
        fin_tree = synth.tree
        assert isinstance(fin_tree, FinallyBlock)
        fin_aux = synth.aux
        

        return self.synthesize_for_stmt_TryElseFin(inher_aux, body_tree, body_aux, handlers_tree, handlers_aux, orelse_tree, orelse_aux, fin_tree, fin_aux)
    
    # inspect: stmt <-- Assert"
    def inspect_stmt_Assert(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Assert_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
        

        return self.synthesize_for_stmt_Assert(inher_aux, test_tree, test_aux)
    
    # inspect: stmt <-- AssertMsg"
    def inspect_stmt_AssertMsg(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_AssertMsg_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_AssertMsg_msg(
            inher_aux,
            test_tree, 
            test_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        msg_tree = synth.tree
        assert isinstance(msg_tree, expr)
        msg_aux = synth.aux
        

        return self.synthesize_for_stmt_AssertMsg(inher_aux, test_tree, test_aux, msg_tree, msg_aux)
    
    # inspect: stmt <-- Import"
    def inspect_stmt_Import(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Import_names(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_import_name(child_token, child_inher_aux)
        names_tree = synth.tree
        assert isinstance(names_tree, sequence_import_name)
        names_aux = synth.aux
        

        return self.synthesize_for_stmt_Import(inher_aux, names_tree, names_aux)
    
    # inspect: stmt <-- ImportFrom"
    def inspect_stmt_ImportFrom(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_ImportFrom_module(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        module_tree = synth.tree
        assert isinstance(module_tree, str)
        module_aux = synth.aux
        
        child_inher_aux = self.traverse_stmt_ImportFrom_names(
            inher_aux,
            module_tree, 
            module_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_import_name(child_token, child_inher_aux)
        names_tree = synth.tree
        assert isinstance(names_tree, sequence_import_name)
        names_aux = synth.aux
        

        return self.synthesize_for_stmt_ImportFrom(inher_aux, module_tree, module_aux, names_tree, names_aux)
    
    # inspect: stmt <-- ImportWildCard"
    def inspect_stmt_ImportWildCard(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_ImportWildCard_module(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        module_tree = synth.tree
        assert isinstance(module_tree, str)
        module_aux = synth.aux
        

        return self.synthesize_for_stmt_ImportWildCard(inher_aux, module_tree, module_aux)
    
    # inspect: stmt <-- Global"
    def inspect_stmt_Global(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Global_names(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_name(child_token, child_inher_aux)
        names_tree = synth.tree
        assert isinstance(names_tree, sequence_name)
        names_aux = synth.aux
        

        return self.synthesize_for_stmt_Global(inher_aux, names_tree, names_aux)
    
    # inspect: stmt <-- Nonlocal"
    def inspect_stmt_Nonlocal(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Nonlocal_names(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_sequence_name(child_token, child_inher_aux)
        names_tree = synth.tree
        assert isinstance(names_tree, sequence_name)
        names_aux = synth.aux
        

        return self.synthesize_for_stmt_Nonlocal(inher_aux, names_tree, names_aux)
    
    # inspect: stmt <-- Expr"
    def inspect_stmt_Expr(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_stmt_Expr_content(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        content_tree = synth.tree
        assert isinstance(content_tree, expr)
        content_aux = synth.aux
        

        return self.synthesize_for_stmt_Expr(inher_aux, content_tree, content_aux)
    
    # inspect: stmt <-- Pass"
    def inspect_stmt_Pass(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_stmt_Pass(inher_aux)
    
    # inspect: stmt <-- Break"
    def inspect_stmt_Break(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_stmt_Break(inher_aux)
    
    # inspect: stmt <-- Continue"
    def inspect_stmt_Continue(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_stmt_Continue(inher_aux)
    
    # inspect: expr <-- ParenExpr
    def inspect_expr_ParenExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux
                
            post_comment_tree = children[2].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[2].aux
                
            return self.synthesize_for_expr_ParenExpr(inher_aux, pre_comment_tree, pre_comment_aux, content_tree, content_aux, post_comment_tree, post_comment_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_ParenExpr_pre_comment(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "ParenExpr"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux


            child_inher_aux = self.traverse_expr_ParenExpr_post_comment(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "ParenExpr"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "ParenExpr"), inher_aux, children))

            
            pre_comment_tree = children[0].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_ParenExpr_content(
                inher_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- BoolOp
    def inspect_expr_BoolOp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
                
            op_tree = children[1].tree
            assert isinstance(op_tree, bool_rator)
            op_aux = children[1].aux
                
            right_tree = children[2].tree
            assert isinstance(right_tree, expr)
            right_aux = children[2].aux
                
            return self.synthesize_for_expr_BoolOp(inher_aux, left_tree, left_aux, op_tree, op_aux, right_tree, right_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux


            child_inher_aux = self.traverse_expr_BoolOp_op(
                inher_aux,
                left_tree, 
                left_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_bool_rator(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "BoolOp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "BoolOp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_BoolOp_left(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 2 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "BoolOp"), inher_aux, children))

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
            op_tree = children[1].tree
            assert isinstance(op_tree, bool_rator)
            op_aux = children[1].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_BoolOp_right(
                inher_aux,
                left_tree, 
                left_aux,
                op_tree, 
                op_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- AssignExpr
    def inspect_expr_AssignExpr(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            target_tree = children[0].tree
            assert isinstance(target_tree, expr)
            target_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux
                
            return self.synthesize_for_expr_AssignExpr(inher_aux, target_tree, target_aux, content_tree, content_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "AssignExpr"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_AssignExpr_target(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "AssignExpr"), inher_aux, children))

            
            target_tree = children[0].tree
            assert isinstance(target_tree, expr)
            target_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_AssignExpr_content(
                inher_aux,
                target_tree, 
                target_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- BinOp
    def inspect_expr_BinOp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 5

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
                
            pre_comment_tree = children[1].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[1].aux
                
            rator_tree = children[2].tree
            assert isinstance(rator_tree, bin_rator)
            rator_aux = children[2].aux
                
            post_comment_tree = children[3].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[3].aux
                
            right_tree = children[4].tree
            assert isinstance(right_tree, expr)
            right_aux = children[4].aux
                
            return self.synthesize_for_expr_BinOp(inher_aux, left_tree, left_aux, pre_comment_tree, pre_comment_aux, rator_tree, rator_aux, post_comment_tree, post_comment_aux, right_tree, right_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux


            child_inher_aux = self.traverse_expr_BinOp_pre_comment(
                inher_aux,
                left_tree, 
                left_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "BinOp"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
            pre_comment_tree = children[1].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[1].aux


            child_inher_aux = self.traverse_expr_BinOp_rator(
                inher_aux,
                left_tree, 
                left_aux,
                pre_comment_tree, 
                pre_comment_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_bin_rator(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "BinOp"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 3: # index does *not* refer to an inductive child

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
            pre_comment_tree = children[1].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[1].aux
            rator_tree = children[2].tree
            assert isinstance(rator_tree, bin_rator)
            rator_aux = children[2].aux


            child_inher_aux = self.traverse_expr_BinOp_post_comment(
                inher_aux,
                left_tree, 
                left_aux,
                pre_comment_tree, 
                pre_comment_aux,
                rator_tree, 
                rator_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "BinOp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "BinOp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_BinOp_left(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 4 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "BinOp"), inher_aux, children))

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
            pre_comment_tree = children[1].tree
            assert isinstance(pre_comment_tree, str)
            pre_comment_aux = children[1].aux
            rator_tree = children[2].tree
            assert isinstance(rator_tree, bin_rator)
            rator_aux = children[2].aux
            post_comment_tree = children[3].tree
            assert isinstance(post_comment_tree, str)
            post_comment_aux = children[3].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_BinOp_right(
                inher_aux,
                left_tree, 
                left_aux,
                pre_comment_tree, 
                pre_comment_aux,
                rator_tree, 
                rator_aux,
                post_comment_tree, 
                post_comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- UnaryOp
    def inspect_expr_UnaryOp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            rator_tree = children[0].tree
            assert isinstance(rator_tree, unary_rator)
            rator_aux = children[0].aux
                
            comment_tree = children[1].tree
            assert isinstance(comment_tree, str)
            comment_aux = children[1].aux
                
            rand_tree = children[2].tree
            assert isinstance(rand_tree, expr)
            rand_aux = children[2].aux
                
            return self.synthesize_for_expr_UnaryOp(inher_aux, rator_tree, rator_aux, comment_tree, comment_aux, rand_tree, rand_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_UnaryOp_rator(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_unary_rator(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "UnaryOp"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            rator_tree = children[0].tree
            assert isinstance(rator_tree, unary_rator)
            rator_aux = children[0].aux


            child_inher_aux = self.traverse_expr_UnaryOp_comment(
                inher_aux,
                rator_tree, 
                rator_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "UnaryOp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 2 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "UnaryOp"), inher_aux, children))

            
            rator_tree = children[0].tree
            assert isinstance(rator_tree, unary_rator)
            rator_aux = children[0].aux
            comment_tree = children[1].tree
            assert isinstance(comment_tree, str)
            comment_aux = children[1].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_UnaryOp_rand(
                inher_aux,
                rator_tree, 
                rator_aux,
                comment_tree, 
                comment_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Lambda
    def inspect_expr_Lambda(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            params_tree = children[0].tree
            assert isinstance(params_tree, parameters)
            params_aux = children[0].aux
                
            body_tree = children[1].tree
            assert isinstance(body_tree, expr)
            body_aux = children[1].aux
                
            return self.synthesize_for_expr_Lambda(inher_aux, params_tree, params_aux, body_tree, body_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Lambda_params(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_parameters(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Lambda"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Lambda"), inher_aux, children))

            
            params_tree = children[0].tree
            assert isinstance(params_tree, parameters)
            params_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_Lambda_body(
                inher_aux,
                params_tree, 
                params_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- IfExp
    def inspect_expr_IfExp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            body_tree = children[0].tree
            assert isinstance(body_tree, expr)
            body_aux = children[0].aux
                
            test_tree = children[1].tree
            assert isinstance(test_tree, expr)
            test_aux = children[1].aux
                
            orelse_tree = children[2].tree
            assert isinstance(orelse_tree, expr)
            orelse_aux = children[2].aux
                
            return self.synthesize_for_expr_IfExp(inher_aux, body_tree, body_aux, test_tree, test_aux, orelse_tree, orelse_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "IfExp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_IfExp_body(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "IfExp"), inher_aux, children))

            
            body_tree = children[0].tree
            assert isinstance(body_tree, expr)
            body_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_IfExp_test(
                inher_aux,
                body_tree, 
                body_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 2 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "IfExp"), inher_aux, children))

            
            body_tree = children[0].tree
            assert isinstance(body_tree, expr)
            body_aux = children[0].aux
            test_tree = children[1].tree
            assert isinstance(test_tree, expr)
            test_aux = children[1].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_IfExp_orelse(
                inher_aux,
                body_tree, 
                body_aux,
                test_tree, 
                test_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Dictionary
    def inspect_expr_Dictionary(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, dictionary_content)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Dictionary(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Dictionary_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_dictionary_content(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Dictionary"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- EmptyDictionary
    def inspect_expr_EmptyDictionary(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_EmptyDictionary(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Set
    def inspect_expr_Set(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, comma_exprs)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Set(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Set_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comma_exprs(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Set"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- ListComp
    def inspect_expr_ListComp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            constraints_tree = children[1].tree
            assert isinstance(constraints_tree, comprehension_constraints)
            constraints_aux = children[1].aux
                
            return self.synthesize_for_expr_ListComp(inher_aux, content_tree, content_aux, constraints_tree, constraints_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux


            child_inher_aux = self.traverse_expr_ListComp_constraints(
                inher_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comprehension_constraints(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "ListComp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "ListComp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_ListComp_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- SetComp
    def inspect_expr_SetComp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            constraints_tree = children[1].tree
            assert isinstance(constraints_tree, comprehension_constraints)
            constraints_aux = children[1].aux
                
            return self.synthesize_for_expr_SetComp(inher_aux, content_tree, content_aux, constraints_tree, constraints_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux


            child_inher_aux = self.traverse_expr_SetComp_constraints(
                inher_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comprehension_constraints(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "SetComp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "SetComp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_SetComp_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- DictionaryComp
    def inspect_expr_DictionaryComp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            key_tree = children[0].tree
            assert isinstance(key_tree, expr)
            key_aux = children[0].aux
                
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux
                
            constraints_tree = children[2].tree
            assert isinstance(constraints_tree, comprehension_constraints)
            constraints_aux = children[2].aux
                
            return self.synthesize_for_expr_DictionaryComp(inher_aux, key_tree, key_aux, content_tree, content_aux, constraints_tree, constraints_aux)
        
        elif index == 2: # index does *not* refer to an inductive child

            
            key_tree = children[0].tree
            assert isinstance(key_tree, expr)
            key_aux = children[0].aux
            content_tree = children[1].tree
            assert isinstance(content_tree, expr)
            content_aux = children[1].aux


            child_inher_aux = self.traverse_expr_DictionaryComp_constraints(
                inher_aux,
                key_tree, 
                key_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comprehension_constraints(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "DictionaryComp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "DictionaryComp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_DictionaryComp_key(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "DictionaryComp"), inher_aux, children))

            
            key_tree = children[0].tree
            assert isinstance(key_tree, expr)
            key_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_DictionaryComp_content(
                inher_aux,
                key_tree, 
                key_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- GeneratorExp
    def inspect_expr_GeneratorExp(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            constraints_tree = children[1].tree
            assert isinstance(constraints_tree, comprehension_constraints)
            constraints_aux = children[1].aux
                
            return self.synthesize_for_expr_GeneratorExp(inher_aux, content_tree, content_aux, constraints_tree, constraints_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux


            child_inher_aux = self.traverse_expr_GeneratorExp_constraints(
                inher_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comprehension_constraints(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "GeneratorExp"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "GeneratorExp"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_GeneratorExp_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Await
    def inspect_expr_Await(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Await(inher_aux, content_tree, content_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Await"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Await_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- YieldNothing
    def inspect_expr_YieldNothing(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_YieldNothing(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Yield
    def inspect_expr_Yield(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Yield(inher_aux, content_tree, content_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Yield"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Yield_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- YieldFrom
    def inspect_expr_YieldFrom(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_YieldFrom(inher_aux, content_tree, content_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "YieldFrom"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_YieldFrom_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Compare
    def inspect_expr_Compare(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux
                
            comps_tree = children[1].tree
            assert isinstance(comps_tree, comparisons)
            comps_aux = children[1].aux
                
            return self.synthesize_for_expr_Compare(inher_aux, left_tree, left_aux, comps_tree, comps_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            left_tree = children[0].tree
            assert isinstance(left_tree, expr)
            left_aux = children[0].aux


            child_inher_aux = self.traverse_expr_Compare_comps(
                inher_aux,
                left_tree, 
                left_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comparisons(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Compare"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Compare"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Compare_left(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Call
    def inspect_expr_Call(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            func_tree = children[0].tree
            assert isinstance(func_tree, expr)
            func_aux = children[0].aux
                
            return self.synthesize_for_expr_Call(inher_aux, func_tree, func_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Call"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Call_func(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- CallArgs
    def inspect_expr_CallArgs(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            func_tree = children[0].tree
            assert isinstance(func_tree, expr)
            func_aux = children[0].aux
                
            args_tree = children[1].tree
            assert isinstance(args_tree, arguments)
            args_aux = children[1].aux
                
            return self.synthesize_for_expr_CallArgs(inher_aux, func_tree, func_aux, args_tree, args_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            func_tree = children[0].tree
            assert isinstance(func_tree, expr)
            func_aux = children[0].aux


            child_inher_aux = self.traverse_expr_CallArgs_args(
                inher_aux,
                func_tree, 
                func_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_arguments(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "CallArgs"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "CallArgs"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_CallArgs_func(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Integer
    def inspect_expr_Integer(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, str)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Integer(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Integer_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Integer"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Float
    def inspect_expr_Float(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, str)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Float(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Float_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Float"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- ConcatString
    def inspect_expr_ConcatString(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, sequence_string)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_ConcatString(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_ConcatString_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_sequence_string(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "ConcatString"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- True_
    def inspect_expr_True_(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_True_(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- False_
    def inspect_expr_False_(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_False_(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- None_
    def inspect_expr_None_(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_None_(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Ellip
    def inspect_expr_Ellip(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_Ellip(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Attribute
    def inspect_expr_Attribute(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            name_tree = children[1].tree
            assert isinstance(name_tree, str)
            name_aux = children[1].aux
                
            return self.synthesize_for_expr_Attribute(inher_aux, content_tree, content_aux, name_tree, name_aux)
        
        elif index == 1: # index does *not* refer to an inductive child

            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux


            child_inher_aux = self.traverse_expr_Attribute_name(
                inher_aux,
                content_tree, 
                content_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Attribute"), inher_aux, children + (child_synth,)))
            return None
            
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Attribute"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Attribute_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Subscript
    def inspect_expr_Subscript(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 2

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            slice_tree = children[1].tree
            assert isinstance(slice_tree, expr)
            slice_aux = children[1].aux
                
            return self.synthesize_for_expr_Subscript(inher_aux, content_tree, content_aux, slice_tree, slice_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Subscript"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Subscript_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            

        elif index == 1 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Subscript"), inher_aux, children))

            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux

            # add on child node 
            child_inher_aux = self.traverse_expr_Subscript_slice(
                inher_aux,
                content_tree, 
                content_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Starred
    def inspect_expr_Starred(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        
        if stack_result:
            # get the result from the child in the stack
            children = children + (stack_result,)
        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, expr)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Starred(inher_aux, content_tree, content_aux)
        
        
        elif index == 0 : # index refers to an inductive child
            # put back current node
            stack.append((make_Grammar("expr", "Starred"), inher_aux, children))

            

            # add on child node 
            child_inher_aux = self.traverse_expr_Starred_content(
                inher_aux
            )
            stack.append((self.next(child_inher_aux), child_inher_aux, ()))
            
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Name
    def inspect_expr_Name(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, str)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Name(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Name_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_str(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Name"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- List
    def inspect_expr_List(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, comma_exprs)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_List(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_List_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comma_exprs(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "List"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- EmptyList
    def inspect_expr_EmptyList(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_EmptyList(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Tuple
    def inspect_expr_Tuple(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 1

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            content_tree = children[0].tree
            assert isinstance(content_tree, comma_exprs)
            content_aux = children[0].aux
                
            return self.synthesize_for_expr_Tuple(inher_aux, content_tree, content_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Tuple_content(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_comma_exprs(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Tuple"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- EmptyTuple
    def inspect_expr_EmptyTuple(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 0

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            return self.synthesize_for_expr_EmptyTuple(inher_aux)
        
        
        else:
            raise SyntaxError()
    
    # inspect: expr <-- Slice
    def inspect_expr_Slice(self,
        inher_aux : InherAux, children : tuple[Result[SynthAux], ...], stack_result : Optional[Result[SynthAux]], 
        stack : list[tuple[abstract_token, InherAux, tuple[Result[SynthAux], ...]]]
    ) -> Optional[Result[SynthAux]]:

        

        total_num_children = 3

        index = len(children)
        if index == total_num_children:
            # the processing of the current rule has completed
            # return the analysis result to the previous item in the stack
            
            lower_tree = children[0].tree
            assert isinstance(lower_tree, option_expr)
            lower_aux = children[0].aux
                
            upper_tree = children[1].tree
            assert isinstance(upper_tree, option_expr)
            upper_aux = children[1].aux
                
            step_tree = children[2].tree
            assert isinstance(step_tree, option_expr)
            step_aux = children[2].aux
                
            return self.synthesize_for_expr_Slice(inher_aux, lower_tree, lower_aux, upper_tree, upper_aux, step_tree, step_aux)
        
        elif index == 0: # index does *not* refer to an inductive child

            


            child_inher_aux = self.traverse_expr_Slice_lower(
                inher_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_option_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Slice"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 1: # index does *not* refer to an inductive child

            
            lower_tree = children[0].tree
            assert isinstance(lower_tree, option_expr)
            lower_aux = children[0].aux


            child_inher_aux = self.traverse_expr_Slice_upper(
                inher_aux,
                lower_tree, 
                lower_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_option_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Slice"), inher_aux, children + (child_synth,)))
            return None
            

        elif index == 2: # index does *not* refer to an inductive child

            
            lower_tree = children[0].tree
            assert isinstance(lower_tree, option_expr)
            lower_aux = children[0].aux
            upper_tree = children[1].tree
            assert isinstance(upper_tree, option_expr)
            upper_aux = children[1].aux


            child_inher_aux = self.traverse_expr_Slice_step(
                inher_aux,
                lower_tree, 
                lower_aux,
                upper_tree, 
                upper_aux
            )
            child_token = self.next(child_inher_aux)
            child_synth = self.crawl_option_expr(child_token, child_inher_aux)

            stack.append((make_Grammar("expr", "Slice"), inher_aux, children + (child_synth,)))
            return None
            
        
        else:
            raise SyntaxError()
    
    # inspect: bool_rator <-- And"
    def inspect_bool_rator_And(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bool_rator_And(inher_aux)
    
    # inspect: bool_rator <-- Or"
    def inspect_bool_rator_Or(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bool_rator_Or(inher_aux)
    
    # inspect: bin_rator <-- Add"
    def inspect_bin_rator_Add(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Add(inher_aux)
    
    # inspect: bin_rator <-- Sub"
    def inspect_bin_rator_Sub(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Sub(inher_aux)
    
    # inspect: bin_rator <-- Mult"
    def inspect_bin_rator_Mult(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Mult(inher_aux)
    
    # inspect: bin_rator <-- MatMult"
    def inspect_bin_rator_MatMult(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_MatMult(inher_aux)
    
    # inspect: bin_rator <-- Div"
    def inspect_bin_rator_Div(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Div(inher_aux)
    
    # inspect: bin_rator <-- Mod"
    def inspect_bin_rator_Mod(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Mod(inher_aux)
    
    # inspect: bin_rator <-- Pow"
    def inspect_bin_rator_Pow(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_Pow(inher_aux)
    
    # inspect: bin_rator <-- LShift"
    def inspect_bin_rator_LShift(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_LShift(inher_aux)
    
    # inspect: bin_rator <-- RShift"
    def inspect_bin_rator_RShift(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_RShift(inher_aux)
    
    # inspect: bin_rator <-- BitOr"
    def inspect_bin_rator_BitOr(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_BitOr(inher_aux)
    
    # inspect: bin_rator <-- BitXor"
    def inspect_bin_rator_BitXor(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_BitXor(inher_aux)
    
    # inspect: bin_rator <-- BitAnd"
    def inspect_bin_rator_BitAnd(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_BitAnd(inher_aux)
    
    # inspect: bin_rator <-- FloorDiv"
    def inspect_bin_rator_FloorDiv(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_bin_rator_FloorDiv(inher_aux)
    
    # inspect: unary_rator <-- Invert"
    def inspect_unary_rator_Invert(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_unary_rator_Invert(inher_aux)
    
    # inspect: unary_rator <-- Not"
    def inspect_unary_rator_Not(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_unary_rator_Not(inher_aux)
    
    # inspect: unary_rator <-- UAdd"
    def inspect_unary_rator_UAdd(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_unary_rator_UAdd(inher_aux)
    
    # inspect: unary_rator <-- USub"
    def inspect_unary_rator_USub(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_unary_rator_USub(inher_aux)
    
    # inspect: cmp_rator <-- Eq"
    def inspect_cmp_rator_Eq(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_Eq(inher_aux)
    
    # inspect: cmp_rator <-- NotEq"
    def inspect_cmp_rator_NotEq(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_NotEq(inher_aux)
    
    # inspect: cmp_rator <-- Lt"
    def inspect_cmp_rator_Lt(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_Lt(inher_aux)
    
    # inspect: cmp_rator <-- LtE"
    def inspect_cmp_rator_LtE(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_LtE(inher_aux)
    
    # inspect: cmp_rator <-- Gt"
    def inspect_cmp_rator_Gt(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_Gt(inher_aux)
    
    # inspect: cmp_rator <-- GtE"
    def inspect_cmp_rator_GtE(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_GtE(inher_aux)
    
    # inspect: cmp_rator <-- Is"
    def inspect_cmp_rator_Is(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_Is(inher_aux)
    
    # inspect: cmp_rator <-- IsNot"
    def inspect_cmp_rator_IsNot(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_IsNot(inher_aux)
    
    # inspect: cmp_rator <-- In"
    def inspect_cmp_rator_In(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_In(inher_aux)
    
    # inspect: cmp_rator <-- NotIn"
    def inspect_cmp_rator_NotIn(self, inher_aux : InherAux) -> Result[SynthAux]:


        

        return self.synthesize_for_cmp_rator_NotIn(inher_aux)
    
    # inspect: constraint <-- AsyncConstraint"
    def inspect_constraint_AsyncConstraint(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_constraint_AsyncConstraint_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_constraint_AsyncConstraint_search_space(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        search_space_tree = synth.tree
        assert isinstance(search_space_tree, expr)
        search_space_aux = synth.aux
        
        child_inher_aux = self.traverse_constraint_AsyncConstraint_filts(
            inher_aux,
            target_tree, 
            target_aux,
            search_space_tree, 
            search_space_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_constraint_filters(child_token, child_inher_aux)
        filts_tree = synth.tree
        assert isinstance(filts_tree, constraint_filters)
        filts_aux = synth.aux
        

        return self.synthesize_for_constraint_AsyncConstraint(inher_aux, target_tree, target_aux, search_space_tree, search_space_aux, filts_tree, filts_aux)
    
    # inspect: constraint <-- Constraint"
    def inspect_constraint_Constraint(self, inher_aux : InherAux) -> Result[SynthAux]:


        
        child_inher_aux = self.traverse_constraint_Constraint_target(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        target_tree = synth.tree
        assert isinstance(target_tree, expr)
        target_aux = synth.aux
        
        child_inher_aux = self.traverse_constraint_Constraint_search_space(
            inher_aux,
            target_tree, 
            target_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        search_space_tree = synth.tree
        assert isinstance(search_space_tree, expr)
        search_space_aux = synth.aux
        
        child_inher_aux = self.traverse_constraint_Constraint_filts(
            inher_aux,
            target_tree, 
            target_aux,
            search_space_tree, 
            search_space_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_constraint_filters(child_token, child_inher_aux)
        filts_tree = synth.tree
        assert isinstance(filts_tree, constraint_filters)
        filts_aux = synth.aux
        

        return self.synthesize_for_constraint_Constraint(inher_aux, target_tree, target_aux, search_space_tree, search_space_aux, filts_tree, filts_aux)
     
    
    # inspect: CompareRight"
    def inspect_CompareRight(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "CompareRight": raise SyntaxError()
        

        child_inher_aux = self.traverse_CompareRight_rator(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_cmp_rator(child_token, child_inher_aux)
        rator_tree = synth.tree
        assert isinstance(rator_tree, cmp_rator)
        rator_aux = synth.aux
            

        child_inher_aux = self.traverse_CompareRight_rand(
            inher_aux,
            rator_tree, 
            rator_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        rand_tree = synth.tree
        assert isinstance(rand_tree, expr)
        rand_aux = synth.aux
            


        return self.synthesize_for_CompareRight(inher_aux, rator_tree, rator_aux, rand_tree, rand_aux)
    
    # inspect: ExceptHandler"
    def inspect_ExceptHandler(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "ExceptHandler": raise SyntaxError()
        

        child_inher_aux = self.traverse_ExceptHandler_arg(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_except_arg(child_token, child_inher_aux)
        arg_tree = synth.tree
        assert isinstance(arg_tree, except_arg)
        arg_aux = synth.aux
            

        child_inher_aux = self.traverse_ExceptHandler_comment(
            inher_aux,
            arg_tree, 
            arg_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
            

        child_inher_aux = self.traverse_ExceptHandler_body(
            inher_aux,
            arg_tree, 
            arg_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
            


        return self.synthesize_for_ExceptHandler(inher_aux, arg_tree, arg_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: Param"
    def inspect_Param(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "Param": raise SyntaxError()
        

        child_inher_aux = self.traverse_Param_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
            

        child_inher_aux = self.traverse_Param_anno(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_param_annotation(child_token, child_inher_aux)
        anno_tree = synth.tree
        assert isinstance(anno_tree, param_annotation)
        anno_aux = synth.aux
            

        child_inher_aux = self.traverse_Param_default(
            inher_aux,
            name_tree, 
            name_aux,
            anno_tree, 
            anno_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_param_default(child_token, child_inher_aux)
        default_tree = synth.tree
        assert isinstance(default_tree, param_default)
        default_aux = synth.aux
            


        return self.synthesize_for_Param(inher_aux, name_tree, name_aux, anno_tree, anno_aux, default_tree, default_aux)
    
    # inspect: ClassDef"
    def inspect_ClassDef(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "ClassDef": raise SyntaxError()
        

        child_inher_aux = self.traverse_ClassDef_name(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        name_tree = synth.tree
        assert isinstance(name_tree, str)
        name_aux = synth.aux
            

        child_inher_aux = self.traverse_ClassDef_bs(
            inher_aux,
            name_tree, 
            name_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_bases(child_token, child_inher_aux)
        bs_tree = synth.tree
        assert isinstance(bs_tree, bases)
        bs_aux = synth.aux
            

        child_inher_aux = self.traverse_ClassDef_comment(
            inher_aux,
            name_tree, 
            name_aux,
            bs_tree, 
            bs_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
            

        child_inher_aux = self.traverse_ClassDef_body(
            inher_aux,
            name_tree, 
            name_aux,
            bs_tree, 
            bs_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
            


        return self.synthesize_for_ClassDef(inher_aux, name_tree, name_aux, bs_tree, bs_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: ElifBlock"
    def inspect_ElifBlock(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "ElifBlock": raise SyntaxError()
        

        child_inher_aux = self.traverse_ElifBlock_test(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_expr(child_token, child_inher_aux)
        test_tree = synth.tree
        assert isinstance(test_tree, expr)
        test_aux = synth.aux
            

        child_inher_aux = self.traverse_ElifBlock_comment(
            inher_aux,
            test_tree, 
            test_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
            

        child_inher_aux = self.traverse_ElifBlock_body(
            inher_aux,
            test_tree, 
            test_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
            


        return self.synthesize_for_ElifBlock(inher_aux, test_tree, test_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: ElseBlock"
    def inspect_ElseBlock(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "ElseBlock": raise SyntaxError()
        

        child_inher_aux = self.traverse_ElseBlock_comment(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
            

        child_inher_aux = self.traverse_ElseBlock_body(
            inher_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
            


        return self.synthesize_for_ElseBlock(inher_aux, comment_tree, comment_aux, body_tree, body_aux)
    
    # inspect: FinallyBlock"
    def inspect_FinallyBlock(self, token : Grammar, inher_aux : InherAux) -> Result[SynthAux]:
        if token.selection != "FinallyBlock": raise SyntaxError()
        

        child_inher_aux = self.traverse_FinallyBlock_comment(
            inher_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_str(child_token, child_inher_aux)
        comment_tree = synth.tree
        assert isinstance(comment_tree, str)
        comment_aux = synth.aux
            

        child_inher_aux = self.traverse_FinallyBlock_body(
            inher_aux,
            comment_tree, 
            comment_aux
        )
        child_token = self.next(child_inher_aux)
        synth = self.crawl_statements(child_token, child_inher_aux)
        body_tree = synth.tree
        assert isinstance(body_tree, statements)
        body_aux = synth.aux
            


        return self.synthesize_for_FinallyBlock(inher_aux, comment_tree, comment_aux, body_tree, body_aux)
     

    
    # traverse return_annotation <-- SomeReturnAnno"
    def traverse_return_annotation_SomeReturnAnno_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse except_arg <-- SomeExceptArg"
    def traverse_except_arg_SomeExceptArg_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse except_arg <-- SomeExceptArgName"
    def traverse_except_arg_SomeExceptArgName_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse except_arg <-- SomeExceptArgName"
    def traverse_except_arg_SomeExceptArgName_name(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'str') 
    
    # traverse param_annotation <-- SomeParamAnno"
    def traverse_param_annotation_SomeParamAnno_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse param_default <-- SomeParamDefault"
    def traverse_param_default_SomeParamDefault_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse parameters_d <-- ConsKwParam"
    def traverse_parameters_d_ConsKwParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_d <-- ConsKwParam"
    def traverse_parameters_d_ConsKwParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'parameters_d') 
    
    # traverse parameters_d <-- SingleKwParam"
    def traverse_parameters_d_SingleKwParam_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_d <-- TransKwParam"
    def traverse_parameters_d_TransKwParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_d <-- TransKwParam"
    def traverse_parameters_d_TransKwParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'Param') 
    
    # traverse parameters_c <-- SingleTupleBundleParam"
    def traverse_parameters_c_SingleTupleBundleParam_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_c <-- TransTupleBundleParam"
    def traverse_parameters_c_TransTupleBundleParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_c <-- TransTupleBundleParam"
    def traverse_parameters_c_TransTupleBundleParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'parameters_d') 
    
    # traverse parameters_c <-- ParamsD"
    def traverse_parameters_c_ParamsD_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'parameters_d') 
    
    # traverse parameters_c <-- DoubleBundleParam"
    def traverse_parameters_c_DoubleBundleParam_tuple_param(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_c <-- DoubleBundleParam"
    def traverse_parameters_c_DoubleBundleParam_dict_param(self, 
        inher_aux : InherAux,
        tuple_param_tree : Param, 
        tuple_param_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (tuple_param_aux,), 'Param') 
    
    # traverse parameters_c <-- DictionaryBundleParam"
    def traverse_parameters_c_DictionaryBundleParam_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_b <-- ConsPosKeyParam"
    def traverse_parameters_b_ConsPosKeyParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_b <-- ConsPosKeyParam"
    def traverse_parameters_b_ConsPosKeyParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'parameters_b') 
    
    # traverse parameters_b <-- SinglePosKeyParam"
    def traverse_parameters_b_SinglePosKeyParam_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_b <-- ParamsC"
    def traverse_parameters_b_ParamsC_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'parameters_c') 
    
    # traverse parameters_a <-- ConsPosParam"
    def traverse_parameters_a_ConsPosParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_a <-- ConsPosParam"
    def traverse_parameters_a_ConsPosParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'parameters_a') 
    
    # traverse parameters_a <-- SinglePosParam"
    def traverse_parameters_a_SinglePosParam_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_a <-- TransPosParam"
    def traverse_parameters_a_TransPosParam_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'Param') 
    
    # traverse parameters_a <-- TransPosParam"
    def traverse_parameters_a_TransPosParam_tail(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'parameters_b') 
    
    # traverse parameters <-- ParamsA"
    def traverse_parameters_ParamsA_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'parameters_a') 
    
    # traverse parameters <-- ParamsB"
    def traverse_parameters_ParamsB_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'parameters_b') 
    
    # traverse keyword <-- NamedKeyword"
    def traverse_keyword_NamedKeyword_name(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse keyword <-- NamedKeyword"
    def traverse_keyword_NamedKeyword_content(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'expr') 
    
    # traverse keyword <-- SplatKeyword"
    def traverse_keyword_SplatKeyword_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse import_name <-- ImportNameAlias"
    def traverse_import_name_ImportNameAlias_name(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse import_name <-- ImportNameAlias"
    def traverse_import_name_ImportNameAlias_alias(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'str') 
    
    # traverse import_name <-- ImportNameOnly"
    def traverse_import_name_ImportNameOnly_name(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse with_item <-- WithItemAlias"
    def traverse_with_item_WithItemAlias_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse with_item <-- WithItemAlias"
    def traverse_with_item_WithItemAlias_alias(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'expr') 
    
    # traverse with_item <-- WithItemOnly"
    def traverse_with_item_WithItemOnly_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse bases <-- SomeBases"
    def traverse_bases_SomeBases_bases(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'bases_a') 
    
    # traverse bases_a <-- ConsBase"
    def traverse_bases_a_ConsBase_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse bases_a <-- ConsBase"
    def traverse_bases_a_ConsBase_tail(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'bases_a') 
    
    # traverse bases_a <-- SingleBase"
    def traverse_bases_a_SingleBase_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse bases_a <-- KeywordBases"
    def traverse_bases_a_KeywordBases_kws(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'keywords') 
    
    # traverse keywords <-- ConsKeyword"
    def traverse_keywords_ConsKeyword_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse keywords <-- ConsKeyword"
    def traverse_keywords_ConsKeyword_head(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'keyword') 
    
    # traverse keywords <-- ConsKeyword"
    def traverse_keywords_ConsKeyword_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : keyword, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux,), 'str') 
    
    # traverse keywords <-- ConsKeyword"
    def traverse_keywords_ConsKeyword_tail(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : keyword, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux, post_comment_aux,), 'keywords') 
    
    # traverse keywords <-- SingleKeyword"
    def traverse_keywords_SingleKeyword_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse keywords <-- SingleKeyword"
    def traverse_keywords_SingleKeyword_content(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'keyword') 
    
    # traverse keywords <-- SingleKeyword"
    def traverse_keywords_SingleKeyword_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : keyword, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, content_aux,), 'str') 
    
    # traverse comparisons <-- ConsCompareRight"
    def traverse_comparisons_ConsCompareRight_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'CompareRight') 
    
    # traverse comparisons <-- ConsCompareRight"
    def traverse_comparisons_ConsCompareRight_tail(self, 
        inher_aux : InherAux,
        head_tree : CompareRight, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'comparisons') 
    
    # traverse comparisons <-- SingleCompareRight"
    def traverse_comparisons_SingleCompareRight_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'CompareRight') 
    
    # traverse option_expr <-- SomeExpr"
    def traverse_option_expr_SomeExpr_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse comma_exprs <-- ConsExpr"
    def traverse_comma_exprs_ConsExpr_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse comma_exprs <-- ConsExpr"
    def traverse_comma_exprs_ConsExpr_head(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'expr') 
    
    # traverse comma_exprs <-- ConsExpr"
    def traverse_comma_exprs_ConsExpr_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux,), 'str') 
    
    # traverse comma_exprs <-- ConsExpr"
    def traverse_comma_exprs_ConsExpr_tail(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux, post_comment_aux,), 'comma_exprs') 
    
    # traverse comma_exprs <-- SingleExpr"
    def traverse_comma_exprs_SingleExpr_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse comma_exprs <-- SingleExpr"
    def traverse_comma_exprs_SingleExpr_content(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'expr') 
    
    # traverse comma_exprs <-- SingleExpr"
    def traverse_comma_exprs_SingleExpr_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, content_aux,), 'str') 
    
    # traverse target_exprs <-- ConsTargetExpr"
    def traverse_target_exprs_ConsTargetExpr_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse target_exprs <-- ConsTargetExpr"
    def traverse_target_exprs_ConsTargetExpr_tail(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'target_exprs') 
    
    # traverse target_exprs <-- SingleTargetExpr"
    def traverse_target_exprs_SingleTargetExpr_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse decorator <-- ExprDec"
    def traverse_decorator_ExprDec_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse decorator <-- CmntDec"
    def traverse_decorator_CmntDec_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse decorators <-- ConsDec"
    def traverse_decorators_ConsDec_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'decorator') 
    
    # traverse decorators <-- ConsDec"
    def traverse_decorators_ConsDec_tail(self, 
        inher_aux : InherAux,
        head_tree : decorator, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'decorators') 
    
    # traverse constraint_filters <-- ConsFilter"
    def traverse_constraint_filters_ConsFilter_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse constraint_filters <-- ConsFilter"
    def traverse_constraint_filters_ConsFilter_tail(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'constraint_filters') 
    
    # traverse constraint_filters <-- SingleFilter"
    def traverse_constraint_filters_SingleFilter_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse sequence_string <-- ConsStr"
    def traverse_sequence_string_ConsStr_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse sequence_string <-- ConsStr"
    def traverse_sequence_string_ConsStr_tail(self, 
        inher_aux : InherAux,
        head_tree : str, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'sequence_string') 
    
    # traverse sequence_string <-- SingleStr"
    def traverse_sequence_string_SingleStr_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse arguments <-- ConsArg"
    def traverse_arguments_ConsArg_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse arguments <-- ConsArg"
    def traverse_arguments_ConsArg_head(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'expr') 
    
    # traverse arguments <-- ConsArg"
    def traverse_arguments_ConsArg_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux,), 'str') 
    
    # traverse arguments <-- ConsArg"
    def traverse_arguments_ConsArg_tail(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, head_aux, post_comment_aux,), 'arguments') 
    
    # traverse arguments <-- SingleArg"
    def traverse_arguments_SingleArg_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse arguments <-- SingleArg"
    def traverse_arguments_SingleArg_content(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'expr') 
    
    # traverse arguments <-- SingleArg"
    def traverse_arguments_SingleArg_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, content_aux,), 'str') 
    
    # traverse arguments <-- KeywordsArg"
    def traverse_arguments_KeywordsArg_kws(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'keywords') 
    
    # traverse dictionary_item <-- Field"
    def traverse_dictionary_item_Field_key(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse dictionary_item <-- Field"
    def traverse_dictionary_item_Field_content(self, 
        inher_aux : InherAux,
        key_tree : expr, 
        key_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (key_aux,), 'expr') 
    
    # traverse dictionary_item <-- DictionarySplatFields"
    def traverse_dictionary_item_DictionarySplatFields_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse dictionary_content <-- ConsDictionaryItem"
    def traverse_dictionary_content_ConsDictionaryItem_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'dictionary_item') 
    
    # traverse dictionary_content <-- ConsDictionaryItem"
    def traverse_dictionary_content_ConsDictionaryItem_tail(self, 
        inher_aux : InherAux,
        head_tree : dictionary_item, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'dictionary_content') 
    
    # traverse dictionary_content <-- SingleDictionaryItem"
    def traverse_dictionary_content_SingleDictionaryItem_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'dictionary_item') 
    
    # traverse sequence_name <-- ConsId"
    def traverse_sequence_name_ConsId_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse sequence_name <-- ConsId"
    def traverse_sequence_name_ConsId_tail(self, 
        inher_aux : InherAux,
        head_tree : str, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'sequence_name') 
    
    # traverse sequence_name <-- SingleId"
    def traverse_sequence_name_SingleId_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse sequence_import_name <-- ConsImportName"
    def traverse_sequence_import_name_ConsImportName_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'import_name') 
    
    # traverse sequence_import_name <-- ConsImportName"
    def traverse_sequence_import_name_ConsImportName_tail(self, 
        inher_aux : InherAux,
        head_tree : import_name, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'sequence_import_name') 
    
    # traverse sequence_import_name <-- SingleImportName"
    def traverse_sequence_import_name_SingleImportName_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'import_name') 
    
    # traverse sequence_with_item <-- ConsWithItem"
    def traverse_sequence_with_item_ConsWithItem_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'with_item') 
    
    # traverse sequence_with_item <-- ConsWithItem"
    def traverse_sequence_with_item_ConsWithItem_tail(self, 
        inher_aux : InherAux,
        head_tree : with_item, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'sequence_with_item') 
    
    # traverse sequence_with_item <-- SingleWithItem"
    def traverse_sequence_with_item_SingleWithItem_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'with_item') 
    
    # traverse module <-- FutureMod"
    def traverse_module_FutureMod_names(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_import_name') 
    
    # traverse module <-- FutureMod"
    def traverse_module_FutureMod_body(self, 
        inher_aux : InherAux,
        names_tree : sequence_import_name, 
        names_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (names_aux,), 'statements') 
    
    # traverse module <-- SimpleMod"
    def traverse_module_SimpleMod_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse statements <-- ConsStmt"
    def traverse_statements_ConsStmt_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'stmt') 
    
    # traverse statements <-- ConsStmt"
    def traverse_statements_ConsStmt_tail(self, 
        inher_aux : InherAux,
        head_tree : stmt, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'statements') 
    
    # traverse statements <-- SingleStmt"
    def traverse_statements_SingleStmt_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'stmt') 
    
    # traverse comprehension_constraints <-- ConsConstraint"
    def traverse_comprehension_constraints_ConsConstraint_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'constraint') 
    
    # traverse comprehension_constraints <-- ConsConstraint"
    def traverse_comprehension_constraints_ConsConstraint_tail(self, 
        inher_aux : InherAux,
        head_tree : constraint, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'comprehension_constraints') 
    
    # traverse comprehension_constraints <-- SingleConstraint"
    def traverse_comprehension_constraints_SingleConstraint_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'constraint') 
    
    # traverse sequence_ExceptHandler <-- ConsExceptHandler"
    def traverse_sequence_ExceptHandler_ConsExceptHandler_head(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'ExceptHandler') 
    
    # traverse sequence_ExceptHandler <-- ConsExceptHandler"
    def traverse_sequence_ExceptHandler_ConsExceptHandler_tail(self, 
        inher_aux : InherAux,
        head_tree : ExceptHandler, 
        head_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (head_aux,), 'sequence_ExceptHandler') 
    
    # traverse sequence_ExceptHandler <-- SingleExceptHandler"
    def traverse_sequence_ExceptHandler_SingleExceptHandler_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'ExceptHandler') 
    
    # traverse conditions <-- ElifCond"
    def traverse_conditions_ElifCond_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'ElifBlock') 
    
    # traverse conditions <-- ElifCond"
    def traverse_conditions_ElifCond_tail(self, 
        inher_aux : InherAux,
        content_tree : ElifBlock, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'conditions') 
    
    # traverse conditions <-- ElseCond"
    def traverse_conditions_ElseCond_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'ElseBlock') 
    
    # traverse function_def <-- FunctionDef"
    def traverse_function_def_FunctionDef_name(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse function_def <-- FunctionDef"
    def traverse_function_def_FunctionDef_params(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'parameters') 
    
    # traverse function_def <-- FunctionDef"
    def traverse_function_def_FunctionDef_ret_anno(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux,), 'return_annotation') 
    
    # traverse function_def <-- FunctionDef"
    def traverse_function_def_FunctionDef_comment(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux, ret_anno_aux,), 'str') 
    
    # traverse function_def <-- FunctionDef"
    def traverse_function_def_FunctionDef_body(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux, ret_anno_aux, comment_aux,), 'statements') 
    
    # traverse function_def <-- AsyncFunctionDef"
    def traverse_function_def_AsyncFunctionDef_name(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse function_def <-- AsyncFunctionDef"
    def traverse_function_def_AsyncFunctionDef_params(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'parameters') 
    
    # traverse function_def <-- AsyncFunctionDef"
    def traverse_function_def_AsyncFunctionDef_ret_anno(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux,), 'return_annotation') 
    
    # traverse function_def <-- AsyncFunctionDef"
    def traverse_function_def_AsyncFunctionDef_comment(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux, ret_anno_aux,), 'str') 
    
    # traverse function_def <-- AsyncFunctionDef"
    def traverse_function_def_AsyncFunctionDef_body(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, params_aux, ret_anno_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- Comment"
    def traverse_stmt_Comment_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse stmt <-- DecFunctionDef"
    def traverse_stmt_DecFunctionDef_decs(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'decorators') 
    
    # traverse stmt <-- DecFunctionDef"
    def traverse_stmt_DecFunctionDef_fun_def(self, 
        inher_aux : InherAux,
        decs_tree : decorators, 
        decs_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (decs_aux,), 'function_def') 
    
    # traverse stmt <-- DecClassDef"
    def traverse_stmt_DecClassDef_decs(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'decorators') 
    
    # traverse stmt <-- DecClassDef"
    def traverse_stmt_DecClassDef_class_def(self, 
        inher_aux : InherAux,
        decs_tree : decorators, 
        decs_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (decs_aux,), 'ClassDef') 
    
    # traverse stmt <-- ReturnSomething"
    def traverse_stmt_ReturnSomething_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- Delete"
    def traverse_stmt_Delete_targets(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'comma_exprs') 
    
    # traverse stmt <-- Assign"
    def traverse_stmt_Assign_targets(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'target_exprs') 
    
    # traverse stmt <-- Assign"
    def traverse_stmt_Assign_content(self, 
        inher_aux : InherAux,
        targets_tree : target_exprs, 
        targets_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (targets_aux,), 'expr') 
    
    # traverse stmt <-- AugAssign"
    def traverse_stmt_AugAssign_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AugAssign"
    def traverse_stmt_AugAssign_op(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'bin_rator') 
    
    # traverse stmt <-- AugAssign"
    def traverse_stmt_AugAssign_content(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        op_tree : bin_rator, 
        op_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, op_aux,), 'expr') 
    
    # traverse stmt <-- AnnoAssign"
    def traverse_stmt_AnnoAssign_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AnnoAssign"
    def traverse_stmt_AnnoAssign_anno(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- AnnoAssign"
    def traverse_stmt_AnnoAssign_content(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        anno_tree : expr, 
        anno_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, anno_aux,), 'expr') 
    
    # traverse stmt <-- AnnoDeclar"
    def traverse_stmt_AnnoDeclar_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AnnoDeclar"
    def traverse_stmt_AnnoDeclar_anno(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- For"
    def traverse_stmt_For_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- For"
    def traverse_stmt_For_iter(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- For"
    def traverse_stmt_For_comment(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux,), 'str') 
    
    # traverse stmt <-- For"
    def traverse_stmt_For_body(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- ForElse"
    def traverse_stmt_ForElse_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- ForElse"
    def traverse_stmt_ForElse_iter(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- ForElse"
    def traverse_stmt_ForElse_comment(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux,), 'str') 
    
    # traverse stmt <-- ForElse"
    def traverse_stmt_ForElse_body(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- ForElse"
    def traverse_stmt_ForElse_orelse(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux, body_aux,), 'ElseBlock') 
    
    # traverse stmt <-- AsyncFor"
    def traverse_stmt_AsyncFor_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AsyncFor"
    def traverse_stmt_AsyncFor_iter(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- AsyncFor"
    def traverse_stmt_AsyncFor_comment(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux,), 'str') 
    
    # traverse stmt <-- AsyncFor"
    def traverse_stmt_AsyncFor_body(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- AsyncForElse"
    def traverse_stmt_AsyncForElse_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AsyncForElse"
    def traverse_stmt_AsyncForElse_iter(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse stmt <-- AsyncForElse"
    def traverse_stmt_AsyncForElse_comment(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux,), 'str') 
    
    # traverse stmt <-- AsyncForElse"
    def traverse_stmt_AsyncForElse_body(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- AsyncForElse"
    def traverse_stmt_AsyncForElse_orelse(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, iter_aux, comment_aux, body_aux,), 'ElseBlock') 
    
    # traverse stmt <-- While"
    def traverse_stmt_While_test(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- While"
    def traverse_stmt_While_comment(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux,), 'str') 
    
    # traverse stmt <-- While"
    def traverse_stmt_While_body(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- WhileElse"
    def traverse_stmt_WhileElse_test(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- WhileElse"
    def traverse_stmt_WhileElse_comment(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux,), 'str') 
    
    # traverse stmt <-- WhileElse"
    def traverse_stmt_WhileElse_body(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- WhileElse"
    def traverse_stmt_WhileElse_orelse(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux, body_aux,), 'ElseBlock') 
    
    # traverse stmt <-- If"
    def traverse_stmt_If_test(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- If"
    def traverse_stmt_If_comment(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux,), 'str') 
    
    # traverse stmt <-- If"
    def traverse_stmt_If_body(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- If"
    def traverse_stmt_If_orelse(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux, body_aux,), 'conditions') 
    
    # traverse stmt <-- With"
    def traverse_stmt_With_items(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_with_item') 
    
    # traverse stmt <-- With"
    def traverse_stmt_With_comment(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (items_aux,), 'str') 
    
    # traverse stmt <-- With"
    def traverse_stmt_With_body(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (items_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- AsyncWith"
    def traverse_stmt_AsyncWith_items(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_with_item') 
    
    # traverse stmt <-- AsyncWith"
    def traverse_stmt_AsyncWith_comment(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (items_aux,), 'str') 
    
    # traverse stmt <-- AsyncWith"
    def traverse_stmt_AsyncWith_body(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (items_aux, comment_aux,), 'statements') 
    
    # traverse stmt <-- RaiseExc"
    def traverse_stmt_RaiseExc_exc(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- RaiseFrom"
    def traverse_stmt_RaiseFrom_exc(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- RaiseFrom"
    def traverse_stmt_RaiseFrom_caus(self, 
        inher_aux : InherAux,
        exc_tree : expr, 
        exc_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (exc_aux,), 'expr') 
    
    # traverse stmt <-- Try"
    def traverse_stmt_Try_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse stmt <-- Try"
    def traverse_stmt_Try_handlers(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'sequence_ExceptHandler') 
    
    # traverse stmt <-- TryElse"
    def traverse_stmt_TryElse_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse stmt <-- TryElse"
    def traverse_stmt_TryElse_handlers(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'sequence_ExceptHandler') 
    
    # traverse stmt <-- TryElse"
    def traverse_stmt_TryElse_orelse(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux, handlers_aux,), 'ElseBlock') 
    
    # traverse stmt <-- TryExceptFin"
    def traverse_stmt_TryExceptFin_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse stmt <-- TryExceptFin"
    def traverse_stmt_TryExceptFin_handlers(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'sequence_ExceptHandler') 
    
    # traverse stmt <-- TryExceptFin"
    def traverse_stmt_TryExceptFin_fin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux, handlers_aux,), 'FinallyBlock') 
    
    # traverse stmt <-- TryFin"
    def traverse_stmt_TryFin_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse stmt <-- TryFin"
    def traverse_stmt_TryFin_fin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'FinallyBlock') 
    
    # traverse stmt <-- TryElseFin"
    def traverse_stmt_TryElseFin_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'statements') 
    
    # traverse stmt <-- TryElseFin"
    def traverse_stmt_TryElseFin_handlers(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'sequence_ExceptHandler') 
    
    # traverse stmt <-- TryElseFin"
    def traverse_stmt_TryElseFin_orelse(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux, handlers_aux,), 'ElseBlock') 
    
    # traverse stmt <-- TryElseFin"
    def traverse_stmt_TryElseFin_fin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux, handlers_aux, orelse_aux,), 'FinallyBlock') 
    
    # traverse stmt <-- Assert"
    def traverse_stmt_Assert_test(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AssertMsg"
    def traverse_stmt_AssertMsg_test(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse stmt <-- AssertMsg"
    def traverse_stmt_AssertMsg_msg(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux,), 'expr') 
    
    # traverse stmt <-- Import"
    def traverse_stmt_Import_names(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_import_name') 
    
    # traverse stmt <-- ImportFrom"
    def traverse_stmt_ImportFrom_module(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse stmt <-- ImportFrom"
    def traverse_stmt_ImportFrom_names(self, 
        inher_aux : InherAux,
        module_tree : str, 
        module_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (module_aux,), 'sequence_import_name') 
    
    # traverse stmt <-- ImportWildCard"
    def traverse_stmt_ImportWildCard_module(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse stmt <-- Global"
    def traverse_stmt_Global_names(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_name') 
    
    # traverse stmt <-- Nonlocal"
    def traverse_stmt_Nonlocal_names(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_name') 
    
    # traverse stmt <-- Expr"
    def traverse_stmt_Expr_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- ParenExpr"
    def traverse_expr_ParenExpr_pre_comment(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse expr <-- ParenExpr"
    def traverse_expr_ParenExpr_content(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux,), 'expr') 
    
    # traverse expr <-- ParenExpr"
    def traverse_expr_ParenExpr_post_comment(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (pre_comment_aux, content_aux,), 'str') 
    
    # traverse expr <-- BoolOp"
    def traverse_expr_BoolOp_left(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- BoolOp"
    def traverse_expr_BoolOp_op(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux,), 'bool_rator') 
    
    # traverse expr <-- BoolOp"
    def traverse_expr_BoolOp_right(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        op_tree : bool_rator, 
        op_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux, op_aux,), 'expr') 
    
    # traverse expr <-- AssignExpr"
    def traverse_expr_AssignExpr_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- AssignExpr"
    def traverse_expr_AssignExpr_content(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse expr <-- BinOp"
    def traverse_expr_BinOp_left(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- BinOp"
    def traverse_expr_BinOp_pre_comment(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux,), 'str') 
    
    # traverse expr <-- BinOp"
    def traverse_expr_BinOp_rator(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux, pre_comment_aux,), 'bin_rator') 
    
    # traverse expr <-- BinOp"
    def traverse_expr_BinOp_post_comment(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        rator_tree : bin_rator, 
        rator_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux, pre_comment_aux, rator_aux,), 'str') 
    
    # traverse expr <-- BinOp"
    def traverse_expr_BinOp_right(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        rator_tree : bin_rator, 
        rator_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux, pre_comment_aux, rator_aux, post_comment_aux,), 'expr') 
    
    # traverse expr <-- UnaryOp"
    def traverse_expr_UnaryOp_rator(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'unary_rator') 
    
    # traverse expr <-- UnaryOp"
    def traverse_expr_UnaryOp_comment(self, 
        inher_aux : InherAux,
        rator_tree : unary_rator, 
        rator_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (rator_aux,), 'str') 
    
    # traverse expr <-- UnaryOp"
    def traverse_expr_UnaryOp_rand(self, 
        inher_aux : InherAux,
        rator_tree : unary_rator, 
        rator_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (rator_aux, comment_aux,), 'expr') 
    
    # traverse expr <-- Lambda"
    def traverse_expr_Lambda_params(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'parameters') 
    
    # traverse expr <-- Lambda"
    def traverse_expr_Lambda_body(self, 
        inher_aux : InherAux,
        params_tree : parameters, 
        params_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (params_aux,), 'expr') 
    
    # traverse expr <-- IfExp"
    def traverse_expr_IfExp_body(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- IfExp"
    def traverse_expr_IfExp_test(self, 
        inher_aux : InherAux,
        body_tree : expr, 
        body_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux,), 'expr') 
    
    # traverse expr <-- IfExp"
    def traverse_expr_IfExp_orelse(self, 
        inher_aux : InherAux,
        body_tree : expr, 
        body_aux : SynthAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (body_aux, test_aux,), 'expr') 
    
    # traverse expr <-- Dictionary"
    def traverse_expr_Dictionary_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'dictionary_content') 
    
    # traverse expr <-- Set"
    def traverse_expr_Set_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'comma_exprs') 
    
    # traverse expr <-- ListComp"
    def traverse_expr_ListComp_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- ListComp"
    def traverse_expr_ListComp_constraints(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'comprehension_constraints') 
    
    # traverse expr <-- SetComp"
    def traverse_expr_SetComp_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- SetComp"
    def traverse_expr_SetComp_constraints(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'comprehension_constraints') 
    
    # traverse expr <-- DictionaryComp"
    def traverse_expr_DictionaryComp_key(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- DictionaryComp"
    def traverse_expr_DictionaryComp_content(self, 
        inher_aux : InherAux,
        key_tree : expr, 
        key_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (key_aux,), 'expr') 
    
    # traverse expr <-- DictionaryComp"
    def traverse_expr_DictionaryComp_constraints(self, 
        inher_aux : InherAux,
        key_tree : expr, 
        key_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (key_aux, content_aux,), 'comprehension_constraints') 
    
    # traverse expr <-- GeneratorExp"
    def traverse_expr_GeneratorExp_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- GeneratorExp"
    def traverse_expr_GeneratorExp_constraints(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'comprehension_constraints') 
    
    # traverse expr <-- Await"
    def traverse_expr_Await_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Yield"
    def traverse_expr_Yield_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- YieldFrom"
    def traverse_expr_YieldFrom_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Compare"
    def traverse_expr_Compare_left(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Compare"
    def traverse_expr_Compare_comps(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (left_aux,), 'comparisons') 
    
    # traverse expr <-- Call"
    def traverse_expr_Call_func(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- CallArgs"
    def traverse_expr_CallArgs_func(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- CallArgs"
    def traverse_expr_CallArgs_args(self, 
        inher_aux : InherAux,
        func_tree : expr, 
        func_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (func_aux,), 'arguments') 
    
    # traverse expr <-- Integer"
    def traverse_expr_Integer_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse expr <-- Float"
    def traverse_expr_Float_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse expr <-- ConcatString"
    def traverse_expr_ConcatString_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'sequence_string') 
    
    # traverse expr <-- Attribute"
    def traverse_expr_Attribute_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Attribute"
    def traverse_expr_Attribute_name(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'str') 
    
    # traverse expr <-- Subscript"
    def traverse_expr_Subscript_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Subscript"
    def traverse_expr_Subscript_slice(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (content_aux,), 'expr') 
    
    # traverse expr <-- Starred"
    def traverse_expr_Starred_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse expr <-- Name"
    def traverse_expr_Name_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse expr <-- List"
    def traverse_expr_List_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'comma_exprs') 
    
    # traverse expr <-- Tuple"
    def traverse_expr_Tuple_content(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'comma_exprs') 
    
    # traverse expr <-- Slice"
    def traverse_expr_Slice_lower(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'option_expr') 
    
    # traverse expr <-- Slice"
    def traverse_expr_Slice_upper(self, 
        inher_aux : InherAux,
        lower_tree : option_expr, 
        lower_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (lower_aux,), 'option_expr') 
    
    # traverse expr <-- Slice"
    def traverse_expr_Slice_step(self, 
        inher_aux : InherAux,
        lower_tree : option_expr, 
        lower_aux : SynthAux,
        upper_tree : option_expr, 
        upper_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (lower_aux, upper_aux,), 'option_expr') 
    
    # traverse constraint <-- AsyncConstraint"
    def traverse_constraint_AsyncConstraint_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse constraint <-- AsyncConstraint"
    def traverse_constraint_AsyncConstraint_search_space(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse constraint <-- AsyncConstraint"
    def traverse_constraint_AsyncConstraint_filts(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        search_space_tree : expr, 
        search_space_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, search_space_aux,), 'constraint_filters') 
    
    # traverse constraint <-- Constraint"
    def traverse_constraint_Constraint_target(self, 
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse constraint <-- Constraint"
    def traverse_constraint_Constraint_search_space(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux,), 'expr') 
    
    # traverse constraint <-- Constraint"
    def traverse_constraint_Constraint_filts(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        search_space_tree : expr, 
        search_space_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (target_aux, search_space_aux,), 'constraint_filters') 
     
    
    # traverse CompareRight
    def traverse_CompareRight_rator(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'cmp_rator') 
    
    # traverse CompareRight
    def traverse_CompareRight_rand(self,
        inher_aux : InherAux,
        rator_tree : cmp_rator, 
        rator_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (rator_aux,), 'expr') 
    
    # traverse ExceptHandler
    def traverse_ExceptHandler_arg(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'except_arg') 
    
    # traverse ExceptHandler
    def traverse_ExceptHandler_comment(self,
        inher_aux : InherAux,
        arg_tree : except_arg, 
        arg_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (arg_aux,), 'str') 
    
    # traverse ExceptHandler
    def traverse_ExceptHandler_body(self,
        inher_aux : InherAux,
        arg_tree : except_arg, 
        arg_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (arg_aux, comment_aux,), 'statements') 
    
    # traverse Param
    def traverse_Param_name(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse Param
    def traverse_Param_anno(self,
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'param_annotation') 
    
    # traverse Param
    def traverse_Param_default(self,
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        anno_tree : param_annotation, 
        anno_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, anno_aux,), 'param_default') 
    
    # traverse ClassDef
    def traverse_ClassDef_name(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse ClassDef
    def traverse_ClassDef_bs(self,
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux,), 'bases') 
    
    # traverse ClassDef
    def traverse_ClassDef_comment(self,
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        bs_tree : bases, 
        bs_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, bs_aux,), 'str') 
    
    # traverse ClassDef
    def traverse_ClassDef_body(self,
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        bs_tree : bases, 
        bs_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (name_aux, bs_aux, comment_aux,), 'statements') 
    
    # traverse ElifBlock
    def traverse_ElifBlock_test(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'expr') 
    
    # traverse ElifBlock
    def traverse_ElifBlock_comment(self,
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux,), 'str') 
    
    # traverse ElifBlock
    def traverse_ElifBlock_body(self,
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (test_aux, comment_aux,), 'statements') 
    
    # traverse ElseBlock
    def traverse_ElseBlock_comment(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse ElseBlock
    def traverse_ElseBlock_body(self,
        inher_aux : InherAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (comment_aux,), 'statements') 
    
    # traverse FinallyBlock
    def traverse_FinallyBlock_comment(self,
        inher_aux : InherAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (), 'str') 
    
    # traverse FinallyBlock
    def traverse_FinallyBlock_body(self,
        inher_aux : InherAux,
        comment_tree : str, 
        comment_aux : SynthAux
    ) -> InherAux:
        return self.traverse_auxes(inher_aux, (comment_aux,), 'statements') 
     

    
    # synthesize: return_annotation <-- SomeReturnAnno
    def synthesize_for_return_annotation_SomeReturnAnno(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeReturnAnno(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: return_annotation <-- NoReturnAnno
    def synthesize_for_return_annotation_NoReturnAnno(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoReturnAnno(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: except_arg <-- SomeExceptArg
    def synthesize_for_except_arg_SomeExceptArg(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeExceptArg(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: except_arg <-- SomeExceptArgName
    def synthesize_for_except_arg_SomeExceptArgName(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeExceptArgName(content_tree, name_tree),
            aux = self.synthesize_auxes((content_aux, name_aux,)) 
        )
    
    # synthesize: except_arg <-- NoExceptArg
    def synthesize_for_except_arg_NoExceptArg(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoExceptArg(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: param_annotation <-- SomeParamAnno
    def synthesize_for_param_annotation_SomeParamAnno(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeParamAnno(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: param_annotation <-- NoParamAnno
    def synthesize_for_param_annotation_NoParamAnno(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoParamAnno(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: param_default <-- SomeParamDefault
    def synthesize_for_param_default_SomeParamDefault(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeParamDefault(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: param_default <-- NoParamDefault
    def synthesize_for_param_default_NoParamDefault(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoParamDefault(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: parameters_d <-- ConsKwParam
    def synthesize_for_parameters_d_ConsKwParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : parameters_d, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsKwParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters_d <-- SingleKwParam
    def synthesize_for_parameters_d_SingleKwParam(self, 
        inher_aux : InherAux,
        content_tree : Param, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleKwParam(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_d <-- TransKwParam
    def synthesize_for_parameters_d_TransKwParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : Param, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TransKwParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters_c <-- SingleTupleBundleParam
    def synthesize_for_parameters_c_SingleTupleBundleParam(self, 
        inher_aux : InherAux,
        content_tree : Param, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleTupleBundleParam(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_c <-- TransTupleBundleParam
    def synthesize_for_parameters_c_TransTupleBundleParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : parameters_d, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TransTupleBundleParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters_c <-- ParamsD
    def synthesize_for_parameters_c_ParamsD(self, 
        inher_aux : InherAux,
        content_tree : parameters_d, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ParamsD(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_c <-- DoubleBundleParam
    def synthesize_for_parameters_c_DoubleBundleParam(self, 
        inher_aux : InherAux,
        tuple_param_tree : Param, 
        tuple_param_aux : SynthAux,
        dict_param_tree : Param, 
        dict_param_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DoubleBundleParam(tuple_param_tree, dict_param_tree),
            aux = self.synthesize_auxes((tuple_param_aux, dict_param_aux,)) 
        )
    
    # synthesize: parameters_c <-- DictionaryBundleParam
    def synthesize_for_parameters_c_DictionaryBundleParam(self, 
        inher_aux : InherAux,
        content_tree : Param, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DictionaryBundleParam(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_b <-- ConsPosKeyParam
    def synthesize_for_parameters_b_ConsPosKeyParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : parameters_b, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsPosKeyParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters_b <-- SinglePosKeyParam
    def synthesize_for_parameters_b_SinglePosKeyParam(self, 
        inher_aux : InherAux,
        content_tree : Param, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SinglePosKeyParam(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_b <-- ParamsC
    def synthesize_for_parameters_b_ParamsC(self, 
        inher_aux : InherAux,
        content_tree : parameters_c, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ParamsC(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_a <-- ConsPosParam
    def synthesize_for_parameters_a_ConsPosParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : parameters_a, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsPosParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters_a <-- SinglePosParam
    def synthesize_for_parameters_a_SinglePosParam(self, 
        inher_aux : InherAux,
        content_tree : Param, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SinglePosParam(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters_a <-- TransPosParam
    def synthesize_for_parameters_a_TransPosParam(self, 
        inher_aux : InherAux,
        head_tree : Param, 
        head_aux : SynthAux,
        tail_tree : parameters_b, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TransPosParam(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: parameters <-- ParamsA
    def synthesize_for_parameters_ParamsA(self, 
        inher_aux : InherAux,
        content_tree : parameters_a, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ParamsA(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters <-- ParamsB
    def synthesize_for_parameters_ParamsB(self, 
        inher_aux : InherAux,
        content_tree : parameters_b, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ParamsB(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: parameters <-- NoParam
    def synthesize_for_parameters_NoParam(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoParam(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: keyword <-- NamedKeyword
    def synthesize_for_keyword_NamedKeyword(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NamedKeyword(name_tree, content_tree),
            aux = self.synthesize_auxes((name_aux, content_aux,)) 
        )
    
    # synthesize: keyword <-- SplatKeyword
    def synthesize_for_keyword_SplatKeyword(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SplatKeyword(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: import_name <-- ImportNameAlias
    def synthesize_for_import_name_ImportNameAlias(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        alias_tree : str, 
        alias_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ImportNameAlias(name_tree, alias_tree),
            aux = self.synthesize_auxes((name_aux, alias_aux,)) 
        )
    
    # synthesize: import_name <-- ImportNameOnly
    def synthesize_for_import_name_ImportNameOnly(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ImportNameOnly(name_tree),
            aux = self.synthesize_auxes((name_aux,)) 
        )
    
    # synthesize: with_item <-- WithItemAlias
    def synthesize_for_with_item_WithItemAlias(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        alias_tree : expr, 
        alias_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_WithItemAlias(content_tree, alias_tree),
            aux = self.synthesize_auxes((content_aux, alias_aux,)) 
        )
    
    # synthesize: with_item <-- WithItemOnly
    def synthesize_for_with_item_WithItemOnly(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_WithItemOnly(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: bases <-- SomeBases
    def synthesize_for_bases_SomeBases(self, 
        inher_aux : InherAux,
        bases_tree : bases_a, 
        bases_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeBases(bases_tree),
            aux = self.synthesize_auxes((bases_aux,)) 
        )
    
    # synthesize: bases <-- NoBases
    def synthesize_for_bases_NoBases(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoBases(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bases_a <-- ConsBase
    def synthesize_for_bases_a_ConsBase(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux,
        tail_tree : bases_a, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsBase(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: bases_a <-- SingleBase
    def synthesize_for_bases_a_SingleBase(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleBase(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: bases_a <-- KeywordBases
    def synthesize_for_bases_a_KeywordBases(self, 
        inher_aux : InherAux,
        kws_tree : keywords, 
        kws_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_KeywordBases(kws_tree),
            aux = self.synthesize_auxes((kws_aux,)) 
        )
    
    # synthesize: keywords <-- ConsKeyword
    def synthesize_for_keywords_ConsKeyword(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : keyword, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux,
        tail_tree : keywords, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsKeyword(pre_comment_tree, head_tree, post_comment_tree, tail_tree),
            aux = self.synthesize_auxes((pre_comment_aux, head_aux, post_comment_aux, tail_aux,)) 
        )
    
    # synthesize: keywords <-- SingleKeyword
    def synthesize_for_keywords_SingleKeyword(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : keyword, 
        content_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleKeyword(pre_comment_tree, content_tree, post_comment_tree),
            aux = self.synthesize_auxes((pre_comment_aux, content_aux, post_comment_aux,)) 
        )
    
    # synthesize: comparisons <-- ConsCompareRight
    def synthesize_for_comparisons_ConsCompareRight(self, 
        inher_aux : InherAux,
        head_tree : CompareRight, 
        head_aux : SynthAux,
        tail_tree : comparisons, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsCompareRight(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: comparisons <-- SingleCompareRight
    def synthesize_for_comparisons_SingleCompareRight(self, 
        inher_aux : InherAux,
        content_tree : CompareRight, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleCompareRight(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: option_expr <-- SomeExpr
    def synthesize_for_option_expr_SomeExpr(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SomeExpr(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: option_expr <-- NoExpr
    def synthesize_for_option_expr_NoExpr(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoExpr(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: comma_exprs <-- ConsExpr
    def synthesize_for_comma_exprs_ConsExpr(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux,
        tail_tree : comma_exprs, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsExpr(pre_comment_tree, head_tree, post_comment_tree, tail_tree),
            aux = self.synthesize_auxes((pre_comment_aux, head_aux, post_comment_aux, tail_aux,)) 
        )
    
    # synthesize: comma_exprs <-- SingleExpr
    def synthesize_for_comma_exprs_SingleExpr(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleExpr(pre_comment_tree, content_tree, post_comment_tree),
            aux = self.synthesize_auxes((pre_comment_aux, content_aux, post_comment_aux,)) 
        )
    
    # synthesize: target_exprs <-- ConsTargetExpr
    def synthesize_for_target_exprs_ConsTargetExpr(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux,
        tail_tree : target_exprs, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsTargetExpr(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: target_exprs <-- SingleTargetExpr
    def synthesize_for_target_exprs_SingleTargetExpr(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleTargetExpr(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: decorator <-- ExprDec
    def synthesize_for_decorator_ExprDec(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ExprDec(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: decorator <-- CmntDec
    def synthesize_for_decorator_CmntDec(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_CmntDec(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: decorators <-- ConsDec
    def synthesize_for_decorators_ConsDec(self, 
        inher_aux : InherAux,
        head_tree : decorator, 
        head_aux : SynthAux,
        tail_tree : decorators, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsDec(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: decorators <-- NoDec
    def synthesize_for_decorators_NoDec(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoDec(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: constraint_filters <-- ConsFilter
    def synthesize_for_constraint_filters_ConsFilter(self, 
        inher_aux : InherAux,
        head_tree : expr, 
        head_aux : SynthAux,
        tail_tree : constraint_filters, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsFilter(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: constraint_filters <-- SingleFilter
    def synthesize_for_constraint_filters_SingleFilter(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleFilter(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: constraint_filters <-- NoFilter
    def synthesize_for_constraint_filters_NoFilter(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoFilter(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: sequence_string <-- ConsStr
    def synthesize_for_sequence_string_ConsStr(self, 
        inher_aux : InherAux,
        head_tree : str, 
        head_aux : SynthAux,
        tail_tree : sequence_string, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsStr(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: sequence_string <-- SingleStr
    def synthesize_for_sequence_string_SingleStr(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleStr(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: arguments <-- ConsArg
    def synthesize_for_arguments_ConsArg(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        head_tree : expr, 
        head_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux,
        tail_tree : arguments, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsArg(pre_comment_tree, head_tree, post_comment_tree, tail_tree),
            aux = self.synthesize_auxes((pre_comment_aux, head_aux, post_comment_aux, tail_aux,)) 
        )
    
    # synthesize: arguments <-- SingleArg
    def synthesize_for_arguments_SingleArg(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleArg(pre_comment_tree, content_tree, post_comment_tree),
            aux = self.synthesize_auxes((pre_comment_aux, content_aux, post_comment_aux,)) 
        )
    
    # synthesize: arguments <-- KeywordsArg
    def synthesize_for_arguments_KeywordsArg(self, 
        inher_aux : InherAux,
        kws_tree : keywords, 
        kws_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_KeywordsArg(kws_tree),
            aux = self.synthesize_auxes((kws_aux,)) 
        )
    
    # synthesize: dictionary_item <-- Field
    def synthesize_for_dictionary_item_Field(self, 
        inher_aux : InherAux,
        key_tree : expr, 
        key_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Field(key_tree, content_tree),
            aux = self.synthesize_auxes((key_aux, content_aux,)) 
        )
    
    # synthesize: dictionary_item <-- DictionarySplatFields
    def synthesize_for_dictionary_item_DictionarySplatFields(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DictionarySplatFields(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: dictionary_content <-- ConsDictionaryItem
    def synthesize_for_dictionary_content_ConsDictionaryItem(self, 
        inher_aux : InherAux,
        head_tree : dictionary_item, 
        head_aux : SynthAux,
        tail_tree : dictionary_content, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsDictionaryItem(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: dictionary_content <-- SingleDictionaryItem
    def synthesize_for_dictionary_content_SingleDictionaryItem(self, 
        inher_aux : InherAux,
        content_tree : dictionary_item, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleDictionaryItem(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: sequence_name <-- ConsId
    def synthesize_for_sequence_name_ConsId(self, 
        inher_aux : InherAux,
        head_tree : str, 
        head_aux : SynthAux,
        tail_tree : sequence_name, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsId(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: sequence_name <-- SingleId
    def synthesize_for_sequence_name_SingleId(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleId(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: sequence_import_name <-- ConsImportName
    def synthesize_for_sequence_import_name_ConsImportName(self, 
        inher_aux : InherAux,
        head_tree : import_name, 
        head_aux : SynthAux,
        tail_tree : sequence_import_name, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsImportName(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: sequence_import_name <-- SingleImportName
    def synthesize_for_sequence_import_name_SingleImportName(self, 
        inher_aux : InherAux,
        content_tree : import_name, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleImportName(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: sequence_with_item <-- ConsWithItem
    def synthesize_for_sequence_with_item_ConsWithItem(self, 
        inher_aux : InherAux,
        head_tree : with_item, 
        head_aux : SynthAux,
        tail_tree : sequence_with_item, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsWithItem(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: sequence_with_item <-- SingleWithItem
    def synthesize_for_sequence_with_item_SingleWithItem(self, 
        inher_aux : InherAux,
        content_tree : with_item, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleWithItem(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: module <-- FutureMod
    def synthesize_for_module_FutureMod(self, 
        inher_aux : InherAux,
        names_tree : sequence_import_name, 
        names_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_FutureMod(names_tree, body_tree),
            aux = self.synthesize_auxes((names_aux, body_aux,)) 
        )
    
    # synthesize: module <-- SimpleMod
    def synthesize_for_module_SimpleMod(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SimpleMod(body_tree),
            aux = self.synthesize_auxes((body_aux,)) 
        )
    
    # synthesize: statements <-- ConsStmt
    def synthesize_for_statements_ConsStmt(self, 
        inher_aux : InherAux,
        head_tree : stmt, 
        head_aux : SynthAux,
        tail_tree : statements, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsStmt(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: statements <-- SingleStmt
    def synthesize_for_statements_SingleStmt(self, 
        inher_aux : InherAux,
        content_tree : stmt, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleStmt(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: comprehension_constraints <-- ConsConstraint
    def synthesize_for_comprehension_constraints_ConsConstraint(self, 
        inher_aux : InherAux,
        head_tree : constraint, 
        head_aux : SynthAux,
        tail_tree : comprehension_constraints, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsConstraint(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: comprehension_constraints <-- SingleConstraint
    def synthesize_for_comprehension_constraints_SingleConstraint(self, 
        inher_aux : InherAux,
        content_tree : constraint, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleConstraint(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: sequence_ExceptHandler <-- ConsExceptHandler
    def synthesize_for_sequence_ExceptHandler_ConsExceptHandler(self, 
        inher_aux : InherAux,
        head_tree : ExceptHandler, 
        head_aux : SynthAux,
        tail_tree : sequence_ExceptHandler, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConsExceptHandler(head_tree, tail_tree),
            aux = self.synthesize_auxes((head_aux, tail_aux,)) 
        )
    
    # synthesize: sequence_ExceptHandler <-- SingleExceptHandler
    def synthesize_for_sequence_ExceptHandler_SingleExceptHandler(self, 
        inher_aux : InherAux,
        content_tree : ExceptHandler, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SingleExceptHandler(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: conditions <-- ElifCond
    def synthesize_for_conditions_ElifCond(self, 
        inher_aux : InherAux,
        content_tree : ElifBlock, 
        content_aux : SynthAux,
        tail_tree : conditions, 
        tail_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ElifCond(content_tree, tail_tree),
            aux = self.synthesize_auxes((content_aux, tail_aux,)) 
        )
    
    # synthesize: conditions <-- ElseCond
    def synthesize_for_conditions_ElseCond(self, 
        inher_aux : InherAux,
        content_tree : ElseBlock, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ElseCond(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: conditions <-- NoCond
    def synthesize_for_conditions_NoCond(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NoCond(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: function_def <-- FunctionDef
    def synthesize_for_function_def_FunctionDef(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_FunctionDef(name_tree, params_tree, ret_anno_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((name_aux, params_aux, ret_anno_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: function_def <-- AsyncFunctionDef
    def synthesize_for_function_def_AsyncFunctionDef(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        ret_anno_tree : return_annotation, 
        ret_anno_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AsyncFunctionDef(name_tree, params_tree, ret_anno_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((name_aux, params_aux, ret_anno_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- Comment
    def synthesize_for_stmt_Comment(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Comment(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: stmt <-- DecFunctionDef
    def synthesize_for_stmt_DecFunctionDef(self, 
        inher_aux : InherAux,
        decs_tree : decorators, 
        decs_aux : SynthAux,
        fun_def_tree : function_def, 
        fun_def_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DecFunctionDef(decs_tree, fun_def_tree),
            aux = self.synthesize_auxes((decs_aux, fun_def_aux,)) 
        )
    
    # synthesize: stmt <-- DecClassDef
    def synthesize_for_stmt_DecClassDef(self, 
        inher_aux : InherAux,
        decs_tree : decorators, 
        decs_aux : SynthAux,
        class_def_tree : ClassDef, 
        class_def_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DecClassDef(decs_tree, class_def_tree),
            aux = self.synthesize_auxes((decs_aux, class_def_aux,)) 
        )
    
    # synthesize: stmt <-- ReturnSomething
    def synthesize_for_stmt_ReturnSomething(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ReturnSomething(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: stmt <-- Return
    def synthesize_for_stmt_Return(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Return(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: stmt <-- Delete
    def synthesize_for_stmt_Delete(self, 
        inher_aux : InherAux,
        targets_tree : comma_exprs, 
        targets_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Delete(targets_tree),
            aux = self.synthesize_auxes((targets_aux,)) 
        )
    
    # synthesize: stmt <-- Assign
    def synthesize_for_stmt_Assign(self, 
        inher_aux : InherAux,
        targets_tree : target_exprs, 
        targets_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Assign(targets_tree, content_tree),
            aux = self.synthesize_auxes((targets_aux, content_aux,)) 
        )
    
    # synthesize: stmt <-- AugAssign
    def synthesize_for_stmt_AugAssign(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        op_tree : bin_rator, 
        op_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AugAssign(target_tree, op_tree, content_tree),
            aux = self.synthesize_auxes((target_aux, op_aux, content_aux,)) 
        )
    
    # synthesize: stmt <-- AnnoAssign
    def synthesize_for_stmt_AnnoAssign(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        anno_tree : expr, 
        anno_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AnnoAssign(target_tree, anno_tree, content_tree),
            aux = self.synthesize_auxes((target_aux, anno_aux, content_aux,)) 
        )
    
    # synthesize: stmt <-- AnnoDeclar
    def synthesize_for_stmt_AnnoDeclar(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        anno_tree : expr, 
        anno_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AnnoDeclar(target_tree, anno_tree),
            aux = self.synthesize_auxes((target_aux, anno_aux,)) 
        )
    
    # synthesize: stmt <-- For
    def synthesize_for_stmt_For(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_For(target_tree, iter_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((target_aux, iter_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- ForElse
    def synthesize_for_stmt_ForElse(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ForElse(target_tree, iter_tree, comment_tree, body_tree, orelse_tree),
            aux = self.synthesize_auxes((target_aux, iter_aux, comment_aux, body_aux, orelse_aux,)) 
        )
    
    # synthesize: stmt <-- AsyncFor
    def synthesize_for_stmt_AsyncFor(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AsyncFor(target_tree, iter_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((target_aux, iter_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- AsyncForElse
    def synthesize_for_stmt_AsyncForElse(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        iter_tree : expr, 
        iter_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AsyncForElse(target_tree, iter_tree, comment_tree, body_tree, orelse_tree),
            aux = self.synthesize_auxes((target_aux, iter_aux, comment_aux, body_aux, orelse_aux,)) 
        )
    
    # synthesize: stmt <-- While
    def synthesize_for_stmt_While(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_While(test_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((test_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- WhileElse
    def synthesize_for_stmt_WhileElse(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_WhileElse(test_tree, comment_tree, body_tree, orelse_tree),
            aux = self.synthesize_auxes((test_aux, comment_aux, body_aux, orelse_aux,)) 
        )
    
    # synthesize: stmt <-- If
    def synthesize_for_stmt_If(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux,
        orelse_tree : conditions, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_If(test_tree, comment_tree, body_tree, orelse_tree),
            aux = self.synthesize_auxes((test_aux, comment_aux, body_aux, orelse_aux,)) 
        )
    
    # synthesize: stmt <-- With
    def synthesize_for_stmt_With(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_With(items_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((items_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- AsyncWith
    def synthesize_for_stmt_AsyncWith(self, 
        inher_aux : InherAux,
        items_tree : sequence_with_item, 
        items_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AsyncWith(items_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((items_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: stmt <-- Raise
    def synthesize_for_stmt_Raise(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Raise(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: stmt <-- RaiseExc
    def synthesize_for_stmt_RaiseExc(self, 
        inher_aux : InherAux,
        exc_tree : expr, 
        exc_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_RaiseExc(exc_tree),
            aux = self.synthesize_auxes((exc_aux,)) 
        )
    
    # synthesize: stmt <-- RaiseFrom
    def synthesize_for_stmt_RaiseFrom(self, 
        inher_aux : InherAux,
        exc_tree : expr, 
        exc_aux : SynthAux,
        caus_tree : expr, 
        caus_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_RaiseFrom(exc_tree, caus_tree),
            aux = self.synthesize_auxes((exc_aux, caus_aux,)) 
        )
    
    # synthesize: stmt <-- Try
    def synthesize_for_stmt_Try(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Try(body_tree, handlers_tree),
            aux = self.synthesize_auxes((body_aux, handlers_aux,)) 
        )
    
    # synthesize: stmt <-- TryElse
    def synthesize_for_stmt_TryElse(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TryElse(body_tree, handlers_tree, orelse_tree),
            aux = self.synthesize_auxes((body_aux, handlers_aux, orelse_aux,)) 
        )
    
    # synthesize: stmt <-- TryExceptFin
    def synthesize_for_stmt_TryExceptFin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux,
        fin_tree : FinallyBlock, 
        fin_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TryExceptFin(body_tree, handlers_tree, fin_tree),
            aux = self.synthesize_auxes((body_aux, handlers_aux, fin_aux,)) 
        )
    
    # synthesize: stmt <-- TryFin
    def synthesize_for_stmt_TryFin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        fin_tree : FinallyBlock, 
        fin_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TryFin(body_tree, fin_tree),
            aux = self.synthesize_auxes((body_aux, fin_aux,)) 
        )
    
    # synthesize: stmt <-- TryElseFin
    def synthesize_for_stmt_TryElseFin(self, 
        inher_aux : InherAux,
        body_tree : statements, 
        body_aux : SynthAux,
        handlers_tree : sequence_ExceptHandler, 
        handlers_aux : SynthAux,
        orelse_tree : ElseBlock, 
        orelse_aux : SynthAux,
        fin_tree : FinallyBlock, 
        fin_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_TryElseFin(body_tree, handlers_tree, orelse_tree, fin_tree),
            aux = self.synthesize_auxes((body_aux, handlers_aux, orelse_aux, fin_aux,)) 
        )
    
    # synthesize: stmt <-- Assert
    def synthesize_for_stmt_Assert(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Assert(test_tree),
            aux = self.synthesize_auxes((test_aux,)) 
        )
    
    # synthesize: stmt <-- AssertMsg
    def synthesize_for_stmt_AssertMsg(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        msg_tree : expr, 
        msg_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AssertMsg(test_tree, msg_tree),
            aux = self.synthesize_auxes((test_aux, msg_aux,)) 
        )
    
    # synthesize: stmt <-- Import
    def synthesize_for_stmt_Import(self, 
        inher_aux : InherAux,
        names_tree : sequence_import_name, 
        names_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Import(names_tree),
            aux = self.synthesize_auxes((names_aux,)) 
        )
    
    # synthesize: stmt <-- ImportFrom
    def synthesize_for_stmt_ImportFrom(self, 
        inher_aux : InherAux,
        module_tree : str, 
        module_aux : SynthAux,
        names_tree : sequence_import_name, 
        names_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ImportFrom(module_tree, names_tree),
            aux = self.synthesize_auxes((module_aux, names_aux,)) 
        )
    
    # synthesize: stmt <-- ImportWildCard
    def synthesize_for_stmt_ImportWildCard(self, 
        inher_aux : InherAux,
        module_tree : str, 
        module_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ImportWildCard(module_tree),
            aux = self.synthesize_auxes((module_aux,)) 
        )
    
    # synthesize: stmt <-- Global
    def synthesize_for_stmt_Global(self, 
        inher_aux : InherAux,
        names_tree : sequence_name, 
        names_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Global(names_tree),
            aux = self.synthesize_auxes((names_aux,)) 
        )
    
    # synthesize: stmt <-- Nonlocal
    def synthesize_for_stmt_Nonlocal(self, 
        inher_aux : InherAux,
        names_tree : sequence_name, 
        names_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Nonlocal(names_tree),
            aux = self.synthesize_auxes((names_aux,)) 
        )
    
    # synthesize: stmt <-- Expr
    def synthesize_for_stmt_Expr(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Expr(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: stmt <-- Pass
    def synthesize_for_stmt_Pass(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Pass(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: stmt <-- Break
    def synthesize_for_stmt_Break(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Break(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: stmt <-- Continue
    def synthesize_for_stmt_Continue(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Continue(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- ParenExpr
    def synthesize_for_expr_ParenExpr(self, 
        inher_aux : InherAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ParenExpr(pre_comment_tree, content_tree, post_comment_tree),
            aux = self.synthesize_auxes((pre_comment_aux, content_aux, post_comment_aux,)) 
        )
    
    # synthesize: expr <-- BoolOp
    def synthesize_for_expr_BoolOp(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        op_tree : bool_rator, 
        op_aux : SynthAux,
        right_tree : expr, 
        right_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_BoolOp(left_tree, op_tree, right_tree),
            aux = self.synthesize_auxes((left_aux, op_aux, right_aux,)) 
        )
    
    # synthesize: expr <-- AssignExpr
    def synthesize_for_expr_AssignExpr(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AssignExpr(target_tree, content_tree),
            aux = self.synthesize_auxes((target_aux, content_aux,)) 
        )
    
    # synthesize: expr <-- BinOp
    def synthesize_for_expr_BinOp(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        pre_comment_tree : str, 
        pre_comment_aux : SynthAux,
        rator_tree : bin_rator, 
        rator_aux : SynthAux,
        post_comment_tree : str, 
        post_comment_aux : SynthAux,
        right_tree : expr, 
        right_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_BinOp(left_tree, pre_comment_tree, rator_tree, post_comment_tree, right_tree),
            aux = self.synthesize_auxes((left_aux, pre_comment_aux, rator_aux, post_comment_aux, right_aux,)) 
        )
    
    # synthesize: expr <-- UnaryOp
    def synthesize_for_expr_UnaryOp(self, 
        inher_aux : InherAux,
        rator_tree : unary_rator, 
        rator_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        rand_tree : expr, 
        rand_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_UnaryOp(rator_tree, comment_tree, rand_tree),
            aux = self.synthesize_auxes((rator_aux, comment_aux, rand_aux,)) 
        )
    
    # synthesize: expr <-- Lambda
    def synthesize_for_expr_Lambda(self, 
        inher_aux : InherAux,
        params_tree : parameters, 
        params_aux : SynthAux,
        body_tree : expr, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Lambda(params_tree, body_tree),
            aux = self.synthesize_auxes((params_aux, body_aux,)) 
        )
    
    # synthesize: expr <-- IfExp
    def synthesize_for_expr_IfExp(self, 
        inher_aux : InherAux,
        body_tree : expr, 
        body_aux : SynthAux,
        test_tree : expr, 
        test_aux : SynthAux,
        orelse_tree : expr, 
        orelse_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_IfExp(body_tree, test_tree, orelse_tree),
            aux = self.synthesize_auxes((body_aux, test_aux, orelse_aux,)) 
        )
    
    # synthesize: expr <-- Dictionary
    def synthesize_for_expr_Dictionary(self, 
        inher_aux : InherAux,
        content_tree : dictionary_content, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Dictionary(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- EmptyDictionary
    def synthesize_for_expr_EmptyDictionary(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_EmptyDictionary(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Set
    def synthesize_for_expr_Set(self, 
        inher_aux : InherAux,
        content_tree : comma_exprs, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Set(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- ListComp
    def synthesize_for_expr_ListComp(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        constraints_tree : comprehension_constraints, 
        constraints_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ListComp(content_tree, constraints_tree),
            aux = self.synthesize_auxes((content_aux, constraints_aux,)) 
        )
    
    # synthesize: expr <-- SetComp
    def synthesize_for_expr_SetComp(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        constraints_tree : comprehension_constraints, 
        constraints_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_SetComp(content_tree, constraints_tree),
            aux = self.synthesize_auxes((content_aux, constraints_aux,)) 
        )
    
    # synthesize: expr <-- DictionaryComp
    def synthesize_for_expr_DictionaryComp(self, 
        inher_aux : InherAux,
        key_tree : expr, 
        key_aux : SynthAux,
        content_tree : expr, 
        content_aux : SynthAux,
        constraints_tree : comprehension_constraints, 
        constraints_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_DictionaryComp(key_tree, content_tree, constraints_tree),
            aux = self.synthesize_auxes((key_aux, content_aux, constraints_aux,)) 
        )
    
    # synthesize: expr <-- GeneratorExp
    def synthesize_for_expr_GeneratorExp(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        constraints_tree : comprehension_constraints, 
        constraints_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_GeneratorExp(content_tree, constraints_tree),
            aux = self.synthesize_auxes((content_aux, constraints_aux,)) 
        )
    
    # synthesize: expr <-- Await
    def synthesize_for_expr_Await(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Await(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- YieldNothing
    def synthesize_for_expr_YieldNothing(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_YieldNothing(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Yield
    def synthesize_for_expr_Yield(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Yield(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- YieldFrom
    def synthesize_for_expr_YieldFrom(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_YieldFrom(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- Compare
    def synthesize_for_expr_Compare(self, 
        inher_aux : InherAux,
        left_tree : expr, 
        left_aux : SynthAux,
        comps_tree : comparisons, 
        comps_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Compare(left_tree, comps_tree),
            aux = self.synthesize_auxes((left_aux, comps_aux,)) 
        )
    
    # synthesize: expr <-- Call
    def synthesize_for_expr_Call(self, 
        inher_aux : InherAux,
        func_tree : expr, 
        func_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Call(func_tree),
            aux = self.synthesize_auxes((func_aux,)) 
        )
    
    # synthesize: expr <-- CallArgs
    def synthesize_for_expr_CallArgs(self, 
        inher_aux : InherAux,
        func_tree : expr, 
        func_aux : SynthAux,
        args_tree : arguments, 
        args_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_CallArgs(func_tree, args_tree),
            aux = self.synthesize_auxes((func_aux, args_aux,)) 
        )
    
    # synthesize: expr <-- Integer
    def synthesize_for_expr_Integer(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Integer(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- Float
    def synthesize_for_expr_Float(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Float(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- ConcatString
    def synthesize_for_expr_ConcatString(self, 
        inher_aux : InherAux,
        content_tree : sequence_string, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ConcatString(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- True_
    def synthesize_for_expr_True_(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_True_(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- False_
    def synthesize_for_expr_False_(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_False_(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- None_
    def synthesize_for_expr_None_(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_None_(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Ellip
    def synthesize_for_expr_Ellip(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Ellip(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Attribute
    def synthesize_for_expr_Attribute(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        name_tree : str, 
        name_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Attribute(content_tree, name_tree),
            aux = self.synthesize_auxes((content_aux, name_aux,)) 
        )
    
    # synthesize: expr <-- Subscript
    def synthesize_for_expr_Subscript(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux,
        slice_tree : expr, 
        slice_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Subscript(content_tree, slice_tree),
            aux = self.synthesize_auxes((content_aux, slice_aux,)) 
        )
    
    # synthesize: expr <-- Starred
    def synthesize_for_expr_Starred(self, 
        inher_aux : InherAux,
        content_tree : expr, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Starred(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- Name
    def synthesize_for_expr_Name(self, 
        inher_aux : InherAux,
        content_tree : str, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Name(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- List
    def synthesize_for_expr_List(self, 
        inher_aux : InherAux,
        content_tree : comma_exprs, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_List(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- EmptyList
    def synthesize_for_expr_EmptyList(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_EmptyList(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Tuple
    def synthesize_for_expr_Tuple(self, 
        inher_aux : InherAux,
        content_tree : comma_exprs, 
        content_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Tuple(content_tree),
            aux = self.synthesize_auxes((content_aux,)) 
        )
    
    # synthesize: expr <-- EmptyTuple
    def synthesize_for_expr_EmptyTuple(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_EmptyTuple(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: expr <-- Slice
    def synthesize_for_expr_Slice(self, 
        inher_aux : InherAux,
        lower_tree : option_expr, 
        lower_aux : SynthAux,
        upper_tree : option_expr, 
        upper_aux : SynthAux,
        step_tree : option_expr, 
        step_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Slice(lower_tree, upper_tree, step_tree),
            aux = self.synthesize_auxes((lower_aux, upper_aux, step_aux,)) 
        )
    
    # synthesize: bool_rator <-- And
    def synthesize_for_bool_rator_And(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_And(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bool_rator <-- Or
    def synthesize_for_bool_rator_Or(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Or(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Add
    def synthesize_for_bin_rator_Add(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Add(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Sub
    def synthesize_for_bin_rator_Sub(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Sub(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Mult
    def synthesize_for_bin_rator_Mult(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Mult(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- MatMult
    def synthesize_for_bin_rator_MatMult(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_MatMult(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Div
    def synthesize_for_bin_rator_Div(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Div(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Mod
    def synthesize_for_bin_rator_Mod(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Mod(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- Pow
    def synthesize_for_bin_rator_Pow(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Pow(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- LShift
    def synthesize_for_bin_rator_LShift(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_LShift(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- RShift
    def synthesize_for_bin_rator_RShift(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_RShift(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- BitOr
    def synthesize_for_bin_rator_BitOr(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_BitOr(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- BitXor
    def synthesize_for_bin_rator_BitXor(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_BitXor(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- BitAnd
    def synthesize_for_bin_rator_BitAnd(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_BitAnd(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: bin_rator <-- FloorDiv
    def synthesize_for_bin_rator_FloorDiv(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_FloorDiv(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: unary_rator <-- Invert
    def synthesize_for_unary_rator_Invert(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Invert(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: unary_rator <-- Not
    def synthesize_for_unary_rator_Not(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Not(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: unary_rator <-- UAdd
    def synthesize_for_unary_rator_UAdd(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_UAdd(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: unary_rator <-- USub
    def synthesize_for_unary_rator_USub(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_USub(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- Eq
    def synthesize_for_cmp_rator_Eq(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Eq(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- NotEq
    def synthesize_for_cmp_rator_NotEq(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NotEq(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- Lt
    def synthesize_for_cmp_rator_Lt(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Lt(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- LtE
    def synthesize_for_cmp_rator_LtE(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_LtE(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- Gt
    def synthesize_for_cmp_rator_Gt(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Gt(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- GtE
    def synthesize_for_cmp_rator_GtE(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_GtE(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- Is
    def synthesize_for_cmp_rator_Is(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Is(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- IsNot
    def synthesize_for_cmp_rator_IsNot(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_IsNot(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- In
    def synthesize_for_cmp_rator_In(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_In(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: cmp_rator <-- NotIn
    def synthesize_for_cmp_rator_NotIn(self, 
        inher_aux : InherAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_NotIn(),
            aux = self.synthesize_auxes(()) 
        )
    
    # synthesize: constraint <-- AsyncConstraint
    def synthesize_for_constraint_AsyncConstraint(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        search_space_tree : expr, 
        search_space_aux : SynthAux,
        filts_tree : constraint_filters, 
        filts_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_AsyncConstraint(target_tree, search_space_tree, filts_tree),
            aux = self.synthesize_auxes((target_aux, search_space_aux, filts_aux,)) 
        )
    
    # synthesize: constraint <-- Constraint
    def synthesize_for_constraint_Constraint(self, 
        inher_aux : InherAux,
        target_tree : expr, 
        target_aux : SynthAux,
        search_space_tree : expr, 
        search_space_aux : SynthAux,
        filts_tree : constraint_filters, 
        filts_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Constraint(target_tree, search_space_tree, filts_tree),
            aux = self.synthesize_auxes((target_aux, search_space_aux, filts_aux,)) 
        )
     
    
    # synthesize: CompareRight
    def synthesize_for_CompareRight(self, 
        inher_aux : InherAux,
        rator_tree : cmp_rator, 
        rator_aux : SynthAux,
        rand_tree : expr, 
        rand_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_CompareRight(rator_tree, rand_tree),
            aux = self.synthesize_auxes((rator_aux, rand_aux,)) 
        )
    
    # synthesize: ExceptHandler
    def synthesize_for_ExceptHandler(self, 
        inher_aux : InherAux,
        arg_tree : except_arg, 
        arg_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ExceptHandler(arg_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((arg_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: Param
    def synthesize_for_Param(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        anno_tree : param_annotation, 
        anno_aux : SynthAux,
        default_tree : param_default, 
        default_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_Param(name_tree, anno_tree, default_tree),
            aux = self.synthesize_auxes((name_aux, anno_aux, default_aux,)) 
        )
    
    # synthesize: ClassDef
    def synthesize_for_ClassDef(self, 
        inher_aux : InherAux,
        name_tree : str, 
        name_aux : SynthAux,
        bs_tree : bases, 
        bs_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ClassDef(name_tree, bs_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((name_aux, bs_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: ElifBlock
    def synthesize_for_ElifBlock(self, 
        inher_aux : InherAux,
        test_tree : expr, 
        test_aux : SynthAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ElifBlock(test_tree, comment_tree, body_tree),
            aux = self.synthesize_auxes((test_aux, comment_aux, body_aux,)) 
        )
    
    # synthesize: ElseBlock
    def synthesize_for_ElseBlock(self, 
        inher_aux : InherAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_ElseBlock(comment_tree, body_tree),
            aux = self.synthesize_auxes((comment_aux, body_aux,)) 
        )
    
    # synthesize: FinallyBlock
    def synthesize_for_FinallyBlock(self, 
        inher_aux : InherAux,
        comment_tree : str, 
        comment_aux : SynthAux,
        body_tree : statements, 
        body_aux : SynthAux
    ) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = make_FinallyBlock(comment_tree, body_tree),
            aux = self.synthesize_auxes((comment_aux, body_aux,)) 
        )
     



    def inspect_str(self, token : Vocab, inher_aux : InherAux) -> Result[SynthAux]:
        return Result[SynthAux](
            tree = token.selection,
            aux = self.synthesize_auxes(()) 
        ) 

    def crawl_str(self, token : abstract_token, inher_aux : InherAux) -> Result[SynthAux]:
        if not isinstance(token, Vocab): raise SyntaxError()
        return self.inspect_str(token, inher_aux)

    @abstractmethod
    def traverse_auxes(self, inher_aux : InherAux, synth_auxes : tuple[SynthAux, ...], target_syntax_type : str) -> InherAux:
        pass

    @abstractmethod
    def synthesize_auxes(self, auxes : tuple[SynthAux, ...]) -> SynthAux:
        pass

    